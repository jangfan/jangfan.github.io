---
title: 堆学习(一)
date: 2023-03-14 20:03:34
tags: pwn
categories: 学习笔记
---

**前言：栈草草的结束了，只掌握一些简单的rop利用，至于为什么这么早想学习堆，可能跟我的学习理念有关吧，我的学习理念是了解重要的学习框架，先将基础结构的相对简单的内容学会，再同步深入学习更深度的内容。现在相比较学习栈的其他花里胡哨的利用方式，我更想先学习堆的基本内容和简单利用**

# 什么是堆

堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。

 **堆的生长方向是从低地址向高地址生长的，而栈是从高地址向低地址生长的。**

实际上堆可以申请到的内存空间比栈要大很多，在 linux 的 4G 的虚拟内存空间里最高可以达到 2.9 G 的空间

> 对堆操作的**是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核**。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能

![](%E5%A0%86%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20120910.png)

俺以 **glibc 库下的 ptmalloc2 堆管理器**为例学习

## 堆的基本结构

![](%E5%A0%86%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20142218.png)

当用户通过**malloc**等函数申请空间时，实际上是从堆中分配内存，ptmalloc根据用户的需要，为用户分配不同类型的chunk

malloc_chunk结构

```c
struct malloc_chunk {
    INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */
    INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */
    
    struct malloc_chunk* fd; /* double links -- used only if free. */
    struct malloc_chunk* bk;
    
    /* Only used for large blocks: pointer to next larger size. */
    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
    struct malloc_chunk* bk_nextsize;
};

```

每个程序分配的内存(这里指的是malloc函数)，在内部被一个叫"堆块"的所替代。一个堆块是由程序返回内存组成的(实际上是malloc的返回值)。这块区域在申请新的内存的时候会不断扩大。同样，当一定数量的内存释放时，堆也可以收缩。

**1.pre_size 字段:** 只有在前面一个堆块是空闲的时候才有值，用来指示前一个堆块的大小。前面一个堆块在使用时，他的值始终为 0
**2.size 字段:** 是用来指示当前堆块的大小的（头部加上 user data 的大小）。但是这个字段的最后三位相当于三个 flag ，有另外的作用。

​      `NON_MAIN_ARENA`，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。

​      `IS_MAPPED`，记录当前 chunk 是否是由 mmap 分配的。

​      ` PREV_INUSE`，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 P 位都会被设置为 1，以便于防止访问前             面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。

**3..user data** 就是用来存放用户数据的。使用malloc函数分配到的内存的返回地址是指user data(用户数据区)

例如在64位程序中：

```c
malloc(8)
```

申请到的堆块总大小为 16 + 8 + 8 + 1 = 0x21

1.第一个 16 字节是**系统最小分配的内存**，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。

- 在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节
- 例如，如果代码中是 malloc(0) 的话，**堆管理器也会分配最小内存空间给你**

2.第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）
3.第三个 8 字节为 size 字段的大小（32 位的为 4 字节）
4.最后一个 1 字节是 **PREV_INUSE 的值，只有 0 或 1两个值**

## 指针与地址

首先要明确用户在调用 malloc 函数时返回的值为**一个指针，指向分配到堆空间（用户数据区）**

![](%E5%A0%86%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20151811.png)

first chunk（second chunk）表示第一和第二个结构，**每个结构中都有一个 point_heap 指针来指向存储用户数据的堆块（chunk）。**

**左边的这个本身就是一个堆块，用来存放一些全局信息**。比如 max_size 存储了能够存储的最大结构数量；exist_num 表示已经存储的结构的数量。

### IDA 中常见的指针表示形式

在 IDA 伪代码中的指针形式形如下面的情况：

```scss
*(qword_6020A8 + 8)
```

**表示取到 qword_6020A8 这个地址加 8 偏移的那个地址存储的值**

汇编代码等同于：

```makefile
.text:0000000000400F85                 mov     rax, cs:qword_6020A8
.text:0000000000400F8C                 mov     rax, [rax+8]
```

简单转化一下，也就是：

```undefined
*(addr) = [addr]
```

### 链表

在 pwn 的堆题目中，经常会有像一些”笔记管理系统”之类的题目，例如下面这里例子

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/9mQhGPF.png)

代码提供了最基本的增删查改的功能。这个”笔记”的数据结构**通常就是使用链表连接起来的**，记录了当前 note 的大小、属性、内容等等。

**例如，下面这个例子就是以指针为基础来存储这个 note 结构的**。这里的 i 代表 note 的索引，若这里的 i = 0 时：

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/n366Lzt.png)

*(qword_6020A8 + 16) 就**代表从 qword_6020A8 这个地址出再往后偏移 16 个字节，取到这个地址存储的值，接着把 1 赋值给这个地方（也就是把 1 存入这个地址）**

同样的 *(qword_6020A8 + 24) 就代表偏移 24 个字节处的值为 len

依次类推就可以在**不连续的内存空间中**，把整个 note 的数据结构存储下来了。

## 申请堆的本质

> 堆管理器 ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。

ptmalloc2 的作用通俗的讲就是**相当于一个”中间商”**，在程序想要申请向系统申请堆空间时，这里的 ptmalloc2 就会申请一块很大的空间，并根据算法从这些内存中把空间真正的分配给程序。

简单点说就是下面这个图中的情况：

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/OHeE6wZ.png)

例子

```c++
#include<stdio.h>
#include<malloc.h>
int main(){
    char *p;
    p=malloc(10);
    return 0;
}
```

在 gdb 中进行调试，在 call malloc 处下一个断点，**在这里使用 vmmap 命令，查看内存分布**。可以看到此时并没有发现堆段

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/AmbgBDz.png)

单步 n ，vmmap 命令再次查看内存，发现出现了堆段

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/4J2yIhn.png)

但是这里我们明明只是申请了 10 字节的大小，但是为什么这里的为什么给了这么大的堆段呢？

```undefined
0x00602000     ~    0x00623000
```

计算一下，刚好是 132 kB

```undefined
(0x00623000-0x00602000)/1024 = 132 kB
```

> 原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以这个区域叫做 main arena

也就是说这 132 KB 是”厂家”（内核）批发给”中间商”（ptmalloc2）的货物，**以便下次程序在向系统申请小内存的时候，直接去”中间商”去取就行了**，他就会在这 132KB 中按照要申请”货物”的多少进行分配下去。若”中间商”缺货了话，ptmalloc2 就继续去找”厂家”（系统内核）去取货

### 查看已分配的堆内存分布

在上面我们动态调试的时候已经执行了 malloc 函数，申请到的堆指针是保存在 eax 中的
![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/YTz6loS.png)

我们这里使用下面这个命令来查看内存堆块情况：

```undefined
x/32gx 0x602010-0x10
```

- 32位的程序使用 x/32xw 比较直观一点

这里减去 0x10 表示从堆块的头部开始观察（包含 pre size 和 size 字段）

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/TEiVMUc.png)

## main_arena和top chunk

**1.main_arena**是ptmalloc2堆管理器与1操作系统内核进行交互申请得到的，也就是上边申请的132KB，因为是主线程分配的，所以叫main_arena(通过增加program break loction)的方式增加main_arena的大小，在gdb调试中通过**"x/32gx &main_arena"**可以看到main_arena的内存分配情况。、

**2.top chunk**是堆中的一个堆块，带头的。程序以后分配的内存都要放在它的后边。在程序在向堆管理器申请内存的时候，没有合适的内存空间分配给它时，此时会从top chunk上剪切一部分chunk分配给它

## free函数和bins

### free函数

free函数与bins的分配息息相关。

例子

```cpp
#include <stdlib.h>
#include <string.h>

int main(){

        char *p;
        p = malloc(10)；
            memcpy(p,"Hello",5);
        free(p);
        return 0;
}
```

- 程序将 “Hello” 字符串复制到申请到的堆内存空间中。

编译后用 gdb 调试，在 call memcpy 处下一个断点，单步后将 “Hello” 复制到堆块中

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/MK9NWa8.png)

继续使用 x/32gx 0x602010-0x10 命令查看堆块情况

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/SkUxKXN.png)

继续单步 n，执行 free 函数之后，查看堆块情况

![img](%E5%A0%86%E5%AD%A6%E4%B9%A0/iifOKJV.png)

这里可以看出原本堆块中存储的内容已经被清空，然后**查看一下 main_arena 的值，发现其中 +0x8 的偏移处**，存储了指向已经 free 了的指针（指向头部，而不是 user data）

调用free函数，清空此堆块的use_data,并将此堆块的指针存储在main_arena中，或者fast_bin中。

### bin

bins这个概念与内存回收相关，堆管理器会根据用户已经申请到的内存空间大小进行释放，来决定放入哪类bins中，相当于垃圾分类。

**描述**

1.用户free掉的内存并不会马上还给系统，ptmalloc会统一管理heap和mmap映射区域中的空闲的chunk

2.当用户进行下一次分配请求时，ptmalloc会首先试图在空闲的chunk中挑选一块给用户，避免了频繁的系统调用。

3.ptmalloc将相似的chunk用双链表连接起来，这样的一个链表称为bin

4.ptmalloc一共维护了128个bin，并使用一个数组来存储这些bin

5.堆管理器将bin分为四类：**fastbin|unsortedbin|smallbin|largebin**

6.数组中bin 1为unsortedbin；2~63为smallbin；64~126为largebin

![](https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图 2023-03-18 192154.png)

#### fastbin

为了快速重新分配回内存而存在的结构，fastbin是使用最多的一类，结构也很简单
>fastbin所包含的chunk大小为16，24，32，80bytes。当分配一块较小的内存（<=64bytes），会首先在fastbin中移除并返回；否则通过其他方式(剪切top chunk)得到一块符合大小的chunk并返回。

**描述**

1.在32位操作系统中，当用户释放的堆块大小小于64B时使用fastbin进行管理，即chunk   空间最大为80字节
2.fastbin只使用了fd成员，是个单链表结构
3.fastbin不会对P位进行操作，也就是说它不会主动进行合并；只有在某些特定情况下，堆管理器才会对fastbin进行合并
4.fastbinY为管理fastbin的数组，每个成员分别管理不同大小的fastbin链表，且均指向了当前链表的尾节点，当尾节点被分配时，通过其fd指针指向前一个结点
5.当用户申请chunk大小小于或等于MAX_FAST_SIZE时，优先从fastbins中查找相应的空闲块，且规则为LIFO（Last in, first out, 后进先出）

例子

![](%E5%A0%86%E5%AD%A6%E4%B9%A0/image-20230318193939959.png)

此时0x0804a00处的chunk(实际chunk的size段要减去PREV_INUSE字段值1)被free，那么会被存储在40bytes的fastbin的内存地址中（地址存储的是指针，64位地址占8个字节），在main_arena中表示16，24，82，，，，，80bytes的内存地址中分别已经存储了已经free的而且满足相同大小的chunk。

**fastbin的特性**

**1.使用单链表来维护释放的堆块**

![](%E5%A0%86%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-18%20195928.png)

**2.使用先进后出的方式维护链表**

当程序需要重新malloc内存并且从fastbin中挑选堆块，会选择后边的新加入的堆块拿来进行内存分配，这里的话也就是直接使用第二次释放的堆块，将这个堆块从链表中移除，根据fk指针找到这个堆块，此时main_arena也指向这里

### unsortedbin

**描述**：

1. 当释放较小或较大的chunk的时候，为了增加分配效率，系统会先将最近释放的chunk添加到unsorted bin中

2. unsorted bin 为一个双向循环链表，对chunk的大小没有限制，即任何大小的chunk都可以放入unsorted bin链表中

3. 当fastbin，smallbin中的chunk不能满足用户申请的chunk的大小时，堆管理器会考虑使用unsortedbin。它会在分配large chunk之前对堆中碎片进行合并，以减少对中的碎片。

   unsortedbin使用的是双链表对chunk进行链接，可以看成不满足能够进行内存分配的堆块都放在unsortedbin中

#### smallbin

**描述：**

1. 在32位操作系统中，当用户释放的堆块大小大于64B，小于等于512B时使用small bin进行管理
2. small bin 为双向循环链表，且使用 FIFO（First in, first out, 先入先出） 算法
3. 当满足small bin条件的chunk被释放后，会优先被放入unosrted bin，只有在一定情况下，才会被分配到small bin中
4. 相邻的free chunk将会被合并成一个更大的fee chunk，增加内存利用率

# 深入理解堆

## 概念

**堆管理器处于用户程序和内核中间主要做以下工作：**

1.响应用户申请的内存，向操作系统申请内存，然后返回给用户程序。

2.管理用户释放的内存

注意：在内存分配与使用的时候，linux有一个基本内存管理思想，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实是虚拟内存。只有当用户使用相应内存的时候，系统才会真正分配物理页面给用户使用。

## 堆的基本操作

### malloc

malloc函数返回对应大小字节内存的指针，还进行了对异常情况的处理。如果申请的字节数为0，返回当前系统允许的堆的最小内存。如果申请的字节数为负数的时候，由于在大多数系统上，size_t是无符号数，所以程序就会申请很大的内存空间，通常会失败，因为没有足够的空间可以分配。

### free

free函数会释放由p指向的内存块，这个内存块可以通过malloc或者相关函数realloc得到的。同时也进行了对异常情况进行了处理。

当p为空指针，函数不执行。

当p已经释放，再次释放会出现乱七八糟的情况，这就是double free。

## 内存分配后的系统调用

无论是malloc函数还是free函数，我们动态申请或者释放内存的时候，都经常使用，但是它们并不是与系统进行交互的函数。这些函数背后的系统调用只要是(s)brk以及mmap，munmap函数。

### (s)brk

>对于堆的操作，操作系统提供了brk函数，glibc库提供了sbrk函数
>
>malloc的底层实现，用于分配开辟内存，但是brk函数是系统调用而sbrk不是，sbrk调用了sbrk

初始时，堆的起始地址start_brk以及堆的末尾brk指向同一地址。根据是否开启ASLR，两者的具体位置会不同。开启时start_brk和brk都指向data/bss段的结尾；开启后，start_brk和brk也会指向同一位置，只是这个位置在data/bss段的随机位置

### mmap

malloc会使用mmap来创建独立的匿名映射段。匿名映射主要目的主要是可以申请以0填充的内存，并且仅被调用进程所使用

###多线程支持
